This little document is a little primer on CSQC for people that have no understanding of it.
The reader is expected to have an understanding of SSQC basics (entities, globals, functions, prototypes, fields, etc).
As I am the primary author of FTEQW+FTEQCC, I am biased towards it and its feature set. I will attempt to include sidenotes where my instructions might not match other engines (namely: DarkPlaces), but the code examples given are intended to run in either engine.




Motivation for CSQC:
Quake's archetecture is that of client and server. Even in a single player game, your engine is running both a client and server simultaneously (for example, demos are simply a capture of all the server->client packets).
This archetecture brings with it the ability for new clients to connect mid-game, without having to have run the game right from the start of the map.
And this is the distinction between SSQC and CSQC.
Traditional QC code is compiled into a single progs.dat file which runs purely on the server. It controls where, when, and how things move from one place to another, and the server will automatically 'replicate' a subset of the current state of the game to each connected client each network frame, and that is that subset which the client draws (for terminology, Quake3 refers to these gamestate copies as 'snapshots', which is a good way to think of it).
SSQC, running on the server, has absolutely no control over the client beyond what it can send it. Primarily this includes snapshots, stuffcmds, stats, and 'temporary entities'. But worse than this, SSQC is commonly running on a remote machine, with latency, packetloss, and other networking limitations.

CSQC provides a way around these issues.
A) CSQC has full control over the screen. It can draw the game where it wants. It can draw a hud how it wants.
B) CSQC is running locally. It has no latency issues at all. Mouse movement is present directly within the frame that follows, rather than needing to bounce off the server.
C) CSQC can perform its own player prediction, allowing mods to freely provide their own player physics without breaking client expectations.
D) CSQC can interact with input devices like keyboard and mice, providing rich user interfaces.

CSQC's down sides.
A) CSQC is separate and distinct from SSQC. The two modules share no data (but may still share significant parts of code). You will need to learn how to get data from ssqc to csqc and vice versa.
B) As a large after-gpl feature, different engines tend to have their own interpretation of the CSQC spec. As a result, cross-engine compatibility may be hard, but is not impossible.
C) CSQC's versatility can be a curse. The engine tries to avoid doing too many things automatically, most noticably in regards to the screen - a CSQC mod with functions but no code results in nothing being drawn to the screen. Mods need a small bootstrap chunk of code to retain feature compatibility.
D) CSQC attempts to clean up the API slightly, which can result in certain differences between SSQC and CSQC.
E) Compared to SSQC, CSQC is often written in the context of a single client. It has a greater focus on callbacks, globals, and builtins to retrieve data from snapshots and other hiding places within the engine.
F) CSQC needs a certain amount of cheat protection. Thus there are limitations in place to ensure that the csprogs matches one available on the server (the original versions had other additional limitations!).
G) CSQC is running on the client, and is typically autodownloaded. The client must thus also place certain additional restrictions on console commands and cvars, just as it would via stuffcmds.

In essence, csqc sits somewhere between the middle of the client's renderer, networking, and input modules. Basically, the use input is filtered via csqc before going to the client/networking. Snapshots are still parsed by the engine's networking, but the renderer will not draw them without the csqc saying to do so.




Setting up a basic CSQC mod and compiling:
CSQC is compiled just like SSQC. Both start from a .src file, but typically a different one.
While you can use a progs.src inside a different directory, I will write this with the expectation that your CSQC's .src file can be found as eg: c:\quake\mymod\src\csprogs.src
Where SSQC outputs to a 'progs.dat' (or 'qwprogs.dat'), CSQC outputs to a 'csprogs.dat' file. This is forms the first line of your csprogs.src file. Typically with a ..\ prefix so that the qcc writes it to the right directory...
The second line of your csprogs.src should be to specify some sort of 'defs.qc' equivelent for CSQC. Sadly, CSQC has different system+field+builtin defs from SSQC and thus needs a different file.
With FTEQW, you can get the engine to generate such a file for you by issuing the command 'pr_dumpplatform -O csdefs -Tcs' at FTEQW's console (be warned that it includes FTEQCC extensions which will not work in other qccs). You'll want to copy this file to your src directory (instead of it being in your home dir where the qcc can't see it - the given command will name the system path that you'll need to copy it from). If you're exclusively targetting DP, you may wish to get DP-specific defs from other sources, but be warned that certain builtins may have different names, and you will need to work around that. For the things documented here, using an FTEQW-generated csdefs.qc should work okay with current DP versions.
And the third line of your csprogs.src file should name one of your own code files (which you will need to write).

So, inside c:\quake\mymod\src\csprogs.src we have these lines:
../csprogs.dat  //the name of the file to 
csdefs.qc       //system defs to match the engine, including various extensions
view.qc         //name it whatever you want. This is where you will be writing code.

To make things easy (assuming you're using FTEQCC), you can add the following line to your defs.qc
#pragma sourcefile csprogs.src
This line will cause fteqcc to automatically start compiling your csprogs.dat after it compiles your progs.dat. Its one of those convienience features.
Note that this will not affect your actual progs.dat file (beyond compiling it).
Alternatively you can rename your progs.src to ssprogs.src, and make a new progs.src that contains two pragmas that name your two src files, then you can freely choose just ssqc, just csqc, or both.
Or you can instead use separate batch files and the -srcfile argument to distinguish between which src file to use.
Create an empty view.qc file and try compiling. You should get a csprogs.dat from it (side note: if you used DP-specific defs instead, you'll get errors about functions not being defined, you'll need to make stubs for these at some point, typically they'll need to return false).




Our first Code (the 3d game view):
open up your empty view.qc file and add this function:
void(float width, float height, float menushown) CSQC_UpdateView =
{
	drawfill('0 0 0', [width, height, 0], '1 1 0', 1, 0);
	drawstring('0 0 0', "Hello, World", '8 8 0', '0 0 1', 1, 0);
};
If you save+compile+run, you will now find that your fledgeling mod has had its first effect... The game view has disappeared, to be replaced by a yellow screen! oh noes! By adding that function, the engine now knows you want to take explicit control of the screen, and it is no longer doing that automatically for you. So we need to at least get back to what we had. This will need some explaination. If you're just aiming for a hud and nothing else, you can grab the example code at the end of this section and otherwise skip this section.

Contrary to 2d drawing, 3d drawing in csqc is based around building up an entire scene then telling the renderer to do its stuff in one go. This model is somewhat derived from the way Quake3 works, and allows the engine to provide its own shadow, rtlight, etc effects within the gameview as a whole. 3d rendering is thus based upon the concept of an active scene or view (with its set of view properties), as well as a list of the entities present in that scene.
Due to certain expectations with input, the scene is NOT normally cleared automatically by the engine. Even if it was, certain default properties change over frames anyway (like the player position). Thus the First thing we need to do is to clear the scene with:
clearscene();
Well, okay, that function name was a little obvious. Remember I said that the scene had various 'view properties'? Well, clearscene just set them to their default values for you. However, the default is for the engine to not draw a hud at all. So if only as an example of how to reconfigure scene properties, you'll need the following line too:
setviewprop(VF_DRAWENGINESBAR, 1);
Lets throw in a crosshair too:
setviewprop(VF_DRAWCROSSHAIR, 1);
For reference:
//setviewprop(VF_MIN, '0 0 0');
//setviewprop(VF_SIZE, [width, height, 0]);
Will allow you to move the 3d view around on the screen. The min+size values should be in virtual positions, but DP currently uses physical pixels (sidenote: alternative coordinate systems SUCK!)
Right, so now our scene includes a crosshair, a status bar (aka: hud). The view position and angles are in their default positions (ie: angle pulled from client state, origin pulled from prediction or lerped from snapshots).
Its still not being drawn though. We've only said where it should be. We've not actually said to draw it.
So lets do that for the luls:
renderscene();
Urr, yeah, another obvious name there from Mr Imaginative.
If you compile and run, what do we get? Try it!
You didn't try it did you. You just read the next line without bothering... Well, if you HAD run it, you would have seen that we now get a fullscreen view of the game, with an sbar and the world. We can run around as normal... But there's something missing, and that, my friend, is entities.
renderscene will not automatically hunt for entities for you. The easiest way to achieve this is with the following line:
addentities((intermission?0:MASK_VIEWMODEL)|MASK_ENGINE);
Of course, you'll want to ensure that the call is between clearscene and renderscene, or they'll just be wiped at the start of the next frame.
This builtin reaches into the networking snapshot code and pulls out all the entities that match the masks. MASK_ENGINE refers to the snapshot entities. MASK_VIEWMODEL refers to the entity that is normally generated from your ssqc player's .weaponmodel and .weaponfame fields (which you generally don't want to appear during intermission).
If you have spawned some entities in csqc, you can call addentity(yourent) to add a copy of it the scene also. This is useful for one-only entities like custom view models being predicted in csqc.
But for csqc entities, the easiest way to add them to the scene is to set your entity's .drawmask to something evil like MASK_ENGINE, and then addentities will automatically add it to the scene for you. More on this later.

One thing to note about the following code is that getviewprop also exists, if you wish to read a default like VF_ORIGIN. For instance, you can make the view bob randomly by reading its current position, adding sin(time*period)*magnitude to the z coord.

So, to compact that into something small for the lazy people who skipped most of this section. I'll add a few other no-op values commented out as the value given is the default(ish) already.
void(float width, float height, float menushown) CSQC_UpdateView =
{
	clearscene();					//wipe entity lists. reset view properties to their defaults.
	setviewprop(VF_DRAWENGINESBAR, 1);		//draw a status bar (or hud or whatever the engine normally does) around the screen.
	setviewprop(VF_DRAWCROSSHAIR, 1);		//draw a crosshair in the middle of the screen.
	//setviewprop(VF_ORIGIN, '0 0 0');		//view position of the scene (after view_ofs effects).
	//setviewprop(VF_ANGLES, '0 0 0');		//override the view angles. input will work as normal. other players will see your player as normal. your screen will just be pointing a different direction.
	//setviewprop(VF_DRAWWORLD, 1);			//whether the world entity should be drawn. set to 0 if you want a completely empty scene.
	//setviewprop(VF_MIN, '0 0 0');			//top-left coord (x,y) of the scene viewport in virtual pixels (or annoying physical pixels in dp).
	//setviewprop(VF_SIZE, [width, height, 0]);	//virtual size (width,height) of the scene viewport in virtual pixels (or annoying physical pixels in dp).
	//setviewprop(VF_AFOV, cvar("fov"));		//note: fov_x and fov_y control individual axis. afov is general
	//setviewprop(VF_PERSPECTIVE, 1);		//1 means like quake and other 3d games. 0 means isometric.
	addentities((intermission?0:MASK_VIEWMODEL)|MASK_ENGINE);	//add various entities to the scene's lists.
	renderscene();					//draw the scene to the screen using the various properties.
};




Our first hud (2d stuff and stats):
Unlike 3d stuff which uses some huge complex scene concept, 2d stuff is immediate only. All 2d drawing calls are immediately sent to the renderer in the exact order they are given, and can thus overlap without issues. Later calls will always overwrite whatever is already on the screen at the position specified.
First of all, add a call at the bottom of your CSQC_UpdateView function to some Hud_Draw function:
Hud_Draw([width, height]);
And then include the following code just before your CSQC_UpdateView function (or in a different file ideally, just be sure to prototype etc like you would in ssqc):
float stitems, stitems2, stweapon;
void Hud_Draw(vector scrsz)
{
	vector pos = [(scrsz_x-320)/2, pos_y = scrsz_y - 24, 0];	//calculate the top-left of the sbar, assuming it is 320 units wide and placed in the bottom-middle of the screen
	//get some commonly refered to values
	stitems = getstatbits(STAT_ITEMS, 0, 23);			//this is the player's self.items value (STAT_ITEMS is generated specially by the server)
	stitems2 = getstatbits(STAT_ITEMS, 23, 9);			//this is the player's self.items2 value if it exists, otherwise it is the serverflags global
	stweapon = getstatf(STAT_ACTIVEWEAPON);				//this is the player's self.weapon value.

	drawpic(pos, "sbar", '320 24 0', '1 1 1', 0.5, 0);		//draw the sbar background image slightly transparently

	Hud_DrawLargeValue(pos+'24 0 0', getstatf(STAT_ARMOR), 25);
	Hud_DrawLargeValue(pos+'136 0 0', getstatf(STAT_HEALTH), 25);
	Hud_DrawLargeValue(pos+'248 0 0', getstatf(STAT_AMMO), 10);
};

And here's the helper function I used which wasn't defined above.
void(vector pos, float value, float threshhold) Hud_DrawLargeValue =
{
	float c;
	float len;
	string s;
	if (value < 0)
		value = 0;	//hrm
	if (value>999)
		value = 999;
	s = ftos(floor(value));
	len = strlen(s);
	pos_x += 24 * (3-len);
	if (value <= threshhold)
	{	//use alternate (red) numbers

		while(len>0)
		{
			len-=1;
			c = str2chr(s, len);
			drawpic(pos+len * '24 0 0', sprintf("anum_%g", c-'0'), '24 24 0', '1 1 1', 1, 0);
		}
	}
	else
	{	//use normal numbers

		while(len>0)
		{
			len-=1;
			c = str2chr(s, len);
			drawpic(pos+len * '24 0 0', sprintf("num_%g", c-'0'), '24 24 0', '1 1 1', 1, 0);
		}
	}
};

Okay, try running that.
Now you get your basic sbar appearing, with health and armor values, that goes red if the values are low.
Note that I'm not going to give any more hud code. Go write your own! Here's one I wrote earlier: http://sourceforge.net/p/fteqw/code/HEAD/tree/trunk/quakec/csqctest/src/cs/hud.qc?format=raw

There's a few generic builtins there which you may have never seen before. sprintf: generates a formatted temp-string (%g, %f are replaced with a float argument, %s uses a string argument, %v uses a vector argument, most other things can use %i for debugging), str2chr(x,y): reads the character at position Y from string X. These are both available in ssqc as parts of various extensions and are really quite useful.
Here are the builtins for 2d stuff:
vector(string picname) drawgetimagesize = #318;										//retrieves the size of a picture.
float(vector position, float character, vector size, vector rgb, float alpha, optional float drawflag) drawcharacter = #320;//draws a single character.
float(vector position, string text, vector size, vector rgb, float alpha, optional float drawflag) drawrawstring = #321;//draws a string without stopping for colour codes
float(vector position, string text, vector size, vector rgb, float alpha, float drawflag) drawstring = #326;		//supports colour codes
float(vector position, string pic, vector size, vector rgb, float alpha, optional float drawflag) drawpic = #322;	//draw a picture on the screen. gfx/foo.lmp, or no extra path+extension for wad images.
float(vector position, vector size, vector rgb, float alpha, optional float drawflag) drawfill = #323;			//draws a simple box
float(string text, float usecolours, optional vector fontsize) stringwidth = #327;					//gets the virtual width of the string, so you can size things properly.
void(vector pos, vector sz, string pic, vector srcpos, vector srcsz, vector rgb, float alpha, optional float drawflag) drawsubpic = #328;//draws a subregion of a picture.
All of those builtins can be used to draw various 2d stuff. Using different fonts is an extra extension that I'm too lazy to explain here.
But there's also getstatf and getstatbits that need some explaining. To do so, I'll need to explain the network protocol a little.

Quake's networking protocol is more than just entity snapshots. It also includes a concept of stats. In NQ, different stats are transfered to the client with various limitations, while in QW they're generally more generic. Generic aproaches are good, so all stats are exposed via the same sort of interface similar to the one that the engine uses.
Basically, all the various player-specific fields form the various bits of your hud are various 'stats' (technical term rather than general term).
The first 32 stats are reserved by the engine for one reason or another, either for future expansion or because its just part of the protocol that has always existed (they are typically some representation of various player fields and are safe to read - later ones may depend upon server extensions). Stats between 32 and 127 inclusive are 'free' stats reserved for mod-specific purposes by QC.
getstatf reads the numeric stat into a float.
getstati reads the numeric stat into an integer (as most qc code doesn't support ints, you would normally think it useless).
getstats reads a string stat, returning a tempstring.
getstatbits is a bit more awkward, and is provided only for legacy compatibility with STAT_ITEMS. This needs more explaining... STAT_ITEMS, as you will see in the Hud_Draw function I gave you, is read twice. Why read it twice, you might ask... Because STAT_ITEMS is an integer bitfield over the network. Worse - the upper bits of this integer (which cannot normally be used in floats due to precision) is packed with info on runes currently held! So, in order to read both parts of this stat, you need a special builtin which can decode the various integer bits into a float which qc can actually use. The positions and bitcounts should generally be useable for any mod, although you might need to handle runes being a little shifted if your mod does not make use of items2.
So that's how you read a stat, but you'll still need to know how to create your own stats for your awesome hud, and that requires some ssqc (which is where the info is).

The main way to add a stat is with this builtin:
void(float num, float type, .__variant fld) clientstat = #232;
Which is typically invoked from worldspawn using something like:
clientstat(STAT_MYSUPERSTAT, EV_FLOAT, mysuperstat);
where mysuperstat was defined in defs.qc or whereever as:
.float mysuperstat;
And, as noted above, is read with getstatf(STAT_MYSUPERSTAT)
You'll want to share the STAT_FOO defines between ssqc+csqc.

.int foo; clientstat(STAT_FOO, EV_INTEGER, foo); int myfoo = getstati(STAT_FOO); works too, if your qcc+engine support integers.
.string foobar; clientstat(STAT_FOOBAR, EV_STRING, foobar); string myfoobar = getstats(STAT_FOOBAR); works as well. Hurrah.
.entity enemy; clientstat(STAT_ENEMYNUM, EV_INTEGER, foo); float myenemynum = getstatf(STAT_ENEMYNUM); works too, if your qcc+engine support integers.
However, vectors are not normally supported as stats. You will need to separate the various componants (ie: myvector_x) and send+read as 3 separate floats.
Entities are sent only as numbers _in the ssqc_. The numbers don't always match up, thus findfloat(world, entnum, getstatf(STAT_ENTNUM)) generally needs to be used if its to refer to some csqc entity. Note that it may still evaluate to world, as entities may not be in the pvs or may not even be visible to csqc. Stats and snapshots may all have different latency and arrive at different times due to packetloss or whatever.
As noted above, those custom STAT_FOO values should normally be between 32 and 127 for futureproofing. You can generally go higher too, but its not guarenteed.

Sidenote: DP compat with stats is more awkward. Unlike FTEQW, DP still has exclusively integer stats. numeric stats are specifically integer stats thus float stats are thus rounded towards 0. strings on the other hand are limited to 15 chars, and actually consume 4 consecutive stats. If you actually need floating point precision with DP, you can tell the engine that the stat is actually an integer, using ev_integer and getstati. Doing so will avoid truncation and has resulted in some enterprising dp users renaming getstati to getstatf just to confuse everyone, so be careful of that if you're using dp-specific defs...




User Input (guis):
User input (keyboard and mice and stuff) can be intercepted using the CSQC_InputEvent function.
This function is a generic entry point for multiple different sorts of events. The type of event is passed in evtype. The later arguments have different meanings depending on the event type.
Event handling is basically implemented via interception. That is, if you want to do something with the event you can do so, and you can then 'cancel' the event in the engine's eyes by returning TRUE.
So, if you did something and now want the engine to ignore it, return TRUE. If you want the engine to handle the event for you, return FALSE.
Note that not all events can be meaningfully canceled, and other events should not be canceled.
For example, if the user presses a key, the key has been pressed, the unicode meaning of that key combination is still determined (normally by the operating system), and you will still receive a release event when the user releases the key, but by cancelling the event, you can get the engine to avoid doing any key binding logic. Of course, key UP events should generally never be canceled as a general rule. The reasoning for this is that if you are cancelling up events, you must be very careful in tracking down events and the owners of those down events, because if you cancel a down event and NOT an up event, you can end up with the engine's key binding system thinking a key is still pressed and thus with the player running forwards endlessly.
So:
Key down events:
	scanx: this is the quake KEY_ code value associated with the physical hardware button. May be set to 0. You'll always get the same code for each key regardless of whether shift etc are pressed also.
	chary: this is the unicode code point of the key. May be set to 0. You'll get different values from the same key depending on whether shift etc is pressed.
	devid: for mouse buttons, this is a mouse-device/touch-event id (see mouse absolute events for details). for keyboard buttons, this is a keyboard device id.
	cancel to avoid bindings (like disabling weapon switches or +forward etc).
	Either scanx or chary may be set to 0, but not both at the same time.
	Some windowing systems support scanx and chary both being set in a single call (like scanx==KEY_1 and chary=='!'), or may invoke the function twice (ie: scanx==KEY_1 and chary==0, and scanx==0 and chary=='!').
	This is significant when it comes to dead keys and unicode input in certain locales.
	Thus if you are typing, you should use ONLY chary for actual typing, with scanx for control keys like the cursor keys+delete, and otherwise support bindings via the scanx value and ignore chary.
key up events:
	scanx: as in key down events.
	chary: as in key down events.
	devid: as in key down events.
	It is not guarenteed that you will receive unicode up events as the windowing system may not support it, but you will receive scancode up events.
	cancelling avoids cancelling -forward type bindings which should normally always be safe for duplicates, thus cancelling up events should generally be avoided.
mouse motion events:
	scanx: how many pixels across the screen the mouse has moved (scaled in terms of virtual pixels, so may be fractional).
	chary: how many pixels down the screen the mouse has moved (scaled in terms of virtual pixels, so may be fractional).
	devid: a mouse device or touch event id. see mouse absolute events for details.
	If running a UI, you would want to add the two values to the previous mouse cursor position before returning TRUE.
	cancel to avoid the engine changing view angles.
mouse absolute events:
	scanx: the absolute X position on the screen in terms of virtual pixels.
	chary: the absolute X position on the screen in terms of virtual pixels.
	devid: a mouse device or touch event id.
	The device id for mice and touch events can be somewhat complex.
	For mice, you are likely to see all mice appear as id 0, simply because the operating system merges all mouse devices to simulate a single one which is all the engine can see.
	On windows, you tend to need an engine that supports raw input in order to get distinguishable mouse devices.
	When used in a mouse-driven user interface, a mouse devid is a simple mouse device id that is constant for every event that the mouse generates.
	For touch events, things are more complicated. Touch ids have a limited life span in order to facilitate multitouch screens.
	A multitouch sequence thus follows these lines:
		mouse absolute
		key down (scanx=key_mouse1)
		mouse absolute etc
		key up (scanx=key_mouse1)
	After which, the touch id can be recycled as a different touch event.
	(Side note: to test multitouch in fteqw+vista+, use these console commands: in_simulatemultitouch 1; in_rawinput 1; in_restart; note that you will need multiple mice plugged in, one for each 'finger')
	A mouse device may use either mouse motion or mouse absolute events depending on whether the mouse is grabbed for use exclusively with quake or not.
	It is not uncommon for engines to automatically switch to absolute positions when the console is down.
	cancel to avoid changing view angles if the engine has some sort of touchscreen mode enabled, otherwise does nothing.
accelerometer events:
	scanx: x acceleration
	chary: y acceleration (-9.8 (gravity) if the screen is held vertically I believe)
	devid: z acceleration (-9.8 (gravity) if the screen is flat facing upwards)
focus events:
	scanx: now has mouse focus. true=focused. false=unfocused. -1=unchanged
	chary: now has keyboard focus. true=focused. false=unfocused. -1=unchanged
	devid: the mouse or keyboard for which focus changed.
	for the sake of simplicity, you can just ignore any events with a devid other than 0.
	note that it is the engine's choice whether the qc receives input or not. if the console or the menus are active, those may exclusively receive input instead.
	
So for a windowing system with a mouse cursor and a simple text field, we can write this simple code:
string userinputtext;
vector mousecursor;
float(float evtype, float scanx, float chary, float devid) CSQC_InputEvent =
{
	switch(evtype)
	{
	case IE_KEYDOWN:
		string newt = userinputtext;
		if (scanx == KEY_BACKSPACE)
			newt = substring(newt, 0, -2);	//-1 = end of string. -2=one char before the end of the string
		else if (scanx == KEY_ENTER)
		{
			//send it to the server in the form of a say command. just to show some useful(ish) interaction with the server.
			localcmd(strcat("cmd say ", userinputtext, "\n"));
			newt = "";
		}
		else if (chary)
			newt = strcat(newt, chr2str(chary)); //add the char to the end.
		else if (scanx == KEY_MOUSE2)
			newt = ""; //clear it on right click.
		//other scancodes not recognised, but don't add redundant 0s on the end.
		//temp strings are not valid between calls.
		if (newt != userinputtext)
		{
			strunzone(userinputtext);
			userinputtext = strzone(newt);
		}
		break;
	case IE_KEYUP:
		return FALSE;	//don't break things if the menu was enabled mid-game while other keys are potentially still held, or some other way.
	case IE_MOUSEDELTA:
		//note: we can cope with multiple separate mouse devices here.
		mousecursor_x += scanx;
		mousecursor_y += chary;
		return TRUE; //don't change view angles
	case IE_MOUSEABS:
		if (devid != 0)	//no stuttering please.
			return FALSE;
		mousecursor_x = scanx;
		mousecursor_y = chary;
		return TRUE; //don't change view angles
	default:
		break;
	}

	return FALSE;
};
//NOTE: this conflicts with previous examples! skip the drawfill and add the rest after your renderscene call or something.
void(float width, float height, float menushown) CSQC_UpdateView =
{
	drawfill('0 0 0', [width, height, 0], '1 1 0', 1, 0);	//clear the screen
	drawstring('0 0 0', userinputtext, '8 8 0', '0 0 1', 1, 0);	//draw their input text
	float sc = (sin(time*8)+1.5)*8
	drawcharacter(mousecursor - '0.5 0.5 0'*sc, '+', sc*'1 1 0', '0 0 1', 1, 0);	//draw a lame cursor with pulsing size (to distinguish it from any possible engine cursor)
};

Of course, as you go further into windowing systems, you'll need to make some sort of heirachy or screen regions or some other logic so that things can be clicked on. Explaining how to write UI wigits is somewhat outside of the scope of this tutorial, so look elsewhere for such things.

If you wish to use a 2d mouse cursor to interact with 3d positions, you can do something like:
vector() CursorToWorldCoord =
{
	vector wnear = unproject([mousecursor_x, mousecursor_y, 0]);	//determine the world coordinate for the mouse cursor upon the near clip plane
	vector wfar = unproject([mousecursor_x, mousecursor_y, 100000]);//determine the world coordinate for the mouse cursor upon the far clip plane, with an outrageously large value as a workaround for dp.
	traceline(wnear, wfar, TRUE, world);
	return trace_endpos;
};
Similarly:
vector(vector worldpos) WorldToScreen =
{
	vector twodee = project(worldpos);
	twodee_z = 0;	//discard all depth info (note that depth is typically scaled between 0 and 1, so avoid)
	return twodee;
};




Right, now its time to explain CSQC-only entities in proper detail:
I'm going to introduce you to a new entrypoint just for the luls:
void(float apiver, string enginename, float enginever) CSQC_Init =
{	//note: the three arguments are engine-defined, and can be used to to detect if the engine version you're running in has bugs. Just call error("please update your engine") if it's got known fatal bugs, but try not to exclude engines you've not tested against (ie: forks where your code will otherwise work fine).
	local entity foo = spawn();
	precache_model("progs/player.mdl");	//or something else
	setmodel(foo, "progs/player.mdl");	//same as ssqc, see, its easy!
	setorigin(foo, '0 0 0');		//you'll need to fix the origin to ensure you don't put it in a wall...
	foo.drawmask = MASK_ENGINE;		//cause the entity to be added to the scene automatically via the addentities(MASK_ENGINE) builtin.
};

So yeah, when the csprogs is loaded, the CSQC_Init function is automatically called by the engine. Inside we spawn an entity, just like we would in ssqc. Give it a position, just like you would in ssqc, etc.
In fact, the only difference so far is the extra drawmask line. This line is so that the core csqc can handle subviews gracefully instead of all entities being added to the scene unconditionally.
So if we try running it, our CSQC_UpdateView (at least ones that actually draw a view) automatically pick up our new entity, but we've not set a think function nor are we trying to animate it.
CSQC entities do not interpolate or autoanimate, nor does the engine interpolate them. What's worse, is that think functions with their predefined interval can result in video frames skipping with jerky animations! oh noes!
So lets add an extra csqc-specific line to where you spawned your entity.
foo.predraw = AnimateSomeLameModel;
Nice simple function field assignment there...
And we need to define that function. Here's one I wrote earlier:
float() AnimateSomeLameModel =
{
	#define FIRSTFRAME 0
	#define NUMFRAMES 6
	self.lerpfrac -= frametime * 10;	//animate at 10fps
	while(self.lerpfrac < 0) //protects against sudden low framerates.
	{
		self.frame2 = self.frame; //if we're at 0, frame2 became redundant anyway
		self.frame += 1;	//move on to the next frame
		if (self.frame >= FIRSTFRAME+NUMFRAMES) //this should be relative to the current animation that should be shown
			self.frame = FIRSTFRAME;	//restart it.
		self.lerpfrac += 1; //go to the start of the frame
	}

	makevectors(getviewprop(VF_ANGLES));	//set v_forward etc.
	vector vieworg = getviewprop(VF_ORIGIN);//read the current view origin
	setorigin(self, vieworg + v_forward*128);//reposition the entity to 128 units infront of the view so it doesn't get lost in the wall, so we know its visible.
	return FALSE;
};
Yes, its completely lame, but it demonstrates the basics of animation, which is what is important, right?
Anyway, the three fields 'frame', 'frame2', and 'lerpfrac' work together to provide animation blending. A lerpfrac of 1 means that only frame2 is used, while a lerpfrac of 0 means that only frame is used. A lerpfrac of 0.5 means that both are used with the result being 50% between them. If you don't do the lerpfrac thing and instead just set frame inside some think function, the animation will NOT be smooth due to the lack of auto interpolation.
With the code above, I've made lerpfrac act as a stepping timer that keeps counting down from 1 to 0. when it drops below 0, a new frame is chosen and the old one is archived off in frame2 and lerpfrac is reset to about 1. This means that the frame choice after a frame switch is still mostly the old frame, blending into the new frame over time.
Be warned that frametime is in local time rather than tied to server time, and thus the animation is purely clientside with no relation to server timings and is thus unsyncronised. If you want a more robust solution, you would need to syncronise based upon the time difference between time and some starttime value when the new action became valid.
Sidenote: To animate within a framegroup, you will need to update self.frame1time and self.frame2time each frame. This is the absolute time into the animation. If you increment the value by something like: frametime*distance_traveled/animated_distance_traveled, it should be possible to achieve foot syncronisation with different movement speed settings.




CSQC Entity Networking:
CSQC entity networking is works with callbacks, and includes tolerance for packetloss and latency. Basically, the SSQC sets various SendFlags on the entity to say which parts of the entity have changed, and the server calls the SendEntity callback in order to build an update mssage at some point in the future. The callback is told the SendFlags that need to be sent.
The redundantcy and vauge wording is where packetloss tolerance comes in. Basically, the server is responsible for tracking the flags in each message, and any which never arrived on the client must be resent. This can take a successful round-trip before dropped packets are noticed, hence the 'in the future', and why the callback is told the fields which got dropped.
The network message itself is framed only by the entity number. The callback is responsible for stating exactly what sort of entity it is, and what is actually inside the message. This is typically achieved with a leading entitytype id byte.

In SSQC:
float(entity to, float sendflags) MySendEntity =
{
	WriteByte(MSG_ENTITY, 5);		//write some entity type header
	WriteByte(MSG_ENTITY, sendflags);	//tell the csqc what is actually present.
	if (sendflags & 1)
	{
		WriteCoord(MSG_ENTITY, self.origin_x);
		WriteCoord(MSG_ENTITY, self.origin_y);
		WriteCoord(MSG_ENTITY, self.origin_z);
	}
	if (sendflags & 2)
		WriteByte(MSG_ENTITY, self.frame);

	if (sendflags & 128)
		WriteByte(MSG_ENTITY, self.modelindex);	//sending a modelindex is smaller than sending an entire string.

	return TRUE;	//handled. If you return FALSE here, the entity will be considered invisible to the player.
};

In your spawn function:
	self.SendEntity = MySendEntity;
And when the origin changes:
	self.SendFlags |= 1;
And when the frame changes:
	self.SendFlags |= 2;
Note how the SendEntity function refers to sendflag 128, but its not set anywhere. Well, 'new' entities always have sendflags set to 0xfffff or something just large enough to avoid overflowing floats. Thus entities which have just been spawned or otherwise have just entered a player's pvs will always have sendflag bit 128 set, and thus the modelindex will be sent for such new entities without needing to explicitly state it.

From the CSQC side, the engine notices the entity update and then calls CSQC_Ent_Update. If the entity is new, it calls CSQC_Ent_Update beforehand.
The CSQC must then read whatever header the ssqc wrote, determine what sort of entity it is, and determine what the meaning of the various fields are.
Once the SSQC removes the entity or it just becomes invisible, the server will send a remove event, which the client will handle by calling CSQC_Ent_Remove. The CSQC is expected to then call remove(self) before returning.
void(float isnew) CSQC_Ent_Update =
{
	float enttype = readbyte():
	float flags;
	switch (enttype)
	{
	case 5:
		flags = readbyte();
		if (flags & 1)
		{
			self.origin_x = readcoord();
			self.origin_y = readcoord();
			self.origin_z = readcoord();
			setorigin(self, self.origin);	//for correctness.
		}
		if (flags & 2)
			self.frame = readbyte();
		if (flags & 128)
		{
			setmodelindex(self, readbyte());
			self.drawmask = MASK_ENGINE;
		}
		break;
	default:
		error("Unknown entity type! oh noes! panic!");
	}
};
void() CSQC_Ent_Remove =
{
	remove(self);
};
As you add new types of entities, you'll need to add more cases. Ideally you'd just move much of that code into a function call.
Also, you might want to combine the enttype byte and the flags byte, at least for entities which don't have many flags.
If you keep your entity networking fairly generic, you can combine various projectiles into common classes, and doing so shouldn't really need more than 16 different classes, thus giving four flags for potentially less overhead. But that's optimisation talk and thus perhaps out of place here. Anyway, you get the idea.
The above example is very simplistic, of course, as it only sets origin, frame, and model.
There's a few things to look out for. As described in the previous section, there is no automatic interpolation or animation lerping, so you'll need to combine that with the predraw stuff. To interpolate positions, you'll have to keep track of the update time, old update time, new origin and old origin. lerping is then:
local float frac = (time - self.lastupdate) / (self.lastupdate - self.prevupdate);
frac = bound(0, frac, 1);
self.origin = self.prevorigin + (self.lastorigin-self.prevorigin) * frac;
You can of course make assumptions along the lines of an entity updating 10 times a second on the dot, which may or may not result in more robust interpolation.
When interpolating angles, be sure to take care with wrapping from 360 down to 0. 




Prediction:
In theory, prediction is easy. Simply keep an input frame log, track which input frame was the last one applied to movement data, and applay any unacknowledged input frames to the last state received using the same logic that the server will use.
In practise, prediction is not reliable. It is a guess. A guess which is not particuarly compatible with traditional NQ player entity physics frames with their lack of syncronisation or even acknowledgements.
Generally this means that you must implement ALL player physics code yourself, using tracebox. Alternatively you may be able to get away with using the engine's runstandardplayerphysics function instead, modifying the various input_* values slightly before calling it.

From the SSQC side, things are fairly simple. The server calls:
void() SV_RunClientCommand =
{
	input_angles_y += 180; 		//a fun mindfuck.
	runstandardplayerphysics(self); //and apply the input frame to the current entity state.
}:

From the CSQC side, when you receive an entity state the servercommandframe global will say the input frame number that was last acknowledged by the server. Thus any player entity from the server will have this input frame already applied. While the clientcommandframe global is the input frame that is currently being generated.
Thus if 'self' has its fields set to the most recently received state, you can apply all pending input frames with:
for (if = servercommandframe+1; if <= clientcommandframe; if+=1)
{
	if (!getinputstate(if))
		continue;		//that input frame is too old.
	input_angles_y += 180; 		//a fun mindfuck.
	runstandardplayerphysics(self);	//and apply the input frame to the current entity state.
};
The input frame that matches clientcommandframe is updated each frame, until it is finally sent at which point the global is bumped. Input frames will not be remembered forever, but will otherwise be static until they are forgotten.
You can then set the VF_ORIGIN view property to match the predicted position. You will also likely want to smooth out steps, and perhaps add error correction too.




Advanced Skeletal Animation (FTE_CSQC_SKELETONOBJECTS):
When animating players and such, you may desire more than just frames.
If you're using a skeletal model format (like IQM), then more complete bone control becomes available to you.
When your entity is first spawned after you set the model, add some code like:
	self.skeletonindex = skel_create(self.modelindex);
Each frame, update your .frame, .frame2, .lerpfrac, .frame1time, .frame2time accordingly and then call:
	skel_build(self.skeletonindex, self, self.modelindex, retainfrac, firstbone, lastbone, addfrac);
That call needs some explaining. Especially the last four arguments.
retainfrac is what fraction of the pose info to retain. At the start of each frame you should generally pass 0. Later calls will generally pass 1.
addfrac is what fraction of the animation data to add. Note that this also serves as a sort of scaler. All skel_build calls for each bone in a single skeletal object should add up to 1 to avoid extra scaling.
Using these two values you can blend multiple animations together, for instance allowing running animations to fade into a standing animation, or to blend both sideways and forwards running animations together at rates depending on direction+speed in order to achieve foot-sync.
firstbone and lastbone provide a way for you to affect only a specific region of the model. Beware that this requires that your skeleton has bones that are carefully ordered.
If firstbone is 0, it'll be corrected to 1. Bone 0 is not otherwise valid, as 0 refers to the entity position itself.
If lastbone is 0, it'll be replaced with the total bone count.
If ordered correctly, you can split the model by legs+torso by a bone at the base of the spine. With that achieved, you can find the spine bone with skel_find_bone(self.skeletonindex, "spine1") or so (depends what your model calls it), and then build the two parts of your animation with:
float() playerpredraw =
{
	//interpolate origin, and calc displacement
	//note: you probably want to replace this with prediction if you're working on the local player's entity.
	float frac = (time - self.lastupdate) / (self.lastupdate - self.prevupdate);
	frac = bound(0, frac, 1);
	vector newpos = self.prevorigin + (self.lastorigin-self.prevorigin) * frac;
	vector moved = newpos - self.origin;	//this is how much we've moved since the last render frame, note that it implies frametime.
	self.origin = newpos;
	//determine animation weights
	makevectors([0, self.angles_y, 0]);	//set v_forward,v_right vectors so we can do dot products to see how much of which direction the entity moved in.
	self.forwardweight += fabs(v_forward*moved) * 32;	//scaler should rise to 1 after 0.1 secs when moving at 320qu
	self.sideweight += fabs(v_right*moved) * 32;	//scaler should rise to 1 after 0.1 secs when moving at 320qu
	//clamp 
	float sc = self.forwardweight + self.sideweight;
	if (sc > 1)
		sc = 1/sc;	//greater than 1 would add negative legs...
	else if (moved_x || moved_y)
		sc = 1;		//don't drop any movement weights if we're moving
	else
		sc = max(0, sc - frametime * 10);	//drop down to 0 over 0.1 secs if we stopped moving.
	self.forwardweight *= sc;
	self.sideweight *= sc;
	self.lerpfrac = 0; //just in case...
	//add forward animation (retain frac = 0 to reset it)
	self.frame = $forwardanimation;
	self.frame1time = (self.forwardtime += frametime * (v_forward*moved));
	skel_build(self.skeletonindex, self, self.modelindex, 0, 0, spinebone, self.forwardweight);
	//add side animation (retain frac = 1 to not overwrite forward)
	self.frame = $sideanimation;
	self.frame1time = (self.sidetime += frametime * (v_right*moved));
	skel_build(self.skeletonindex, self, self.modelindex, 1, 0, spinebone, self.sideweight);
	//add idle animation (retain frac = 1 to not overwrite directions)
	self.frame = $standanimation;
	self.frame1time = (self.sidetime += frametime);
	skel_build(self.skeletonindex, self, self.modelindex, 1, 0, spinebone, 1-(self.forwardweight+self.sideweight));
	//add torso animation (retain frac = 0 to reset torso parts. note that this doesn't affect legs due to the bone ranges)
	self.frame = $torsoanimation;
	self.frame1time = time - torsostarttime;
	skel_build(self.skeletonindex, self, self.modelindex, 0, spinebone, 0, 1);
	return FALSE;
}
and in your spawn code:
	setmodel(self, "progs/skelplayer.iqm");
	self.skeletonindex = skel_create(self.modelindex);
	self.predraw = playerpredraw;
	self.drawmask = MASK_ENGINE;
and when its killed:
	skel_delete(self.skeletonindex);
Then when your entity is added to the scene (via addentities), the predraw function is called to interpolate your entity's origin and update its skeltal object.
You'll have to ensure your parse code updates lastupdate and prevupdate timestamps, along with lastorigin and prevorigin, that it updates the angles.
$forwardanimation etc frame macros will need to be set to the correct framegroups within the model (note that this code requires framegroups, and would become more complex if you wished to animate between descrete frames for each animation, but that doing so is possible by using lerpfrac and frame2 instead of frame1time).
The code does not interpolate angles, which is something you'll probably want to add, as well as add a concept of actions so that you can blend between idle+shoot animations as appropriate.




Ragdoll (FTE_QC_RAGDOLL / FTE_QC_RAGDOLL_WIP):
Ragdoll support is dependant upon ODE, which requires cvar("physics_ode_enable") to be set in order to work properly.
Once you have a skeletal object, you can add in ragdoll by calling skel_ragupdate(self, "doll foo.doll", 0); at the end of your predraw function (which will cause the ragdoll to update and move based upon an animated model, and then call skel_ragupdate(self, "animate 0", 0); once your entity dies and goes limp (typically, this is done part-way through the death animation, so the ragdoll inherits a certain amount of velocity from said animation).
The .doll file describes the bodies and joints within the model. If a body is set to animate, it will use the bone data your code specifies. If a body is not set to animate, it will be ragdolled even when the player is still alive. This can be used for things like ponytails, cloth, etc.

//Various globals that are used in this FTEQW example are defined here, they are not used by the engine itself

#pragma warning disable Q302
vector cursor_pos; /* Current mouse cursor position, updated in csqc_inputevent */
float g_width, g_height; /* Globals for screen width and height */

//Menu stuff
float in_menu; //what menu are we in
float time_in_menu;

// for keybinding
float active_bind_index;
float menu_click_held;

const float MENU_NONE = 0;
const float MENU_MAIN = 1;
const float MENU_JOIN = 2;
const float MENU_SETTINGS = 4;
const float MENU_BUY = 8;
const float MENU_HOST = 16;
const float MENU_PREGAME = 32;
const float MENU_POSTGAME = 64;

float in_input_box;
float input_cursor;

vector campos;
vector camang;

entity localplayer;

vector() readvector =
{
	vector r = '0 0 0';
	r_x = readcoord();
	r_y = readcoord();
	r_z = readcoord();
	return r;
};
/*
This file was automatically generated by FTE Quake v1.06
This file can be regenerated by issuing the following command:
pr_dumpplatform -O csdefs -Tcs -Ffte
Available options:
-Ffte       - target only FTE (optimations and additional extensions)
-Tnq        - dump specifically NQ fields
-Tqw        - dump specifically QW fields
-Tcs        - dump specifically CSQC fields
-Tmenu      - dump specifically menuqc fields
-Fdefines   - generate #defines instead of constants
-Faccessors - use accessors instead of basic types via defines
-O          - write to a different qc file
*/
#pragma noref 1
//#pragma flag enable logicops
#pragma warning error Q101 /*too many parms*/
#pragma warning error Q105 /*too few parms*/
#pragma warning error Q106 /*assignment to constant/lvalue*/
#pragma warning error Q208 /*system crc unknown*/
#pragma warning disable F211 /*system crc outdated (eg: dp's csqc)*/
#pragma warning enable F301 /*non-utf-8 strings*/
#pragma warning enable F302 /*uninitialised locals*/
#pragma target FTE
#ifndef CSQC
#define CSQC
#endif
#define FTE_PEXT_SETVIEW /* NQ's svc_setview works correctly even in quakeworld */
#define DP_ENT_SCALE
#define FTE_PEXT_LIGHTSTYLECOL
#define DP_ENT_ALPHA
#define FTE_PEXT_VIEW2
#define FTE_PEXT_ACURATETIMINGS
#define FTE_PEXT_SOUNDDBL
#define FTE_PEXT_FATNESS
#define DP_HALFLIFE_MAP
#define FTE_PEXT_TE_BULLET
#define FTE_PEXT_HULLSIZE
#define FTE_PEXT_MODELDBL
#define FTE_PEXT_ENTITYDBL
#define FTE_PEXT_ENTITYDBL2
#define FTE_PEXT_FLOATCOORDS
#define FTE_PEXT_VWEAP
#define FTE_PEXT_Q2BSP
#define FTE_PEXT_Q3BSP
#define DP_ENT_COLORMOD
#define FTE_HEXEN2
#define FTE_PEXT_SPAWNSTATIC
#define FTE_PEXT_CUSTOMTENTS
#define FTE_PEXT_256PACKETENTITIES
#define TEI_SHOWLMP2
#define DP_GFX_QUAKE3MODELTAGS
#define FTE_PK3DOWNLOADS
#define PEXT_CHUNKEDDOWNLOADS
#define EXT_CSQC_SHARED
#define PEXT_DPFLAGS
#define EXT_CSQC
#define BX_COLOREDTEXT
#define DP_CON_SET /* The 'set' console command exists, and can be used to create/set cvars. */
#define DP_CON_SETA /* The 'seta' console command exists, like the 'set' command, but also marks the cvar for archiving, allowing it to be written into the user's config. Use this command in your default.cfg file. */
#define DP_EF_ADDITIVE
#define DP_EF_BLUE
#define DP_EF_FULLBRIGHT
#define DP_EF_NODEPTHTEST
#define DP_EF_NODRAW
#define DP_EF_NOGUNBOB
#define DP_EF_NOSHADOW
#define DP_EF_RED
#define DP_ENT_CUSTOMCOLORMAP
#define DP_ENT_EXTERIORMODELTOCLIENT
#define DP_ENT_TRAILEFFECTNUM /* self.traileffectnum=particleeffectnum("myeffectname"); can be used to attach a particle trail to the given server entity. This is equivelent to calling trailparticles each frame. */
#define DP_ENT_VIEWMODEL
#define DP_GECKO_SUPPORT
#define DP_GFX_FONTS
#define DP_GFX_SKINFILES
#define DP_GFX_SKYBOX
#define DP_HALFLIFE_MAP_CVAR
#define DP_INPUTBUTTONS
#define DP_LIGHTSTYLE_STATICVALUE
#define DP_LITSUPPORT
#define DP_MD3_TAGSINFO
#define DP_MONSTERWALK /* MOVETYPE_WALK is valid on non-player entities. Note that only players receive acceleration etc in line with none/bounce/fly/noclip movetypes on the player, thus you will have to provide your own accelerations (incluing gravity) yourself. */
#define DP_MOVETYPEBOUNCEMISSILE
#define DP_MOVETYPEFOLLOW
#define DP_QC_ASINACOSATANATAN2TAN
#define DP_QC_CHANGEPITCH
#define DP_QC_COPYENTITY
#define DP_QC_CRC16
#define DP_QC_CVAR_DEFSTRING
#define DP_QC_CVAR_STRING
#define DP_QC_CVAR_TYPE
#define DP_QC_EDICT_NUM
#define DP_QC_ENTITYDATA
#define DP_QC_ETOS
#define DP_QC_FINDCHAIN
#define DP_QC_FINDCHAINFLOAT
#define DP_QC_FINDFLAGS
#define DP_QC_FINDCHAINFLAGS
#define DP_QC_FINDFLOAT
#define DP_QC_FS_SEARCH
#define DP_QC_GETSURFACE
#define DP_QC_GETSURFACEPOINTATTRIBUTE
#define DP_QC_MINMAXBOUND
#define DP_QC_MULTIPLETEMPSTRINGS /* Superseded by DP_QC_UNLIMITEDTEMPSTRINGS. Functions that return a temporary string will not overwrite/destroy previous temporary strings until at least 16 strings are returned (or control returns to the engine). */
#define DP_QC_RANDOMVEC
#define DP_QC_RENDER_SCENE /* clearscene+addentity+setviewprop+renderscene+setmodel are available to menuqc. WARNING: DP advertises this extension without actually supporting it, FTE does actually support it. */
#define DP_QC_SINCOSSQRTPOW
#define DP_QC_SPRINTF /* Provides the sprintf builtin, which allows for rich formatting along the lines of C's function with the same name. Not to be confused with QC's sprint builtin. */
#define DP_QC_STRFTIME
#define DP_QC_STRING_CASE_FUNCTIONS
#define DP_QC_STRINGBUFFERS
#define DP_QC_STRINGCOLORFUNCTIONS
#define DP_QC_STRREPLACE
#define DP_QC_TOKENIZEBYSEPARATOR
#define DP_QC_TRACEBOX
#define DP_QC_TRACETOSS
#define DP_QC_TRACE_MOVETYPE_HITMODEL
#define DP_QC_TRACE_MOVETYPE_WORLDONLY
#define DP_QC_TRACE_MOVETYPES
#define DP_QC_UNLIMITEDTEMPSTRINGS /* Supersedes DP_QC_MULTIPLETEMPSTRINGS, superseded by FTE_QC_PERSISTENTTEMPSTRINGS. Specifies that all temp strings will be valid at least until the QCVM returns. */
#define DP_QC_URI_ESCAPE
#define DP_QC_URI_GET
#define DP_QC_URI_POST
#define DP_QC_VECTOANGLES_WITH_ROLL
#define DP_QC_VECTORVECTORS
#define DP_QC_WHICHPACK
#define DP_QUAKE2_MODEL
#define DP_QUAKE2_SPRITE
#define DP_QUAKE3_MODEL
#define DP_REGISTERCVAR
#define DP_SND_SOUND7_WIP2
#define DP_SND_STEREOWAV
#define DP_SND_OGGVORBIS
#define DP_SOLIDCORPSE
#define DP_SPRITE32
#define DP_SV_BOTCLIENT
#define DP_SV_CLIENTCOLORS /* Provided only for compatibility with DP. */
#define DP_SV_CLIENTNAME /* Provided only for compatibility with DP. */
#define DP_SV_DRAWONLYTOCLIENT
#define DP_SV_DROPCLIENT /* Equivelent to quakeworld's stuffcmd(self,"disconnect\n"); hack */
#define DP_SV_EFFECT
#define DP_SV_EXTERIORMODELFORCLIENT
#define DP_SV_NODRAWTOCLIENT
#define DP_SV_PLAYERPHYSICS /* Allows reworking parts of NQ player physics. USE AT OWN RISK - this necessitates NQ physics and is thus guarenteed to break prediction. */
#define DP_SV_POINTSOUND
#define DP_SV_PRECACHEANYTIME /* Specifies that the various precache builtins can be called at any time. WARNING: precaches are sent reliably while sound events, modelindexes, and particle events are not. This can mean sounds and particles might not work the first time around, or models may take a while to appear (after the reliables are received and the model is loaded from disk). Always attempt to precache a little in advance in order to reduce these issues (preferably at the start of the map...) */
#define DP_SV_PRINT /* Says that the print builtin can be used from nqssqc (as well as just csqc), bypassing the developer cvar issues. */
#define DP_SV_SETCOLOR
#define DP_SV_SPAWNFUNC_PREFIX
#define DP_SV_WRITEPICTURE
#define DP_SV_WRITEUNTERMINATEDSTRING
#define DP_TE_BLOOD
#define DP_TE_CUSTOMFLASH
#define DP_TE_EXPLOSIONRGB
#define DP_TE_PARTICLECUBE
#define DP_TE_PARTICLERAIN
#define DP_TE_PARTICLESNOW
#define DP_TE_SMALLFLASH
#define DP_TE_SPARK
#define DP_TE_STANDARDEFFECTBUILTINS
#define DP_VIEWZOOM
#define EXT_BITSHIFT
#define EXT_DIMENSION_VISIBILITY
#define EXT_DIMENSION_PHYSICS
#define EXT_DIMENSION_GHOST
#define FRIK_FILE
#define FTE_CALLTIMEOFDAY /* Replication of mvdsv functionality (call calltimeofday to cause 'timeofday' to be called, with arguments that can be saved off to a global). Generally strftime is simpler to use. */
#define FTE_CSQC_ALTCONSOLES /* The engine tracks multiple consoles. These may or may not be directly visible to the user. */
#define FTE_CSQC_BASEFRAME /* Specifies that .basebone, .baseframe2, .baselerpfrac, baseframe1time, etc exist in csqc. These fields affect all bones in the entity's model with a lower index than the .basebone field, allowing you to give separate control to the legs of a skeletal model, without affecting the torso animations. */
#define FTE_CSQC_HALFLIFE_MODELS
#define FTE_CSQC_SERVERBROWSER /* Provides builtins to query the engine's serverbrowser servers list from ssqc. Note that these builtins are always available in menuqc. */
#define FTE_CSQC_SKELETONOBJECTS /* Provides container objects for skeletal bone data, which can be modified on a per bone basis if needed. This allows you to dynamically generate animations (or just blend them with greater customisation) instead of being limited to a single animation or two. */
#define FTE_CSQC_RAWIMAGES /* Provides raw rgba image access to csqc. With this, the csprogs can read textures into qc-accessible memory, modify it, and then upload it to the renderer. */
#define FTE_CSQC_RENDERTARGETS /* VF_RT_DESTCOLOUR exists and can be used to redirect any rendering to a texture instead of the screen. */
#define FTE_CSQC_REVERB /* Specifies that the mod can create custom reverb effects. Whether they will actually be used or not depends upon the sound driver. */
#define FTE_CSQC_WINDOWCAPTION /* Provides csqc with the ability to change the window caption as displayed when running windowed or in the task bar when switched out. */
#define FTE_ENT_SKIN_CONTENTS /* self.skin = CONTENTS_WATER; makes a brush entity into water. use -16 for a ladder. */
#define FTE_ENT_UNIQUESPAWNID
#define FTE_EXTENDEDTEXTCODES
#define FTE_FORCESHADER /* Allows csqc to override shaders on models with an explicitly named replacement. Also allows you to define shaders with a fallback if it does not exist on disk. */
#define FTE_FORCEINFOKEY /* Provides an easy way to change a user's userinfo from the server. */
#define FTE_GFX_QUAKE3SHADERS /* specifies that the engine has full support for vanilla quake3 shaders */
#define FTE_GFX_REMAPSHADER /* With the raw power of stuffcmds, the r_remapshader console command is exposed! This mystical command can be used to remap any shader to another. Remapped shaders that specify $diffuse etc in some form will inherit the textures implied by the surface. */
#define FTE_GFX_MODELEVENTS /* Provides a query for per-animation events in model files, including from progs/foo.mdl.events files. */
#define FTE_ISBACKBUFFERED /* Allows you to check if a client has too many reliable messages pending. */
#define FTE_MEMALLOC /* Allows dynamically allocating memory. Use pointers to access this memory. Memory will not be saved into saved games. */
#define FTE_MEDIA_AVI /* playfilm command supports avi files. */
#define FTE_MEDIA_CIN /* playfilm command supports q2 cin files. */
#define FTE_MEDIA_ROQ /* playfilm command supports q3 roq files. */
#define FTE_MULTIPROGS /* Multiple progs.dat files can be loaded inside the same qcvm. Insert new ones with addprogs inside the 'init' function, and use externvalue+externset to rewrite globals (and hook functions) to link them together. Note that the result is generally not very clean unless you carefully design for it beforehand. */
#define FTE_MULTITHREADED /* Faux multithreading, allowing multiple contexts to run in sequence. */
#define FTE_MVD_PLAYERSTATS /* In csqc, getplayerstat can be used to query any player's stats when playing back MVDs. isdemo will return 2 in this case. */
#define FTE_QC_NPCCHAT
#define FTE_PART_SCRIPT /* Specifies that the r_particledesc cvar can be used to select a list of particle effects to load from particles/*.cfg, the format of which is documented elsewhere. */
#define FTE_PART_NAMESPACES /* Specifies that the engine can use foo.bar to load effect foo from particle description bar. When used via ssqc, this should cause the client to download whatever effects as needed. */
#define FTE_PART_NAMESPACE_EFFECTINFO /* Specifies that effectinfo.bar can load effects from effectinfo.txt for DP compatibility. */
#define FTE_QC_BASEFRAME /* Specifies that .basebone and .baseframe exist in ssqc. These fields affect all bones in the entity's model with a lower index than the .basebone field, allowing you to give separate control to the legs of a skeletal model, without affecting the torso animations, from ssqc. */
#define FTE_QC_FILE_BINARY /* Extends FRIK_FILE with binary read+write, as well as allowing seeking. Requires pointers. */
#define FTE_QC_CHANGELEVEL_HUB /* Adds an extra argument to changelevel which is carried over to the next map in the 'spawnspot' global. Maps will be saved+reloaded until the extra argument is omitted again, purging all saved maps. Saved games will contain a copy of each preserved map. parm1-parm64 globals can be used, giving more space to transfer more player data. */
#define FTE_QC_CHECKCOMMAND /* Provides a way to test if a console command exists, and whether its a command/alias/cvar. Does not say anything about the expected meanings of any arguments or values. */
#define FTE_QC_CHECKPVS
#define FTE_QC_CROSSPRODUCT
#define FTE_QC_CUSTOMSKINS /* The engine supports the use of q3 skins, as well as the use of such skin 'files' to specify rich top+bottom colours, qw skins, geomsets, or texture composition even on non-players.. */
#define FTE_QC_FS_SEARCH_SIZEMTIME
#define FTE_QC_HARDWARECURSORS /* setcursormode exists in both csqc+menuqc, and accepts additional arguments to specify a cursor image to use when this module has focus. If the image exceeds hardware limits (or hardware cursors are unsupported), it will be emulated using regular draws - this at least still avoids conflicting cursors as only one will ever be used, even if console+menu+csqc are all overlayed. */
#define FTE_QC_HASHTABLES /* Provides efficient string-based lookups. */
#define FTE_QC_INFOKEY /* QuakeWorld's infokey builtin works, and reports at least name+topcolor+bottomcolor+ping(in ms)+ip(unmasked, but not always ipv4)+team(aka bottomcolor in nq). Does not require actual localinfo/serverinfo/userinfo, but they're _highly_ recommended to any engines with csqc */
#define FTE_QC_INTCONV /* Provides string<>int conversions, including hex representations. */
#define FTE_QC_MATCHCLIENTNAME
#define FTE_QC_MULTICAST /* QuakeWorld's multicast builtin works along with MSG_MULTICAST, but also with unicast support. */
#define FTE_QC_PAUSED
#define FTE_QC_PERSISTENTTEMPSTRINGS /* Supersedes DP_QC_MULTIPLETEMPSTRINGS. Temp strings are garbage collected automatically, and do not expire while they're still in use. This makes strzone redundant. */
#define FTE_QC_RAGDOLL_WIP
#define FTE_QC_SENDPACKET /* Allows the use of out-of-band udp packets to/from other hosts. Includes the SV_ParseConnectionlessPacket event. */
#define FTE_QC_STUFFCMDFLAGS /* Variation on regular stuffcmd that gives control over how spectators/mvds should be treated. */
#define FTE_QC_TRACETRIGGER
#define FTE_QUAKE2_CLIENT /* This engine is able to act as a quake2 client */
#define FTE_QUAKE2_SERVER /* This engine is able to act as a quake2 server */
#define FTE_QUAKE3_CLIENT /* This engine is able to act as a quake3 client */
#define FTE_QUAKE3_SERVER /* This engine is able to act as a quake3 server */
#define FTE_SOLID_LADDER /* Allows a simple trigger to remove effects of gravity (solid 20). obsolete. will prolly be removed at some point as it is not networked properly. Use FTE_ENT_SKIN_CONTENTS */
#define FTE_SPLITSCREEN /* Client supports splitscreen, controlled via cl_splitclients. Servers require allow_splitscreen 1 if splitscreen is to be used over the internet. Mods that use csqc will need to be aware for this to work properly. per-client networking may be problematic. */
#define FTE_SQL /* Provides sql* builtins which can be used for sql database access */
#define FTE_SQL_SQLITE /* SQL functionality is able to utilise sqlite databases */
#define FTE_STRINGS /* Extra builtins (and additional behaviour) to make string manipulation easier */
#define FTE_SV_POINTPARTICLES /* Specifies that particleeffectnum, pointparticles, and trailparticles exist in ssqc as well as csqc. particleeffectnum acts as a precache, allowing ssqc values to be networked up with csqc for use. Use in combination with FTE_PART_SCRIPT+FTE_PART_NAMESPACES to use custom effects. This extension is functionally identical to the DP version, but avoids any misplaced assumptions about the format of the client's particle descriptions. */
#define FTE_SV_REENTER
#define FTE_TE_STANDARDEFFECTBUILTINS /* Provides builtins to replace writebytes, with a QW compatible twist. */
#define FTE_TERRAIN_MAP /* This engine supports .hmp files, as well as terrain embedded within bsp files. */
#define FTE_RAW_MAP /* This engine supports directly loading .map files, as well as realtime editing of the various brushes. */
#define KRIMZON_SV_PARSECLIENTCOMMAND /* SSQC's SV_ParseClientCommand function is able to handle client 'cmd' commands. The tokenizing parts also work in csqc. */
#define NEH_CMD_PLAY2
#define NEH_RESTOREGAME
#define QSG_CVARSTRING
#define QW_ENGINE
#define QWE_MVD_RECORD /* You can use the easyrecord command to record MVD demos serverside. */
#define TEI_MD3_MODEL
#define TENEBRAE_GFX_DLIGHTS /* Allows ssqc to attach rtlights to entities with various special properties. */
#define ZQ_MOVETYPE_FLY /* MOVETYPE_FLY works on players. */
#define ZQ_MOVETYPE_NOCLIP /* MOVETYPE_NOCLIP works on players. */
#define ZQ_MOVETYPE_NONE /* MOVETYPE_NONE works on players. */
#define ZQ_VWEP
#define ZQ_QC_STRINGS /* The strings-only subset of FRIK_FILE is supported. */

#ifdef _ACCESSORS
accessor strbuf : float;
accessor searchhandle : float;
accessor hashtable : float;
accessor infostring : string;
accessor filestream : float;
accessor filestream : float;
#else
#define strbuf float
#define searchhandle float
#define hashtable float
#define infostring string
#define filestream float
#endif

entity self;	/* The magic me */
entity other;	/* Valid in touch functions, this is the entity that we touched. */
entity world;	/* The null entity. Hurrah. Readonly after map spawn time. */
float time;	/* The current game time. Stops when paused. */
float cltime;	/* A local timer that ticks relative to local time regardless of latency, packetloss, or pause. */
float frametime;	/* The time since the last physics/render/input frame. */
float player_localentnum;	/* This is entity number the player is seeing from/spectating, or the player themself, can change mid-map. */
float player_localnum;	/* The 0-based player index, valid for getplayerkeyvalue calls. */
float maxclients;	/* Maximum number of player slots on the server. */
float clientcommandframe;	/* This is the input-frame sequence. frames < clientcommandframe have been sent to the server. frame==clientcommandframe is still being generated and can still change. */
float servercommandframe;	/* This is the input-frame that was last acknowledged by the server. Input frames greater than this should be applied to the player's entity. */
string mapname;	/* The short name of the map. */
float intermission;
vector v_forward, v_up, v_right;
vector view_angles;	/* +x=DOWN */
float trace_allsolid, trace_startsolid, trace_fraction;
vector trace_endpos, trace_plane_normal;
float trace_plane_dist;
entity trace_ent;
float trace_inopen;
float trace_inwater;
float input_timelength;
vector input_angles;	/* +x=DOWN */
vector input_movevalues;
float input_buttons;
float input_impulse;
void end_sys_globals;
.float modelindex;	/* This is the model precache index for the model that was set on the entity, instead of having to look up the model according to the .model field. Use setmodel to change it. */
.vector absmin;	/* Set by the engine when the entity is relinked (by setorigin, setsize, or setmodel). This is in world coordinates. */
.vector absmax;	/* Set by the engine when the entity is relinked (by setorigin, setsize, or setmodel). This is in world coordinates. */
.float entnum;	/* The entity number as its known on the server. */
.float drawmask;	/* Acts as a filter in the addentities call. */
.float() predraw;	/* Called by addentities after the filter and before the entity is actually drawn. Do your interpolation and animation in here. Should return one of the PREDRAW_* constants. */
.float movetype;	/* Describes how the entity moves. One of the MOVETYPE_ constants. */
.float solid;	/* Describes whether the entity is solid or not, and any special properties infered by that. Must be one of the SOLID_ constants */
.vector origin;	/* The current location of the entity in world space. Inline bsp entities (ie: ones placed by a mapper) will typically have a value of '0 0 0' in their neutral pose, as the geometry is offset from that. It is the reference point of the entity rather than the center of its geometry, for non-bsp models, this is often not a significant distinction. */
.vector oldorigin;	/* This is often used on players to reset the player back to where they were last frame if they somehow got stuck inside something due to fpu precision. Never change a player's oldorigin field to inside a solid, because that might cause them to become pemanently stuck. */
.vector velocity;	/* The direction and speed that the entity is moving in world space. */
.vector angles;	/* The eular angles the entity is facing in, in pitch, yaw, roll order. Due to a legacy bug, mdl/iqm/etc formats use +x=UP, bsp/spr/etc formats use +x=DOWN. */
.vector avelocity;	/* The amount the entity's angles change by per second. Note that this is direct eular angles, and thus the angular change is non-linear and often just looks buggy if you're changing more than one angle at a time. */
.float pmove_flags;
.string classname;	/* Identifies the class/type of the entity. Useful for debugging, also used for loading, but its value is not otherwise significant to the engine, this leaves the mod free to set it to whatever it wants and randomly test strings for values in whatever inefficient way it chooses fit. */
.float renderflags;
.string model;	/* The model name that was set via setmodel, in theory. Often, this is cleared to null to prevent the engine from being seen by clients while not changing modelindex. This behaviour allows inline models to remain solid yet be invisible. */
.float frame;	/* The current frame the entity is meant to be displayed in. In CSQC, note the lerpfrac and frame2 fields as well. if it specifies a framegroup, the framegroup will autoanimate in ssqc, but not in csqc. */
.float frame1time;	/* The absolute time into the animation/framegroup specified by .frame. */
.float frame2;	/* The alternative frame. Visible only when lerpfrac is set to 1. */
.float frame2time;	/* The absolute time into the animation/framegroup specified by .frame2. */
.float lerpfrac;	/* If 0, use frame1 only. If 1, use frame2 only. Mix them together for values between. */
.float skin;	/* The skin index to use. on a bsp entity, setting this to 1 will switch to the 'activated' texture instead. A negative value will be understood as a replacement contents value, so setting it to CONTENTS_WATER will make a movable pool of water. */
.float effects;	/* Lots of random flags that change random effects. See EF_* constants. */
.vector mins;	/* The minimum extent of the model (ie: the bottom-left coordinate relative to the entity's origin). Change via setsize. May also be changed by setmodel. */
.vector maxs;	/* like mins, but in the other direction. */
.vector size;	/* maxs-mins. Updated when the entity is relinked (by setorigin, setsize, setmodel) */
.void() touch;
.void() think;
.void() blocked;
.float nextthink;	/* The time at which the entity is next scheduled to fire its think event. For MOVETYPE_PUSH entities, this is relative to that entity's ltime field, for all other entities it is relative to the time gloal. */
.entity chain;
.entity enemy;
.float flags;
.float colormap;
.entity owner;
void end_sys_fields;
vector input_cursor_screen;
vector input_cursor_trace_start;
vector input_cursor_trace_endpos;
float input_cursor_trace_entnum;
int trace_endcontents;
int trace_surfaceflags;
int trace_brush_id;
int trace_brush_faceid;
int trace_surface_id;	/* 1-based. 0 if not known. */
int trace_bone_id;	/* 1-based. 0 if not known. typically needs MOVE_HITMODEL. */
int trace_triangle_id;	/* 1-based. 0 if not known. */
vector global_gravitydir = '0 0 -1';	/* The direction gravity should act in if not otherwise specified per entity. */
int serverid;	/* The unique id of this server within the server cluster. */
.vector punchangle;
.float gravity;
.float hull;	/* Overrides the hull used by the entity for walkmove/movetogoal and not traceline/tracebox. */
.entity movechain;	/* This is a linked list of entities which will be moved whenever this entity moves, logically they are attached to this entity. */
.void() chainmoved;	/* Called when the entity is moved as a result of being part of another entity's .movechain */
.void(float old, float new) contentstransition;	/* This function is called when the entity moves between water and air. If specified, default splash sounds will be disabled allowing you to provide your own. */
.float dimension_solid;	/* This is the bitmask of dimensions which the entity is solid within. */
.float dimension_hit;	/* This is the bitmask of dimensions which the entity will be blocked by. If other.dimension_solid & self.dimension_hit, our traces will impact and not proceed. If its false, the traces will NOT impact, allowing self to pass straight through. */
.int hitcontentsmaski;	/* Traces performed for this entity will impact against surfaces that match this contents mask. */
.float dphitcontentsmask;	/* Some crappy field that inefficiently requires translating to the native contents flags. Ditch the 'dp', do it properly. */
.float scale;	/* Multiplier that resizes the entity. 1 is normal sized, 2 is double sized. scale 0 is remapped to 1. In SSQC, this is limited to 1/16th precision, with a maximum just shy of 16. */
.float fatness;	/* How many QuakeUnits to push the entity's verticies along their normals by. */
.float alpha;	/* The transparency of the entity. 1 means opaque, 0.0001 means virtually invisible. 0 is remapped to 1, for compatibility. */
.float modelflags;	/* Used to override the flags set in the entity's model. Should be set according to the MF_ constants. Use effects|=EF_NOMODELFLAGS to ignore the model's flags completely. The traileffectnum field is more versatile. */
.float basebone;	/* The base* frame animations are equivelent to their non-base versions, except that they only affect bone numbers below the 'basebone' value. This means that the base* animation can affect the legs of a skeletal model independantly of the normal animation fields affecting the torso area. For more complex animation than this, use skeletal objects. */
.float baseframe;	/* See basebone */
.void() customphysics;	/* Called once each physics frame, overriding the entity's .movetype field and associated logic. You'll probably want to use tracebox to move it through the world. Be sure to call .think as appropriate. */
.entity tag_entity;
.float tag_index;
.float skeletonindex;	/* This object serves as a container for the skeletal bone states used to override the animation data. */
.vector colormod;	/* Provides a colour tint for the entity. */
.vector glowmod;
.vector gravitydir;	/* Specifies the direction in which gravity acts. Must be normalised. '0 0 0' also means down. Use '0 0 1' if you want the player to be able to run on ceilings. */
.vector(vector org, vector ang) camera_transform;	/* Provides portal transform information for portal surfaces attached to this entity. Also used to open up pvs in ssqc. */
.float geomtype;
.float friction;
.float erp;
.float jointtype;
.float mass;
.float bouncefactor;
.float bouncestop;
.float idealpitch;
.float pitch_speed;
.float drawflags;	/* Various flags that affect lighting values and scaling. Typically set to 96 in quake for proper compatibility with DP_QC_SCALE. */
.float abslight;	/* Allows overriding light levels. Use drawflags to state that this field should actually be used. */
.vector color;	/* This affects the colour of realtime lights that were enabled via the pflags field. */
.float light_lev;	/* This is the radius of an entity's light. This is not normally used by the engine, but is used for realtime lights (ones that are enabled with the pflags field). */
.float style;	/* Used by the light util to decide how an entity's light should animate. On an entity with pflags set, this also affects realtime lights. */
.float pflags;	/* Realtime lighting flags */
.float frame3;	/* Some people just don't understand how to use framegroups... */
.float frame4;
.float lerpfrac3;
.float lerpfrac4;
.float forceshader;	/* Contains a shader handle used to replace all surfaces upon the entity. */
.float baseframe2;	/* See basebone */
.float baseframe1time;	/* See basebone */
.float baseframe2time;	/* See basebone */
.float baselerpfrac;	/* See basebone */
.float bonecontrol1;	/* Halflife model format bone controller. On player models, this typically affects the spine's yaw. */
.float bonecontrol2;	/* Halflife model format bone controller. On player models, this typically affects the spine's yaw. */
.float bonecontrol3;	/* Halflife model format bone controller. On player models, this typically affects the spine's yaw. */
.float bonecontrol4;	/* Halflife model format bone controller. On player models, this typically affects the spine's yaw. */
.float bonecontrol5;	/* Halflife model format bone controller. This typically affects the mouth. */
.float subblendfrac;	/* Weird animation value specific to halflife models. On player models, this typically affects the spine's pitch, or yaw, or... */
.float subblend2frac;	/* Weird animation value specific to halflife models. I've no idea what this does, probably nothing for most models. */
.float basesubblendfrac;	/* See basebone */
.float basesubblend2frac;	/* See basebone */
void(float reqid, float responsecode, string resourcebody) URI_Get_Callback;	/* Called as an eventual result of the uri_get builtin. */
void(float apilevel, string enginename, float engineversion) CSQC_Init;	/* Called at startup. enginename and engineversion are arbitary hints and can take any form. enginename should be consistant between revisions, but this cannot truely be relied upon. */
void() CSQC_WorldLoaded;	/* Called after model+sound precaches have been executed. Gives a chance for the qc to read the entity lump from the bsp. */
void() CSQC_Shutdown;	/* Specifies that the csqc is going down. Save your persistant settings here. */
void(float vwidth, float vheight, float notmenu) CSQC_UpdateView;	/* Called every single video frame. The CSQC is responsible for rendering the entire screen. */
void(float vwidth, float vheight, float notmenu) CSQC_UpdateViewLoading;	/* Alternative to CSQC_UpdateView, called when the engine thinks there should be a loading screen. If present, will inhibit the engine's normal loading screen, deferring to qc to draw it. */
void(string msg) CSQC_Parse_StuffCmd;	/* Gives the CSQC a chance to intercept stuffcmds. Use the tokenize builtin to parse the message. Unrecognised commands would normally be localcmded, but its probably better to drop unrecognised stuffcmds completely. */
float(string msg) CSQC_Parse_CenterPrint;	/* Gives the CSQC a chance to intercept centerprints. Return true if you wish the engine to otherwise ignore the centerprint. */
float(float save, float take, vector inflictororg) CSQC_Parse_Damage;	/* Called as a result of player.dmg_save or player.dmg_take being set on the server.
Return true to completely inhibit the engine's colour shift and damage rolls, allowing you to do your own thing.
You can use punch_roll += (normalize(inflictororg-player.origin)*v_right)*(take+save)*autocvar_v_kickroll; as a modifier for the roll angle should the player be hit from the side, and slowly fade it away over time. */
void(string printmsg, float printlvl) CSQC_Parse_Print;	/* Gives the CSQC a chance to intercept sprint/bprint builtin calls. CSQC should filter by the client's current msg setting and then pass the message on to the print command, or handle them itself. */
void() CSQC_Parse_Event;	/* Called when the client receives an SVC_CGAMEPACKET. The csqc should read the data or call the error builtin if it does not recognise the message. */
float(float evtype, float scanx, float chary, float devid) CSQC_InputEvent;	/* Called whenever a key is pressed, the mouse is moved, etc. evtype will be one of the IE_* constants. The other arguments vary depending on the evtype. Key presses are not guarenteed to have both scan and unichar values set at the same time. */
__used void() CSQC_Input_Frame;	/* Called just before each time clientcommandframe is updated. You can edit the input_* globals in order to apply your own player inputs within csqc, which may allow you a convienient way to pass certain info to ssqc. */
void(string rendererdescription) CSQC_RendererRestarted;	/* Called by the engine after the video was restarted. This serves to notify the CSQC that any render targets that it may have cached were purged, and will need to be regenerated. */
float(string cmd) CSQC_ConsoleCommand;	/* Called if the user uses any console command registed via registercommand. */
float(string text, string info) CSQC_ConsoleLink;	/* Called if the user clicks a ^[text\infokey\infovalue^] link. Use infoget to read/check each supported key. Return true if you wish the engine to not attempt to handle the link itself.
WARNING: link text can potentially come from other players, so be careful about what you allow to be changed. */
void(float entnum) CSQC_Ent_Spawn;	/* Clumsily defined function for compat with DP. Should call spawn, set that ent's entnum field, and return the entity inside the 'self' global which will then be used for fllowing Ent_Updates. MUST NOT PARSE ANY NETWORK DATA (which makes it kinda useless). */
void(float isnew) CSQC_Ent_Update;	/* Parses the data sent by ssqc's various SendEntity functions (must use the exact same reads as the ssqc used writes - to debug this rule more easily, you may wish to use sv_csqcdebug). 'self' provides context between frames, and self.entnum should normally report which ssqc entity . Be aware that interpolation will need to happen separately. */
void() CSQC_Ent_Remove;
float(float entnum, float channel, string soundname, float vol, float attenuation, vector pos, float pitchmod, float flags) CSQC_Event_Sound;
float() CSQC_Parse_TempEntity;	/* Please don't use this. Use CSQC_Parse_Event and multicasts instead.
The use of serverside protocol translation to handle QW vs NQ protocols mean that you're likely to end up reading slightly different data. Which is bad.
Return true to say that you fully handled the tempentity. Return false to have the client attempt to rewind the network stream and parse the message itself. */
void(string cmdtext) GameCommand;
string(string uri, string method, string postdata, __in string requestheaders, __inout string responseheaders) Cef_GeneratePage;	/* Provides an entrypoint to generate pages for the CEF plugin from within QC. Headers are 
-separated key/value pairs (use tokenizebyseparator). */
void(float prevprogs) init;	/* Part of FTE_MULTIPROGS. Called as soon as a progs is loaded, called at a time when entities are not valid. This is the only time when it is safe to call addprogs without field assignment. As it is also called as part of addprogs, this also gives you a chance to hook functions in modules that are already loaded (via externget+externget). */
void() initents;	/* Part of FTE_MULTIPROGS. Called after fields have been finalized. This is the first point at which it is safe to call spawn(), and is called before any entity fields have been parsed. You can use this entrypoint to send notifications to other modules. */
__used var float physics_mode = 2;	/* 0: original csqc - physics are not run
1: DP-compat. Thinks occur, but not true movetypes.
2: movetypes occur just as they do in ssqc. */
float gamespeed;	/* Set by the engine, this is the value of the sv_gamespeed cvar */
float numclientseats;	/* This is the number of splitscreen clients currently running on this client. */
var vector drawfontscale = '1 1 0';	/* Specifies a scaler for all text rendering. There are other ways to implement this. */
float drawfont;	/* Allows you to choose exactly which font is to be used to draw text. Fonts can be registered/allocated with the loadfont builtin. */
const float FONT_DEFAULT = 0;
const float TRUE = 1;
const float FALSE = 0;	/* File not found... */
const float M_PI = 3.14159;
const float MOVETYPE_NONE = 0;
const float MOVETYPE_WALK = 3;
const float MOVETYPE_STEP = 4;
const float MOVETYPE_FLY = 5;
const float MOVETYPE_TOSS = 6;
const float MOVETYPE_PUSH = 7;
const float MOVETYPE_NOCLIP = 8;
const float MOVETYPE_FLYMISSILE = 9;
const float MOVETYPE_BOUNCE = 10;
const float MOVETYPE_BOUNCEMISSILE = 11;
const float MOVETYPE_FOLLOW = 12;
const float MOVETYPE_6DOF = 30;	/* A glorified MOVETYPE_FLY. Players using this movetype will get some flightsim-like physics, with fully independant rotations (order-dependant transforms). */
const float MOVETYPE_WALLWALK = 31;	/* Players using this movetype will be able to orient themselves to walls, and then run up them. */
const float MOVETYPE_PHYSICS = 32;	/* Enable the use of ODE physics upon this entity. */
const float SOLID_NOT = 0;
const float SOLID_TRIGGER = 1;
const float SOLID_BBOX = 2;
const float SOLID_SLIDEBOX = 3;
const float SOLID_BSP = 4;	/* Does not collide against other SOLID_BSP entities. Normally paired with MOVETYPE_PUSH. */
const float SOLID_CORPSE = 5;	/* Non-solid to SOLID_SLIDEBOX or other SOLID_CORPSE entities. For hitscan weapons to hit corpses, change the player's .solid value to SOLID_BBOX or so, perform the traceline, then revert the player's .solid value. */
const float SOLID_LADDER = 20;	/* Obsolete and may be removed at some point. Use skin=CONTENT_LADDER and solid_bsp or solid_trigger instead. */
const float SOLID_PORTAL = 21;	/* CSG subtraction volume combined with entity transformations on impact. */
const float SOLID_PHYSICS_BOX = 32;
const float SOLID_PHYSICS_SPHERE = 33;
const float SOLID_PHYSICS_CAPSULE = 34;
const float SOLID_PHYSICS_TRIMESH = 35;
const float SOLID_PHYSICS_CYLINDER = 36;
const float GEOMTYPE_NONE = -1;
const float GEOMTYPE_SOLID = 0;
const float GEOMTYPE_BOX = 1;
const float GEOMTYPE_SPHERE = 2;
const float GEOMTYPE_CAPSULE = 3;
const float GEOMTYPE_TRIMESH = 4;
const float GEOMTYPE_CYLINDER = 5;
const float GEOMTYPE_CAPSULE_X = 6;
const float GEOMTYPE_CAPSULE_Y = 7;
const float GEOMTYPE_CAPSULE_Z = 8;
const float GEOMTYPE_CYLINDER_X = 9;
const float GEOMTYPE_CYLINDER_Y = 10;
const float GEOMTYPE_CYLINDER_Z = 11;
const float JOINTTYPE_FIXED = -1;
const float JOINTTYPE_POINT = 1;
const float JOINTTYPE_HINGE = 2;
const float JOINTTYPE_SLIDER = 3;
const float JOINTTYPE_UNIVERSAL = 4;
const float JOINTTYPE_HINGE2 = 5;
const float GE_MAXENTS = -1;	/* Valid for getentity, ignores the entity argument. Returns the maximum number of entities which may be valid, to avoid having to poll 65k when only 100 are used. */
const float GE_ACTIVE = 0;	/* Valid for getentity. Returns whether this entity is known to the client or not. */
const float GE_ORIGIN = 1;	/* Valid for getentity. Returns the interpolated .origin. */
const float GE_FORWARD = 2;	/* Valid for getentity. Returns the interpolated forward vector. */
const float GE_RIGHT = 3;	/* Valid for getentity. Returns the entity's right vector. */
const float GE_UP = 4;	/* Valid for getentity. Returns the entity's up vector. */
const float GE_SCALE = 5;	/* Valid for getentity. Returns the entity .scale. */
const float GE_ORIGINANDVECTORS = 6;	/* Valid for getentity. Returns interpolated .origin, but also sets v_forward, v_right, and v_up accordingly. Use vectoangles(v_forward,v_up) to determine the angles. */
const float GE_ALPHA = 7;	/* Valid for getentity. Returns the entity alpha. */
const float GE_COLORMOD = 8;	/* Valid for getentity. Returns the colormod vector. */
const float GE_PANTSCOLOR = 9;	/* Valid for getentity. Returns the entity's lower color (from .colormap), as a palette range value. */
const float GE_SHIRTCOLOR = 10;	/* Valid for getentity. Returns the entity's lower color (from .colormap), as a palette range value. */
const float GE_SKIN = 11;	/* Valid for getentity. Returns the entity's .skin index. */
const float GE_MINS = 12;	/* Valid for getentity. Guesses the entity's .min vector. */
const float GE_MAXS = 13;	/* Valid for getentity. Guesses the entity's .max vector. */
const float GE_ABSMIN = 14;	/* Valid for getentity. Guesses the entity's .absmin vector. */
const float GE_ABSMAX = 15;	/* Valid for getentity. Guesses the entity's .absmax vector. */
const float GE_MODELINDEX = 200;	/* Valid for getentity. Guesses the entity's .modelindex float. */
const float GE_MODELINDEX2 = 201;	/* Valid for getentity. Guesses the entity's .vw_index float. */
const float GE_EFFECTS = 202;	/* Valid for getentity. Guesses the entity's .effects float. */
const float GE_FRAME = 203;	/* Valid for getentity. Guesses the entity's .frame float. */
const float GE_ANGLES = 204;	/* Valid for getentity. Guesses the entity's .angles vector. */
const float GE_FATNESS = 205;	/* Valid for getentity. Guesses the entity's .fatness float. */
const float GE_DRAWFLAGS = 206;	/* Valid for getentity. Guesses the entity's .drawflags float. */
const float GE_ABSLIGHT = 207;	/* Valid for getentity. Guesses the entity's .abslight float. */
const float GE_GLOWMOD = 208;	/* Valid for getentity. Guesses the entity's .glowmod vector. */
const float GE_GLOWSIZE = 209;	/* Valid for getentity. Guesses the entity's .glowsize float. */
const float GE_GLOWCOLOUR = 210;	/* Valid for getentity. Guesses the entity's .glowcolor float. */
const float GE_RTSTYLE = 211;	/* Valid for getentity. Guesses the entity's .style float. */
const float GE_RTPFLAGS = 212;	/* Valid for getentity. Guesses the entity's .pflags float. */
const float GE_RTCOLOUR = 213;	/* Valid for getentity. Guesses the entity's .color vector. */
const float GE_RTRADIUS = 214;	/* Valid for getentity. Guesses the entity's .light_lev float. */
const float GE_TAGENTITY = 215;	/* Valid for getentity. Guesses the entity's .tag_entity float. */
const float GE_TAGINDEX = 216;	/* Valid for getentity. Guesses the entity's .tag_index float. */
const float GE_GRAVITYDIR = 217;	/* Valid for getentity. Guesses the entity's .gravitydir vector. */
const float GE_TRAILEFFECTNUM = 218;	/* Valid for getentity. Guesses the entity's .traileffectnum float. */
const float CONTENT_EMPTY = -1;
const float CONTENT_SOLID = -2;
const float CONTENT_WATER = -3;
const float CONTENT_SLIME = -4;
const float CONTENT_LAVA = -5;
const float CONTENT_SKY = -6;
const float CONTENT_LADDER = -16;	/* If this value is assigned to a solid_bsp's .skin field, the entity will become a ladder volume. */
const int CONTENTBIT_NONE = 0x00000000i;
const int CONTENTBIT_SOLID = 0x00000001i;
const int CONTENTBIT_LAVA = 0x00000008i;
const int CONTENTBIT_SLIME = 0x00000010i;
const int CONTENTBIT_WATER = 0x00000020i;
const int CONTENTBIT_FTELADDER = 0x00004000i;
const int CONTENTBIT_PLAYERCLIP = 0x00010000i;
const int CONTENTBIT_MONSTERCLIP = 0x00020000i;
const int CONTENTBIT_BODY = 0x02000000i;
const int CONTENTBIT_CORPSE = 0x04000000i;
const int CONTENTBIT_Q2LADDER = 0x20000000i;	/* Content bit specific to q2bsp */
const int CONTENTBIT_SKY = 0x80000000i;
const int CONTENTBITS_POINTSOLID = CONTENTBIT_SOLID|0x00000002i|CONTENTBIT_BODY;	/* Bits that traceline would normally consider solid */
const int CONTENTBITS_BOXSOLID = CONTENTBIT_SOLID|0x00000002i|CONTENTBIT_BODY|CONTENTBIT_PLAYERCLIP;	/* Bits that tracebox would normally consider solid */
const int CONTENTBITS_FLUID = CONTENTBIT_WATER|CONTENTBIT_SLIME|CONTENTBIT_LAVA|CONTENTBIT_SKY;
const int SPA_POSITION;	/* These SPA_* constants are to specify which attribute is returned by the getsurfacepointattribute builtin */
const int SPA_S_AXIS = 1;
const int SPA_T_AXIS = 2;
const int SPA_R_AXIS = 3;	/* aka: SPA_NORMAL */
const int SPA_TEXCOORDS0 = 4;
const int SPA_LIGHTMAP0_TEXCOORDS = 5;
const int SPA_LIGHTMAP0_COLOR = 6;
const float CHAN_AUTO = 0;	/* The automatic channel, play as many sounds on this channel as you want, and they'll all play, however the other channels will replace each other. */
const float CHAN_WEAPON = 1;
const float CHAN_VOICE = 2;
const float CHAN_ITEM = 3;
const float CHAN_BODY = 4;
const float SOUNDFLAG_ABSVOLUME = 16;	/* The sample's volume is not scaled by the volume cvar. Use with caution */
const float SOUNDFLAG_FORCELOOP = 2;	/* The sound will restart once it reaches the end of the sample. */
const float SOUNDFLAG_NOSPACIALISE = 4;	/* The different audio channels are played at the same volume regardless of which way the player is facing, without needing to use 0 attenuation. */
const float SOUNDFLAG_NOREVERB = 32;	/* Disables the use of underwater/reverb effects on this sound effect. */
const float SOUNDFLAG_FOLLOW = 64;	/* The sound's origin will updated to follow the emitting entity. */
const float ATTN_NONE = 0;	/* Sounds with this attenuation can be heard throughout the map */
const float ATTN_NORM = 1;	/* Standard attenuation */
const float ATTN_IDLE = 2;	/* Extra attenuation so that sounds don't travel too far. */
const float ATTN_STATIC = 3;	/* Even more attenuation to avoid torches drowing out everything else throughout the map. */
const string INFOKEY_P_PING = "ping";	/* The player's ping time, in milliseconds. */
const string INFOKEY_P_NAME = "name";	/* The player's name. */
const string INFOKEY_P_SPECTATOR = "*spectator";	/* Whether the player is a spectator or not. */
const string INFOKEY_P_TOPCOLOR = "topcolor";	/* The player's upper/shirt colour (palette index). */
const string INFOKEY_P_BOTTOMCOLOR = "bottomcolor";	/* The player's lower/pants/trouser colour (palette index). */
const string INFOKEY_P_TOPCOLOR_RGB = "topcolor_rgb";	/* The player's upper/shirt colour as an rgb value in a format usable with stov. */
const string INFOKEY_P_BOTTOMCOLOR_RGB = "bottomcolor_rgb";	/* The player's lower/pants/trouser colour as an rgb value in a format usable with stov. */
const string INFOKEY_P_MUTED = "ignored";	/* 0: we can see the result of the player's say/say_team commands.   1: we see no say/say_team messages from this player. Use the ignore command to toggle this value. */
const string INFOKEY_P_VOIP_MUTED = "vignored";	/* 0: we can hear this player when they speak (assuming voip is generally enabled). 1: we ignore everything this player says. Use cl_voip_mute to change the values. */
const string INFOKEY_P_ENTERTIME = "entertime";	/* Reads the timestamp at which the player entered the game, in terms of csqc's time global. */
const string INFOKEY_P_FRAGS = "frags";	/* Reads a player's frag count. */
const string INFOKEY_P_PACKETLOSS = "pl";	/* Reads a player's packetloss, as a percentage. */
const string INFOKEY_P_VOIPSPEAKING = "voipspeaking";	/* Boolean value that says whether the given player is currently sending voice information. */
const string INFOKEY_P_VOIPLOUDNESS = "voiploudness";	/* Only valid for the local player. Gives a value between 0 and 1 to indicate to the user how loud their mic is. */
const string SERVERKEY_IP = "ip";	/* The address of the server we connected to. */
const string SERVERKEY_SERVERNAME = "servername";	/* The hostname that was last passed to the connect command. */
const string SERVERKEY_CONSTATE = "constate";	/* The current connection state. Will be set to one of: disconnected (menu-only mode), active (gamestate received and loaded), connecting(connecting, downloading, or precaching content, aka: loading screen). */
const string SERVERKEY_TRANSFERRING = "transferring";	/* Set to the hostname of the server that we are attempting to connect or transfer to. */
const string SERVERKEY_LOADSTATE = "loadstate";	/* loadstage, loading image name, current step, max steps
Stages are: 1=connecting, 2=serverside, 3=clientside
Key will be empty if we are not loading. */
const string SERVERKEY_PAUSESTATE = "pausestate";	/* 1 if the server claimed to be paused. 0 otherwise */
const string SERVERKEY_DLSTATE = "dlstate";	/* The progress of any current downloads. Empty string if no download is active, otherwise a tokenizable string containing this info:
files-remaining, total-size, unknown-sizes-flag, file-localname, file-remotename, file-percent, file-rate, file-received-bytes, file-total-bytes
If the current file info is omitted, then we are waiting for a download to start. */
const string SERVERKEY_PROTOCOL = "protocol";	/* The protocol we are connected to the server with. */
const string SERVERKEY_MAXPLAYERS = "maxplayers";	/* The number of player/spectator slots allocated on the server. */
const float FL_FLY = 1;
const float FL_SWIM = 2;
const float FL_CLIENT = 8;
const float FL_INWATER = 16;
const float FL_MONSTER = 32;
const float FL_ITEM = 256;
const float FL_ONGROUND = 512;
const float FL_PARTIALGROUND = 1024;
const float FL_WATERJUMP = 2048;
const float FL_JUMPRELEASED = 4096;
const float FL_FINDABLE_NONSOLID = 16384;	/* Allows this entity to be found with findradius */
const float MOVE_NORMAL = 0;
const float MOVE_NOMONSTERS = 1;	/* The trace will ignore all non-solid_bsp entities. */
const float MOVE_MISSILE = 2;	/* The trace will use a bbox size of +/- 15 against entities with FL_MONSTER set. */
const float MOVE_HITMODEL = 4;	/* Traces will impact the actual mesh of the model instead of merely their bounding box. Should generally only be used for tracelines. Note that this flag is unreliable as an object can animate through projectiles. The bounding box MUST be set to completely encompass the entity or those extra areas will be non-solid (leaving a hole for things to go through). */
const float MOVE_TRIGGERS = 16;	/* This trace type will impact only triggers. It will ignore non-solid entities. */
const float MOVE_EVERYTHING = 32;	/* This type of trace will hit solids and triggers alike. Even non-solid entities. */
const float MOVE_ENTCHAIN = 128;	/* Returns a list of entities impacted via the trace_ent.chain field */
const float MOVE_OTHERONLY = 256;	/* Traces that use this trace type will collide against *only* the entity specified via the 'other' global, and will ignore all owner/solid_not/dimension etc rules, they will still adhere to contents and bsp/bbox rules though. */
const float RESTYPE_MODEL = 0;	/* RESTYPE_* constants are used as arguments with the resourcestatus builtin. */
const float RESTYPE_SOUND = 1;	/* precache_sound */
const float RESTYPE_PARTICLE = 2;	/* particleeffectnum */
const float RESTYPE_PIC = 3;	/* precache_pic. Status results are an amalgomation of the textures used by the named shader. */
const float RESTYPE_SKIN = 4;	/* setcustomskin */
const float RESTYPE_TEXTURE = 5;	/* Individual textures within shaders. These are not directly usable, but may be named as part of a skin file, or a shader. */
const float RESSTATE_NOTKNOWN = 0;	/* RESSTATE_* constants are return values from the resourcestatus builtin. The engine doesn't know about the resource if it is in this state. This means you will need to precache it. Attempting to use it anyway may result in warnings, errors, or silently succeed, depending on engine version and resource type. */
const float RESSTATE_NOTLOADED = 1;	/* The resource was precached, but has been flushed and there has not been an attempt to reload it. If you use the resource normally, chances are it'll be loaded but at the cost of a stall. */
const float RESSTATE_LOADING = 2;	/* Resources in this this state are queued for loading, and will be loaded at the engine's convienience. If you attempt to query the resource now, the engine will stall until the result is available. sounds in this state may be delayed, while models/pics/shaders may be invisible. */
const float RESSTATE_FAILED = 3;	/* Resources in this state are unusable/could not be loaded. You will get placeholders or dummy results. Queries will not stall the engine. The engine may display placeholder content. */
const float RESSTATE_LOADED = 4;	/* Resources in this state are finally usable, everything will work okay. Hurrah. Queries will not stall the engine. */
const float EF_BRIGHTFIELD = 1;
const float EF_MUZZLEFLASH = 2;
const float EF_BRIGHTLIGHT = 4;
const float EF_DIMLIGHT = 8;
const float EF_NODRAW = 16;
const float EF_ADDITIVE = 32;	/* The entity will be drawn with an additive blend. */
const float EF_BLUE = 64;	/* A blue glow */
const float EF_RED = 128;	/* A red glow */
const float EF_GREEN = 262144;	/* A green glow */
const float EF_FULLBRIGHT = 512;	/* This entity will ignore lighting */
const float EF_NOSHADOW = 4096;	/* This entity will not cast shadows */
const float EF_NODEPTHTEST = 8192;	/* This entity will be drawn over the top of other things that are closer. */
const float MF_ROCKET = 1;
const float MF_GRENADE = 2;
const float MF_GIB = 4;	/* Regular blood trail */
const float MF_ROTATE = 8;
const float MF_TRACER = 16;	/* AKA: green scrag trail */
const float MF_ZOMGIB = 32;	/* Dark blood trail */
const float MF_TRACER2 = 64;	/* AKA: hellknight projectile trail */
const float MF_TRACER3 = 128;	/* AKA: purple vore trail */
const float PFLAGS_NOSHADOW = 1;	/* Associated RT lights attached will not cast shadows, making them significantly faster to draw. */
const float PFLAGS_CORONA = 2;	/* Enables support of coronas on the associated rtlights. */
const float EV_STRING = 1;
const float EV_FLOAT = 2;
const float EV_VECTOR = 3;
const float EV_ENTITY = 4;
const float EV_FIELD = 5;
const float EV_FUNCTION = 6;
const float EV_POINTER = 7;
const float EV_INTEGER = 8;
const float EV_VARIANT = 9;
hashtable gamestate;	/* Special hash table index for hash_add and hash_get. Entries in this table will persist over map changes (and doesn't need to be created/deleted). */
const float HASH_REPLACE = 256;	/* Used with hash_add. Attempts to remove the old value instead of adding two values for a single key. */
const float HASH_ADD = 512;	/* Used with hash_add. The new entry will be inserted in addition to the existing entry. */
const float STAT_HEALTH = 0;	/* Player's health. */
const float STAT_WEAPONMODELI = 2;	/* This is the modelindex of the current viewmodel (renamed from the original name 'STAT_WEAPON' due to confusions). */
const float STAT_AMMO = 3;	/* player.currentammo */
const float STAT_ARMOR = 4;
const float STAT_WEAPONFRAME = 5;
const float STAT_SHELLS = 6;
const float STAT_NAILS = 7;
const float STAT_ROCKETS = 8;
const float STAT_CELLS = 9;
const float STAT_ACTIVEWEAPON = 10;	/* player.weapon */
const float STAT_TOTALSECRETS = 11;
const float STAT_TOTALMONSTERS = 12;
const float STAT_FOUNDSECRETS = 13;
const float STAT_KILLEDMONSTERS = 14;
const float STAT_ITEMS = 15;	/* self.items | (self.items2<<23). In order to decode this stat properly, you need to use getstatbits(STAT_ITEMS,0,23) to read self.items, and getstatbits(STAT_ITEMS,23,11) to read self.items2 or getstatbits(STAT_ITEMS,28,4) to read the visible part of serverflags, whichever is applicable. */
const float STAT_VIEWHEIGHT = 16;	/* player.view_ofs_z */
const float STAT_VIEW2 = 20;	/* This stat contains the number of the entity in the server's .view2 field. */
const float STAT_VIEWZOOM = 21;	/* Scales fov and sensitiity. Part of DP_VIEWZOOM. */
const float STAT_USER = 32;	/* Custom user stats start here (lower values are reserved for engine use). */
const float VF_MIN = 1;	/* The top-left of the 3d viewport in screenspace. The VF_ values are used via the setviewprop/getviewprop builtins. */
const float VF_MIN_X = 2;
const float VF_MIN_Y = 3;
const float VF_SIZE = 4;	/* The width+height of the 3d viewport in screenspace. */
const float VF_SIZE_X = 5;
const float VF_SIZE_Y = 6;
const float VF_VIEWPORT = 7;	/* vector+vector. Two argument shortcut for VF_MIN and VF_SIZE */
const float VF_FOV = 8;	/* sets both fovx and fovy. consider using afov instead. */
const float VF_FOVX = 9;	/* horizontal field of view. does not consider aspect at all. */
const float VF_FOVY = 10;	/* vertical field of view. does not consider aspect at all. */
const float VF_ORIGIN = 11;	/* The origin of the view. Not of the player. */
const float VF_ORIGIN_X = 12;
const float VF_ORIGIN_Y = 13;
const float VF_ORIGIN_Z = 14;
const float VF_ANGLES = 15;	/* The angles the view will be drawn at. Not the angle the client reports to the server. */
const float VF_ANGLES_X = 16;
const float VF_ANGLES_Y = 17;
const float VF_ANGLES_Z = 18;
const float VF_DRAWWORLD = 19;	/* boolean. If set to 1, the engine will draw the world and static/persistant rtlights. If 0, the world will be skipped and everything will be fullbright. */
const float VF_DRAWENGINESBAR = 20;	/* boolean. If set to 1, the sbar will be drawn, and viewsize will be honoured automatically. */
const float VF_DRAWCROSSHAIR = 21;	/* boolean. If set to 1, the engine will draw its default crosshair. */
const float VF_MINDIST = 23;	/* The distance of the near clip plane from the view position. Should generally not be <=0, as this would introduce NANs. */
const float VF_MAXDIST = 24;	/* The distance of the far clip plane from the view position. If 0, will be considered infinite. */
const float VF_CL_VIEWANGLES = 33;
const float VF_CL_VIEWANGLES_X = 34;
const float VF_CL_VIEWANGLES_Y = 35;
const float VF_CL_VIEWANGLES_Z = 36;
const float VF_PERSPECTIVE = 200;	/* 1: regular rendering. Fov specifies the angle. 0: isometric-style. Fov specifies the number of Quake Units each side of the viewport, and mindist restrictions are removed, pvs culling should be disabled. */
#define VF_LPLAYER VF_ACTIVESEAT
const float VF_ACTIVESEAT = 202;	/* The 'seat' number, used when running splitscreen. */
const float VF_AFOV = 203;	/* Aproximate fov. Matches the 'fov' cvar. The engine handles the aspect ratio for you. */
const float VF_SCREENVSIZE = 204;	/* Provides a reliable way to retrieve the current virtual screen size (even if the screen is automatically scaled to retain aspect). */
const float VF_SCREENPSIZE = 205;	/* Provides a reliable way to retrieve the current physical screen size (cvars need vid_restart for them to take effect). */
const float VF_VIEWENTITY = 206;	/* Changes the RF_EXTERNALMODEL flag on entities to match the new selection, and removes entities flaged with RF_VIEWENTITY. Requires cunning use of .entnum and typically requires calling addentities(MASK_VIEWMODEL) too. */
const float VF_RT_DESTCOLOUR = 212;	/* The texture name to write colour info into, this includes both 3d and 2d drawing.
Additional arguments are: format (rgba8=1,rgba16f=2,rgba32f=3), sizexy.
Written to by both 3d and 2d rendering.
Note that any rendertarget textures may be destroyed on video mode changes or so. Shaders can name render targets by prefixing texture names with '$rt:', or $sourcecolour. */
const float VF_RT_SOURCECOLOUR = 209;	/* The texture name to use with shaders that specify a $sourcecolour map. */
const float VF_RT_DEPTH = 210;	/* The texture name to use as a depth buffer. Also used for shaders that specify $sourcedepth. 1-based. Additional arguments are: format (16bit=4,24bit=5,32bit=6), sizexy. */
const float VF_RT_RIPPLE = 211;	/* The texture name to use as a ripplemap (target for shaders with 'sort ripple'). Also used for shaders that specify $ripplemap. 1-based. Additional arguments are: format, sizexy. */
const float VF_ENVMAP = 220;	/* The cubemap name to use as a fallback for $reflectcube, if a shader was unable to load one. Note that this doesn't automatically change shader permutations or anything. */
const float VF_USERDATA = 221;	/* Pointer (and byte size) to an array of vec4s. This data is then globally visible to all glsl via the w_user uniform. */
const float RF_VIEWMODEL = 1;	/* Specifies that the entity is a view model, and that its origin is relative to the current view position. These entities are also subject to viewweapon bob. */
const float RF_EXTERNALMODEL = 2;	/* Specifies that this entity should be displayed in mirrors (and may still cast shadows), but will not otherwise be visible. */
const float RF_DEPTHHACK = 4;	/* Hacks the depth values such that the entity uses depth values as if it were closer to the screen. This is useful when combined with viewmodels to avoid weapons poking in to walls. */
const float RF_ADDITIVE = 8;	/* Shaders from this entity will temporarily be hacked to use an additive blend mode instead of their normal blend mode. */
const float RF_USEAXIS = 16;	/* The entity will be oriented according to the current v_forward+v_right+v_up vector values instead of the entity's .angles field. */
const float RF_NOSHADOW = 32;	/* This entity will not cast shadows. Often useful on view models. */
const float RF_FRAMETIMESARESTARTTIMES = 64;	/* Specifies that the frame1time, frame2time field are timestamps (denoting the start of the animation) rather than time into the animation. */
const float IE_KEYDOWN = 0;	/* Specifies that a key was pressed. Second argument is the scan code. Third argument is the unicode (printable) char value. Fourth argument denotes which keyboard(or mouse, if its a mouse 'scan' key) the event came from. Note that some systems may completely separate scan codes and unicode values, with a 0 value for the unspecified argument. */
const float IE_KEYUP = 1;	/* Specifies that a key was released. Arguments are the same as IE_KEYDOWN. On some systems, this may be fired instantly after IE_KEYDOWN was fired. */
const float IE_MOUSEDELTA = 2;	/* Specifies that a mouse was moved (touch screens and tablets typically give IE_MOUSEABS events instead, use _windowed_mouse 0 to test code to cope with either). Second argument is the X displacement, third argument is the Y displacement. Fourth argument is which mouse or touch event triggered the event. */
const float IE_MOUSEABS = 3;	/* Specifies that a mouse cursor or touch event was moved to a specific location relative to the virtual screen space. Second argument is the new X position, third argument is the new Y position. Fourth argument is which mouse or touch event triggered the event. */
const float IE_ACCELEROMETER = 4;
const float IE_FOCUS = 5;	/* Specifies that input focus was given. parama says mouse focus, paramb says keyboard focus. If either are -1, then it is unchanged. */
const float IE_JOYAXIS = 6;	/* Specifies that what value a joystick/controller axis currently specifies. x=axis, y=value. Will be called multiple times, once for each axis of each active controller. */
const float IE_GYROSCOPE = 7;
const float FILE_READ = 0;	/* The file may be read via fgets to read a single line at a time. */
const float FILE_APPEND = 1;	/* Like FILE_WRITE, but writing starts at the end of the file. */
const float FILE_WRITE = 2;	/* fputs will be used to write to the file. */
const float FILE_READNL = 4;	/* Like FILE_READ, except newlines are not special. fgets reads the entire file into a tempstring. */
const float FILE_MMAP_READ = 5;	/* The file will be loaded into memory. fgets returns a pointer to the first byte (and will always return the same value for this file). Cast this to your datatype. */
const float FILE_MMAP_RW = 6;	/* Like FILE_MMAP_READ, except any changes to the data will be written back to disk once the file is closed. */
const float MASK_ENGINE = 1;	/* Valid as an argument for addentities. If specified, all non-csqc entities will be added to the scene. */
const float MASK_VIEWMODEL = 2;	/* Valid as an argument for addentities. If specified, the regular engine viewmodel will be added to the scene. */
const float PREDRAW_AUTOADD = 0;	/* Valid as a return value from the predraw function. Returning this will cause the engine to automatically invoke addentity(self) for you. */
const float PREDRAW_NEXT = 1;	/* Valid as a return value from the predraw function. Returning this will simply move on to the next entity without the autoadd behaviour, so can be used for particle/invisible/special entites, or entities that were explicitly drawn with addentity. */
const float LFIELD_ORIGIN = 0;
const float LFIELD_COLOUR = 1;
const float LFIELD_RADIUS = 2;
const float LFIELD_FLAGS = 3;
const float LFIELD_STYLE = 4;
const float LFIELD_ANGLES = 5;
const float LFIELD_FOV = 6;
const float LFIELD_CORONA = 7;
const float LFIELD_CORONASCALE = 8;
const float LFIELD_CUBEMAPNAME = 9;
const float LFIELD_AMBIENTSCALE = 10;
const float LFIELD_DIFFUSESCALE = 11;
const float LFIELD_SPECULARSCALE = 12;
const float LFIELD_ROTATION = 13;
const float LFIELD_DIETIME = 14;
const float LFIELD_RGBDECAY = 15;
const float LFIELD_RADIUSDECAY = 16;
const float LFLAG_NORMALMODE = 1;
const float LFLAG_REALTIMEMODE = 2;
const float LFLAG_LIGHTMAP = 4;
const float LFLAG_FLASHBLEND = 8;
const float LFLAG_NOSHADOWS = 256;
const float LFLAG_SHADOWMAP = 512;
const float LFLAG_CREPUSCULAR = 1024;
const float LFLAG_ORTHOSUN = 0;
const float TEREDIT_RELOAD = 0;
const float TEREDIT_SAVE = 1;
const float TEREDIT_SETHOLE = 2;
const float TEREDIT_HEIGHT_SET = 3;
const float TEREDIT_HEIGHT_SMOOTH = 4;
const float TEREDIT_HEIGHT_SPREAD = 5;
const float TEREDIT_HEIGHT_RAISE = 6;
const float TEREDIT_HEIGHT_FLATTEN = 18;
const float TEREDIT_HEIGHT_LOWER = 7;
const float TEREDIT_TEX_KILL = 8;
const float TEREDIT_TEX_GET = 9;
const float TEREDIT_TEX_BLEND = 10;
const float TEREDIT_TEX_UNIFY = 11;
const float TEREDIT_TEX_NOISE = 12;
const float TEREDIT_TEX_BLUR = 13;
const float TEREDIT_TEX_REPLACE = 19;
const float TEREDIT_TEX_SETMASK = 25;
const float TEREDIT_WATER_SET = 14;
const float TEREDIT_MESH_ADD = 15;
const float TEREDIT_MESH_KILL = 16;
const float TEREDIT_TINT = 17;
const float TEREDIT_RESET_SECT = 20;
const float TEREDIT_RELOAD_SECT = 21;
const float TEREDIT_ENT_GET = 26;
const float TEREDIT_ENT_SET = 27;
const float TEREDIT_ENT_ADD = 28;
const float TEREDIT_ENT_COUNT = 29;
const float SLIST_HOSTCACHEVIEWCOUNT = 0;
const float SLIST_HOSTCACHETOTALCOUNT = 1;
const float SLIST_MASTERQUERYCOUNT = 2;
const float SLIST_MASTERREPLYCOUNT = 3;
const float SLIST_SERVERQUERYCOUNT = 4;
const float SLIST_SERVERREPLYCOUNT = 5;
const float SLIST_SORTFIELD = 6;
const float SLIST_SORTDESCENDING = 7;
const float SLIST_TEST_CONTAINS = 0;
const float SLIST_TEST_NOTCONTAIN = 1;
const float SLIST_TEST_LESSEQUAL = 2;
const float SLIST_TEST_LESS = 3;
const float SLIST_TEST_EQUAL = 4;
const float SLIST_TEST_GREATER = 5;
const float SLIST_TEST_GREATEREQUAL = 6;
const float SLIST_TEST_NOTEQUAL = 7;
const float SLIST_TEST_STARTSWITH = 8;
const float SLIST_TEST_NOTSTARTSWITH = 9;
void(vector vang) makevectors = #1; /*
		Takes an angle vector (pitch,yaw,roll) (+x=DOWN). Writes its results into v_forward, v_right, v_up vectors. */

void(entity e, vector o) setorigin = #2; /*
		Changes e's origin to be equal to o. Also relinks collision state (as well as setting absmin+absmax), which is required after changing .solid */

void(entity e, string m) setmodel = #3; /*
		Looks up m in the model precache list, and sets both e.model and e.modelindex to match. BSP models will set e.mins and e.maxs accordingly, other models depend upon the value of sv_gameplayfix_setmodelrealbox - for compatibility you should always call setsize after all pickups or non-bsp models. Also relinks collision state. */

void(entity e, vector min, vector max) setsize = #4; /*
		Sets the e's mins and maxs fields. Also relinks collision state, which sets absmin and absmax too. */

float() random = #7; /*
		Returns a random value between 0 and 1. Be warned, this builtin can return 1 in most engines, which can break arrays. */

void(entity e, float chan, string samp, float vol, float atten, optional float speedpct, optional float flags, optional float timeofs) sound = #8; /*
		Starts a sound centered upon the given entity.
		chan is the entity sound channel to use, channel 0 will allow you to mix many samples at once, others will replace the old sample
		'samp' must have been precached first
		if specified, 'speedpct' should normally be around 100 (or =0), 200 for double speed or 50 for half speed.
		If flags is specified, the reliable flag in the channels argument is used for additional channels. Flags should be made from SOUNDFLAG_* constants
		timeofs should be negative in order to provide a delay before the sound actually starts. */

vector(vector v) normalize = #9; /*
		Shorten or lengthen a direction vector such that it is only one quake unit long. */

void(string e) error = #10; /*
		Ends the game with an easily readable error message. */

void(string e) objerror = #11; /*
		Displays a non-fatal easily readable error message concerning the self entity, including a field dump. self will be removed! */

float(vector v) vlen = #12; /*
		Returns the square root of the dotproduct of a vector with itself. Or in other words the length of a distance vector, in quake units. */

float(vector v, optional entity reference) vectoyaw = #13; /*
		Given a direction vector, returns the yaw angle in which that direction vector points. If an entity is passed, the yaw angle will be relative to that entity's gravity direction. */

entity() spawn = #14; /*
		Adds a brand new entity into the world! Hurrah, you're now a parent! */

void(entity e) remove = #15; /*
		Destroys the given entity and clears some limited fields (including model, modelindex, solid, classname). Any references to the entity following the call are an error. After two seconds, the entity will be reused, in the interim you can unfortunatly still read its fields to see if the reference is no longer valid. */

void(vector v1, vector v2, float flags, entity ent) traceline = #16; /*
		Traces a thin line through the world from v1 towards v2.
		Will not collide with ent, ent.owner, or any entity who's owner field refers to ent.
		The passed entity will also be used to determine whether to use a capsule trace, the contents that the trace should impact, and a couple of other extra fields that define the trace.
		There are no side effects beyond the trace_* globals being written.
		flags&MOVE_NOMONSTERS will not impact on non-bsp entities.
		flags&MOVE_MISSILE will impact with increased size.
		flags&MOVE_HITMODEL will impact upon model meshes, instead of their bounding boxes.
		flags&MOVE_TRIGGERS will also stop on triggers
		flags&MOVE_EVERYTHING will stop if it hits anything, even non-solid entities.
		flags&MOVE_LAGGED will backdate entity positions for the purposes of this builtin according to the indicated player ent's latency, to provide lag compensation. */

entity(entity start, .string fld, string match) find = #18; /*
		Scan for the next entity with a given field set to the given 'match' value. start should be either world, or the previous entity that was found. Returns world on failure/if there are no more.
		If you have many many entities then you may find that hashtables will give more performance (but requires extra upkeep). */

string(string s) precache_sound = #19; /*
		Precaches a sound, making it known to clients and loading it from disk. This builtin (strongly) should be called during spawn functions. This builtin must be called for the sound before the sound builtin is called, or it might not even be heard. */

string(string s) precache_model = #20; /*
		Precaches a model, making it known to clients and loading it from disk if it has a .bsp extension. This builtin (strongly) should be called during spawn functions. This must be called for each model name before setmodel may use that model name.
		Modelindicies precached in SSQC will always be positive. CSQC precaches will be negative if they are not also on the server. */

entity(vector org, float rad, optional .entity chainfield) findradius = #22; /*
		Finds all entities within a distance of the 'org' specified. One entity is returned directly, while other entities are returned via that entity's .chain field. */

void(string s, ...) dprint = #25; /*
		NQ: Prints the given message on the server's console, but only if the developer cvar is set. Arguments will be concatenated into a single message. */

void(string s, ...) dprint = #25; /*
		QW: Unconditionally prints the given message on the server's console.  Arguments will be concatenated into a single message. */

string(float val) ftos = #26; /*
		Returns a tempstring containing a representation of the given float. Precision depends upon engine. */

string(vector val) vtos = #27; /*
		Returns a tempstring containing a representation of the given vector. Precision depends upon engine. */

void() coredump = #28; /*
		Writes out a coredump. This contains stack, globals, and field info for all ents. This can be handy for debugging. */

void() traceon = #29; /*
		Enables tracing. This may be spammy, slow, and stuff. Set debugger 1 in order to use fte's qc debugger. */

void() traceoff = #30; /*
		Disables tracing again. */

void(entity e) eprint = #31; /*
		Debugging builtin that prints all fields of the given entity to the console. */

float(float yaw, float dist, optional float settraceglobals) walkmove = #32; /*
		Attempt to walk the entity at a given angle for a given distance.
		if settraceglobals is set, the trace_* globals will be set, showing the results of the movement.
		This function will trigger touch events. */

float() droptofloor = #34; /*
		Instantly moves the entity downwards until it hits the ground. If the entity is in solid or would need to drop more than 'pr_droptofloorunits' quake units, its position will be considered invalid and the builtin will abort, returning FALSE, otherwise TRUE. */

void(float lightstyle, string stylestring, optional vector rgb) lightstyle = #35; /*
		Specifies an auto-animating string that specifies the light intensity for entities using that lightstyle.
		a is off, z is fully lit. Should be lower case only.
		rgb will recolour all lights using that lightstyle. */

float(float) rint = #36; /*
		Rounds the given float up or down to the closest integeral value. X.5 rounds away from 0 */

float(float) floor = #37; /*
		Rounds the given float downwards, even when negative. */

float(float) ceil = #38; /*
		Rounds the given float upwards, even when negative. */

float(entity ent) checkbottom = #40; /*
		Expensive checks to ensure that the entity is actually sitting on something solid, returns true if it is. */

float(vector pos) pointcontents = #41; /*
		Checks the given point to see what is there. Returns one of the SOLID_* constants. Just because a spot is empty does not mean that the player can stand there due to the size of the player - use tracebox for such tests. */

float(float) fabs = #43; /*
		Removes the sign of the float, making it positive if it is negative. */

float(string) cvar = #45; /*
		Returns the numeric value of the named cvar */

void(string, ...) localcmd = #46; /*
		Adds the string to the console command queue. Commands will not be executed immediately, but rather at the start of the following frame. */

entity(entity) nextent = #47; /*
		Returns the following entity. Skips over removed entities. Returns world when passed the last valid entity. */

void(vector pos, vector dir, float colour, float count) particle = #48; /*
		Spawn 'count' particles around 'pos' moving in the direction 'dir', with a palette colour index between 'colour' and 'colour+8'. */

#define ChangeYaw changeyaw
void() changeyaw = #49; /*
		Changes the self.angles_y field towards self.ideal_yaw by up to self.yaw_speed. */

vector(vector fwd, optional vector up) vectoangles = #51; /*
		Returns the angles (+x=UP) required to orient an entity to look in the given direction. The 'up' argument is required if you wish to set a roll angle, otherwise it will be limited to just monster-style turning. */

float(float angle) sin = #60; /* Part of DP_QC_SINCOSSQRTPOW
		Forgive me father, for I have trigonometry homework. */

float(float angle) cos = #61; /* Part of DP_QC_SINCOSSQRTPOW*/
float(float value) sqrt = #62; /* Part of DP_QC_SINCOSSQRTPOW*/
void(entity ent) changepitch = #63; /* Part of DP_QC_CHANGEPITCH*/
void(entity ent, entity ignore) tracetoss = #64;
string(entity ent) etos = #65; /* Part of DP_QC_ETOS*/
void(float step) movetogoal = #67; /*
		Runs lots and lots of fancy logic in order to try to step the entity the specified distance towards its goalentity. */

string(string s) precache_file = #68; /*
		This builtin does nothing. It was used only as a hint for pak generation. */

void(entity e) makestatic = #69; /*
		Sends a copy of the entity's renderable fields to all clients, and REMOVES the entity, preventing further changes. This means it will be unmutable and non-solid. */

void(string cvarname, string valuetoset) cvar_set = #72; /*
		Instantly sets a cvar to the given string value. */

void (vector pos, string samp, float vol, float atten) ambientsound = #74;
string(string str) precache_model2 = #75;
string(string str) precache_sound2 = #76;
string(string str) precache_file2 = #77;
string(entity e, string key) infokey = #80; /* Part of FTE_QC_INFOKEY, QW_ENGINE
		If e is world, returns the field 'key' from either the serverinfo or the localinfo. If e is a player, returns the value of 'key' from the player's userinfo string. There are a few special exceptions, like 'ip' which is not technically part of the userinfo. */

float(string) stof = #81; /* Part of FRIK_FILE, FTE_QC_INFOKEY, FTE_STRINGS, QW_ENGINE, ZQ_QC_STRINGS*/
string(float style, optional __out vector rgb) getlightstyle = #0:getlightstyle; /*
		Obtains the light style string for the given style. */

vector(float style) getlightstylergb = #0:getlightstylergb; /*
		Obtains the current rgb value of the specified light style. In csqc, this is correct with regard to the current frame, while ssqc gives no guarentees about time and ignores client cvars. Note: use getlight if you want the actual light value at a point. */

void(vector start, vector mins, vector maxs, vector end, float nomonsters, entity ent) tracebox = #90; /* Part of DP_QC_TRACEBOX
		Exactly like traceline, but a box instead of a uselessly thin point. Acceptable sizes are limited by bsp format, q1bsp has strict acceptable size values. */

vector() randomvec = #91; /* Part of DP_QC_RANDOMVEC
		Returns a vector with random values. Each axis is independantly a value between -1 and 1 inclusive. */

vector(vector org) getlight = #92;
float(string cvarname, string defaultvalue) registercvar = #93; /* Part of DP_REGISTERCVAR
		Creates a new cvar on the fly. If it does not already exist, it will be given the specified value. If it does exist, this is a no-op.
		This builtin has the limitation that it does not apply to configs or commandlines. Such configs will need to use the set or seta command causing this builtin to be a noop.
		In engines that support it, you will generally find the autocvar feature easier and more efficient to use. */

float(float a, float b, ...) min = #94; /* Part of DP_QC_MINMAXBOUND
		Returns the lowest value of its arguments. */

float(float a, float b, ...) max = #95; /* Part of DP_QC_MINMAXBOUND
		Returns the highest value of its arguments. */

float(float minimum, float val, float maximum) bound = #96; /* Part of DP_QC_MINMAXBOUND
		Returns val, unless minimum is higher, or maximum is less. */

float(float value, float exp) pow = #97; /* Part of DP_QC_SINCOSSQRTPOW*/
float(float v, optional float base) logarithm = #0:logarithm; /*
		Determines the logarithm of the input value according to the specified base. This can be used to calculate how much something was shifted by. */

#define findentity findfloat
entity(entity start, .__variant fld, __variant match) findfloat = #98; /* Part of DP_QC_FINDFLOAT
		Equivelent to the find builtin, but instead of comparing strings contents, this builtin compares the raw values. This builtin requires multiple calls in order to scan all entities - set start to the previous call's return value.
		world is returned when there are no more entities. */

float(string extname) checkextension = #99; /*
		Checks for an extension by its name (eg: checkextension("FRIK_FILE") says that its okay to go ahead and use strcat).
		Use cvar("pr_checkextension") to see if this builtin exists. */

float(__variant funcref) checkbuiltin = #0:checkbuiltin; /*
		Checks to see if the specified builtin is supported/mapped. This is intended as a way to check for #0 functions, allowing for simple single-builtin functions. Warning, if two different engines map different builtins to the same number, then this function will not tell you which will be called, only that it won't crash (the exception being #0, which are remapped as available). */

float(float value) anglemod = #102;
filestream(string filename, float mode, optional float mmapminsize) fopen = #110; /* Part of FRIK_FILE
		Opens a file, typically prefixed with "data/", for either read or write access. */

void(filestream fhandle) fclose = #111; /* Part of FRIK_FILE*/
string(filestream fhandle) fgets = #112; /* Part of FRIK_FILE
		Reads a single line out of the file. The new line character is not returned as part of the string. Returns the null string on EOF (use if not(string) to easily test for this, which distinguishes it from the empty string which is returned if the line being read is blank */

void(filestream fhandle, string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7) fputs = #113; /* Part of FRIK_FILE
		Writes the given string(s) into the file. For compatibility with fgets, you should ensure that the string is terminated with a \n - this will not otherwise be done for you. It is up to the engine whether dos or unix line endings are actually written. */

int(filestream fhandle, void *ptr, int size) fread = #0:fread; /* Part of FTE_QC_FILE_BINARY
		Reads binary data out of the file. Returns truncated lengths if the read exceeds the length of the file. */

int(filestream fhandle, void *ptr, int size) fwrite = #0:fwrite; /* Part of FTE_QC_FILE_BINARY
		Writes binary data out of the file. */

#define ftell fseek //c compat
int(filestream fhandle, optional int newoffset) fseek = #0:fseek; /* Part of FTE_QC_FILE_BINARY
		Changes the current position of the file, if specified. Returns prior position, in bytes. */

int(filestream fhandle, optional int newsize) fsize = #0:fsize; /* Part of FTE_QC_FILE_BINARY
		Reports the total size of the file, in bytes. Can also be used to truncate/extend the file */

float(string s) strlen = #114; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
string(string s1, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7, optional string s8) strcat = #115; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
string(string s, float start, float length) substring = #116; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
vector(string s) stov = #117; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
string(string s, ...) strzone = #118; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS
		Create a semi-permanent copy of a string that only becomes invalid once strunzone is called on the string (instead of when the engine assumes your string has left scope). This builtin has become redundant in FTEQW due to the FTE_QC_PERSISTENTTEMPSTRINGS extension and is now functionally identical to strcat for compatibility with old engines+mods. */

void(string s) strunzone = #119; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS
		Destroys a string that was allocated by strunzone. Further references to the string MAY crash the game. In FTE, this function became redundant and now does nothing. */

void(string soundname, optional float channel, optional float volume) localsound = #177; /*
		Plays a sound... locally... probably best not to call this from ssqc. Also disables reverb. */

float(string modelname, optional float queryonly) getmodelindex = #200; /*
		Acts as an alternative to precache_model(foo);setmodel(bar, foo); return bar.modelindex;
		If queryonly is set and the model was not previously precached, the builtin will return 0 without needlessly precaching the model. */

__variant(float prnum, string funcname, ...) externcall = #201; /* Part of FTE_MULTIPROGS
		Directly call a function in a different/same progs by its name.
		prnum=0 is the 'default' or 'main' progs.
		prnum=-1 means current progs.
		prnum=-2 will scan through the active progs and will use the first it finds. */

float(string progsname) addprogs = #202; /* Part of FTE_MULTIPROGS
		Loads an additional .dat file into the current qcvm. The returned handle can be used with any of the externcall/externset/externvalue builtins.
		There are cvars that allow progs to be loaded automatically. */

__variant(float prnum, string varname) externvalue = #203; /* Part of FTE_MULTIPROGS
		Reads a global in the named progs by the name of that global.
		prnum=0 is the 'default' or 'main' progs.
		prnum=-1 means current progs.
		prnum=-2 will scan through the active progs and will use the first it finds. */

void(float prnum, __variant newval, string varname) externset = #204; /* Part of FTE_MULTIPROGS
		Sets a global in the named progs by name.
		prnum=0 is the 'default' or 'main' progs.
		prnum=-1 means current progs.
		prnum=-2 will scan through the active progs and will use the first it finds. */

void(entity portal, float state) openportal = #207; /*
		Opens or closes the portals associated with a door or some such on q2 or q3 maps. On Q2BSPs, the entity should be the 'func_areaportal' entity - its style field will say which portal to open. On Q3BSPs, the entity is the door itself, the portal will be determined by the two areas found from a preceding setorigin call. */

void(optional __variant ret) abort = #211; /* Part of FTE_MULTITHREADED
		QC execution is aborted. Parent QC functions on the stack will be skipped, effectively this forces all QC functions to 'return ret' until execution returns to the engine. If ret is ommited, it is assumed to be 0. */

void(vector org, vector dmin, vector dmax, float colour, float effect, float count) particle2 = #215; /* Part of FTE_HEXEN2*/
void(vector org, vector box, float colour, float effect, float count) particle3 = #216; /* Part of FTE_HEXEN2*/
void(vector org, float radius, float colour, float effect, float count) particle4 = #217; /* Part of FTE_HEXEN2*/
float(float number, float quantity) bitshift = #218; /* Part of EXT_BITSHIFT*/
void(vector pos) te_lightningblood = #219; /* Part of FTE_TE_STANDARDEFFECTBUILTINS*/
float(string s1, string sub, optional float startidx) strstrofs = #221; /* Part of FTE_STRINGS
		Returns the 0-based offset of sub within the s1 string, or -1 if sub is not in s1.
		If startidx is set, this builtin will ignore matches before that 0-based offset. */

float(string str, float index) str2chr = #222; /* Part of FTE_STRINGS
		Retrieves the character value at offset 'index'. */

string(float chr, ...) chr2str = #223; /* Part of FTE_STRINGS
		The input floats are considered character values, and are concatenated. */

string(float ccase, float redalpha, float redchars, string str, ...) strconv = #224; /* Part of FTE_STRINGS
		Converts quake chars in the input string amongst different representations.
		ccase specifies the new case for letters.
		 0: not changed.
		 1: forced to lower case.
		 2: forced to upper case.
		redalpha and redchars switch between colour ranges.
		 0: no change.
		 1: Forced white.
		 2: Forced red.
		 3: Forced gold(low) (numbers only).
		 4: Forced gold (high) (numbers only).
		 5+6: Forced to white and red alternately.
		You should not use this builtin in combination with UTF-8. */

string(float pad, string str1, ...) strpad = #225; /* Part of FTE_STRINGS
		Pads the string with spaces, to ensure its a specific length (so long as a fixed-width font is used, anyway). If pad is negative, the spaces are added on the left. If positive the padding is on the right. */

string(infostring old, string key, string value) infoadd = #226; /* Part of FTE_STRINGS
		Returns a new tempstring infostring with the named value changed (or added if it was previously unspecified). Key and value may not contain the \ character. */

string(infostring info, string key) infoget = #227; /* Part of FTE_STRINGS
		Reads a named value from an infostring. The returned value is a tempstring */

#define strcmp strncmp
float(string s1, string s2, optional float len, optional float s1ofs, optional float s2ofs) strncmp = #228; /* Part of FTE_STRINGS
		Compares up to 'len' chars in the two strings. s1ofs allows you to treat s2 as a substring to compare against, or should be 0.
		Returns 0 if the two strings are equal, a negative value if s1 appears numerically lower, and positive if s1 appears numerically higher. */

float(string s1, string s2) strcasecmp = #229; /* Part of FTE_STRINGS
		Compares the two strings without case sensitivity.
		Returns 0 if they are equal. The sign of the return value may be significant, but should not be depended upon. */

float(string s1, string s2, float len, optional float s1ofs, optional float s2ofs) strncasecmp = #230; /* Part of FTE_STRINGS
		Compares up to 'len' chars in the two strings without case sensitivity. s1ofs allows you to treat s2 as a substring to compare against, or should be 0.
		Returns 0 if they are equal. The sign of the return value may be significant, but should not be depended upon. */

string(string s) strtrim = #0:strtrim; /*
		Trims the whitespace from the start+end of the string. */

void() calltimeofday = #231; /* Part of FTE_CALLTIMEOFDAY
		Asks the engine to instantly call the qc's 'timeofday' function, before returning. For compatibility with mvdsv.
		timeofday should have the prototype: void(float secs, float mins, float hour, float day, float mon, float year, string strvalue)
		The strftime builtin is more versatile and less weird. */

void(vector angle) rotatevectorsbyangle = #235; /*
		rotates the v_forward,v_right,v_up matrix by the specified angles. */

void(vector fwd, vector right, vector up) rotatevectorsbyvectors = #236;
float(float mdlindex, string skinname) skinforname = #237;
float(string shadername, optional string defaultshader, ...) shaderforname = #238; /* Part of FTE_FORCESHADER
		Caches the named shader and returns a handle to it.
		If the shader could not be loaded from disk (missing file or ruleset_allow_shaders 0), it will be created from the 'defaultshader' string if specified, or a 'skin shader' default will be used.
		defaultshader if not empty should include the outer {} that you would ordinarily find in a shader. */

void(vector org, optional float count) te_bloodqw = #239; /* Part of FTE_TE_STANDARDEFFECTBUILTINS*/
float(vector viewpos, entity entity) checkpvs = #240; /* Part of FTE_QC_CHECKPVS*/
vector(entity ent, float tagnum) rotatevectorsbytag = #244;
float(float dividend, float divisor) mod = #245;
int(string) stoi = #259; /* Part of FTE_QC_INTCONV
		Converts the given string into a true integer. Base 8, 10, or 16 is determined based upon the format of the string. */

string(int) itos = #260; /* Part of FTE_QC_INTCONV
		Converts the passed true integer into a base10 string. */

int(string) stoh = #261; /* Part of FTE_QC_INTCONV
		Reads a base-16 string (with or without 0x prefix) as an integer. Bugs out if given a base 8 or base 10 string. :P */

string(int) htos = #262; /* Part of FTE_QC_INTCONV
		Formats an integer as a base16 string, with leading 0s and no prefix. Always returns 8 characters. */

int(float) ftoi = #0:ftoi; /* Part of FTE_QC_INTCONV
		Converts the given float into a true integer without depending on extended qcvm instructions. */

float(int) itof = #0:itof; /* Part of FTE_QC_INTCONV
		Converts the given true integer into a float without depending on extended qcvm instructions. */

float(float modlindex, optional float useabstransforms) skel_create = #263; /* Part of FTE_CSQC_SKELETONOBJECTS
		Allocates a new uninitiaised skeletal object, with enough bone info to animate the given model.
		eg: self.skeletonobject = skel_create(self.modelindex); */

typedef struct
{
	int sourcemodelindex; /*frame data will be imported from this model, bones must be compatible*/
	int reserved;
	int firstbone;
	int lastbone;
	float prescale;	/*0 destroys existing data, 1 retains it*/
	float scale[4];	/*you'll need to do lerpfrac manually*/
	int animation[4];
	float animationtime[4];
	/*halflife models*/
	float subblend[2];
	float controllers[5];
} skelblend_t;
float(float skel, entity ent, float modelindex, float retainfrac, float firstbone, float lastbone, optional float addfrac) skel_build = #264; /* Part of FTE_CSQC_SKELETONOBJECTS
		Animation data (according to the entity's frame info) is pulled from the specified model and blended into the specified skeletal object.
		If retainfrac is set to 0 on the first call and 1 on the others, you can blend multiple animations together according to the addfrac value. The final weight should be 1. Other values will result in scaling and/or other weirdness. You can use firstbone and lastbone to update only part of the skeletal object, to allow legs to animate separately from torso, use 0 for both arguments to specify all, as bones are 1-based. */

float(float skel, int numblends, skelblend_t *weights, int structsize) skel_build_ptr = #0:skel_build_ptr; /*
		Like skel_build, but slightly simpler. */

float(float skel) skel_get_numbones = #265; /* Part of FTE_CSQC_SKELETONOBJECTS
		Retrives the number of bones in the model. The valid range is 1<=bone<=numbones. */

string(float skel, float bonenum) skel_get_bonename = #266; /* Part of FTE_CSQC_SKELETONOBJECTS
		Retrieves the name of the specified bone. Mostly only for debugging. */

float(float skel, float bonenum) skel_get_boneparent = #267; /* Part of FTE_CSQC_SKELETONOBJECTS
		Retrieves which bone this bone's position is relative to. Bone 0 refers to the entity's position rather than an actual bone */

float(float skel, string tagname) skel_find_bone = #268; /* Part of FTE_CSQC_SKELETONOBJECTS
		Finds a bone by its name, from the model that was used to create the skeletal object. */

vector(float skel, float bonenum) skel_get_bonerel = #269; /* Part of FTE_CSQC_SKELETONOBJECTS
		Gets the bone position and orientation relative to the bone's parent. Return value is the offset, and v_forward, v_right, v_up contain the orientation. */

vector(float skel, float bonenum) skel_get_boneabs = #270; /* Part of FTE_CSQC_SKELETONOBJECTS
		Gets the bone position and orientation relative to the entity. Return value is the offset, and v_forward, v_right, v_up contain the orientation.
		Use gettaginfo for world coord+orientation. */

void(float skel, float bonenum, vector org, optional vector fwd, optional vector right, optional vector up) skel_set_bone = #271; /* Part of FTE_CSQC_SKELETONOBJECTS
		Sets a bone position relative to its parent. If the orientation arguments are not specified, v_forward+v_right+v_up are used instead. */

void(float skel, float bonenum, vector org, optional vector fwd, optional vector right, optional vector up) skel_premul_bone = #272; /* Part of FTE_CSQC_SKELETONOBJECTS
		Transforms a single bone by a matrix. You can use makevectors to generate a rotation matrix from an angle. */

void(float skel, float startbone, float endbone, vector org, optional vector fwd, optional vector right, optional vector up) skel_premul_bones = #273; /* Part of FTE_CSQC_SKELETONOBJECTS
		Transforms an entire consecutive range of bones by a matrix. You can use makevectors to generate a rotation matrix from an angle, but you'll probably want to divide the angle by the number of bones. */

void(float skel, float bonenum, vector org, optional vector fwd, optional vector right, optional vector up) skel_postmul_bone = #0:skel_postmul_bone; /*
		Transforms a single bone by a matrix. You can use makevectors to generate a rotation matrix from an angle. */

void(float skeldst, float skelsrc, float startbone, float entbone) skel_copybones = #274; /* Part of FTE_CSQC_SKELETONOBJECTS
		Copy bone data from one skeleton directly into another. */

void(float skel) skel_delete = #275; /* Part of FTE_CSQC_SKELETONOBJECTS
		Deletes a skeletal object. The actual delete is delayed, allowing the skeletal object to be deleted in an entity's predraw function yet still be valid by the time the addentity+renderscene builtins need it. Also uninstanciates any ragdoll currently in effect on the skeletal object. */

float(float modidx, string framename) frameforname = #276; /* Part of FTE_CSQC_SKELETONOBJECTS
		Looks up a framegroup from a model by name, avoiding the need for hardcoding. Returns -1 on error. */

float(float modidx, float framenum) frameduration = #277; /* Part of FTE_CSQC_SKELETONOBJECTS
		Retrieves the duration (in seconds) of the specified framegroup. */

void(float modidx, float framenum, __inout float basetime, float targettime, void(float timestamp, int code, string data) callback) processmodelevents = #0:processmodelevents; /* Part of FTE_GFX_MODELEVENTS
		Calls a callback for each event that has been reached. Basetime is set to targettime. */

float(float modidx, float framenum, __inout float basetime, float targettime, __out int code, __out string data) getnextmodelevent = #0:getnextmodelevent; /*
		Reports the next event within a model's animation. Returns a boolean if an event was found between basetime and targettime. Writes to basetime,code,data arguments (if an event was found, basetime is set to the event's time, otherwise to targettime).
		WARNING: this builtin cannot deal with multiple events with the same timestamp (only the first will be reported). */

float(float modidx, float framenum, int eventidx, __out float timestamp, __out int code, __out string data) getmodeleventidx = #0:getmodeleventidx; /*
		Reports an indexed event within a model's animation. Writes to timestamp,code,data arguments on success. Returns false if the animation/event/model was out of range/invalid. Does not consider looping animations (retry from index 0 if it fails and you know that its a looping animation). This builtin is more annoying to use than getnextmodelevent, but can be made to deal with multiple events with the exact same timestamp. */

#define dotproduct(v1,v2) ((vector)(v1)*(vector)(v2))
vector(vector v1, vector v2) crossproduct = #0:crossproduct; /* Part of FTE_QC_CROSSPRODUCT
		Small helper function to calculate the crossproduct of two vectors. */

float(entity pusher, vector move, vector amove) pushmove = #0:pushmove;
void(float action, optional vector pos, optional float radius, optional float quant, ...) terrain_edit = #278; /* Part of FTE_TERRAIN_MAP
		Realtime terrain editing. Actions are the TEREDIT_ constants. */

typedef struct
{
	string	shadername;
	vector	planenormal;
	float	planedist;
	vector	sdir;
	float	sbias;
	vector	tdir;
	float	tbias;
} brushface_t;
int(float modelidx, int brushid, brushface_t *out_faces, int maxfaces, int *out_contents) brush_get = #0:brush_get; /* Part of FTE_RAW_MAP
		Queries a brush's information. You must pre-allocate the face array for the builtin to write to. Return value is the number of faces retrieved, 0 on error. */

int(float modelidx, brushface_t *in_faces, int numfaces, int contents, optional int brushid) brush_create = #0:brush_create; /* Part of FTE_RAW_MAP
		Inserts a new brush into the model. Return value is the new brush's id. */

void(float modelidx, int brushid) brush_delete = #0:brush_delete; /* Part of FTE_RAW_MAP
		Destroys the specified brush. */

float(float modelid, int brushid, int faceid, float selectedstate) brush_selected = #0:brush_selected; /* Part of FTE_RAW_MAP
		Allows you to easily set transient visual properties of a brush. returns old value. selectedstate=-1 changes nothing (called for its return value). */

int(float modelid, int brushid, int faceid, vector *points, int maxpoints) brush_getfacepoints = #0:brush_getfacepoints; /* Part of FTE_RAW_MAP
		Returns the list of verticies surrounding the given face. If face is 0, returns the center of the brush (if space for 1 point) or the mins+maxs (if space for 2 points). */

int(int faceid, brushface_t *in_faces, int numfaces, vector *points, int maxpoints) brush_calcfacepoints = #0:brush_calcfacepoints; /* Part of FTE_RAW_MAP
		Determines the points of the specified face, if the specified brush were to actually be created. */

int(float modelid, vector *planes, float *dists, int numplanes, int *out_brushes, int *out_faces, int maxresults) brush_findinvolume = #0:brush_findinvolume; /* Part of FTE_RAW_MAP
		Allows you to easily obtain a list of brushes+faces within the given bounding region. If out_faces is not null, the same brush might be listed twice. */

void(optional entity ent, optional vector neworigin) touchtriggers = #279; /*
		Triggers a touch events between self and every SOLID_TRIGGER entity that it is in contact with. This should typically just be the triggers touch functions. Also optionally updates the origin of the moved entity. */

float(entity skelent, string dollcmd, float animskel) skel_ragupdate = #281; /*
		Updates the skeletal object attached to the entity according to its origin and other properties.
		if animskel is non-zero, the ragdoll will animate towards the bone state in the animskel skeletal object, otherwise they will pick up the model's base pose which may not give nice results.
		If dollcmd is not set, the ragdoll will update (this should be done each frame).
		If the doll is updated without having a valid doll, the model's default .doll will be instanciated.
		commands:
		 doll foo.doll : sets up the entity to use the named doll file
		 dollstring TEXT : uses the doll file directly embedded within qc, with that extra prefix.
		 cleardoll : uninstanciates the doll without destroying the skeletal object.
		 animate 0.5 : specifies the strength of the ragdoll as a whole 
		 animatebody somebody 0.5 : specifies the strength of the ragdoll on a specific body (0 will disable ragdoll animations on that body).
		 enablejoint somejoint 1 : enables (or disables) a joint. Disabling joints will allow the doll to shatter. */

float*(float skel) skel_mmap = #282; /*
		Map the bones in VM memory. They can then be accessed via pointers. Each bone is 12 floats, the four vectors interleaved (sadly). */

void(entity ent, float bonenum, vector org, optional vector angorfwd, optional vector right, optional vector up) skel_set_bone_world = #283; /*
		Sets the world position of a bone within the given entity's attached skeletal object. The world position is dependant upon the owning entity's position. If no orientation argument is specified, v_forward+v_right+v_up are used for the orientation instead. If 1 is specified, it is understood as angles. If 3 are specified, they are the forawrd/right/up vectors to use. */

string(float modidx, float framenum) frametoname = #284;
string(float modidx, float skin) skintoname = #285;
float(float resourcetype, float tryload, string resourcename) resourcestatus = #286; /*
		resourcetype must be one of the RESTYPE_ constants. Returns one of the RESSTATE_ constants. Tryload 0 is a query only. Tryload 1 will attempt to reload the content if it was flushed. */

hashtable(float tabsize, optional float defaulttype) hash_createtab = #287; /* Part of FTE_QC_HASHTABLES
		Creates a hash table object with at least 'tabsize' slots. hash table with index 0 is a game-persistant table and will NEVER be returned by this builtin (except as an error return). */

void(hashtable table) hash_destroytab = #288; /* Part of FTE_QC_HASHTABLES
		Destroys a hash table object. */

void(hashtable table, string name, __variant value, optional float typeandflags) hash_add = #289; /* Part of FTE_QC_HASHTABLES
		Adds the given key with the given value to the table.
		If flags&HASH_REPLACE, the old value will be removed, if not set then multiple values may be added for a single key, they won't overwrite.
		The type argument describes how the value should be stored and saved to files. While you can claim that all variables are just vectors, being more precise can result in less issues with tempstrings or saved games. */

__variant(hashtable table, string name, optional __variant deflt, optional float requiretype, optional float index) hash_get = #290; /* Part of FTE_QC_HASHTABLES
		looks up the specified key name in the hash table. returns deflt if key was not found. If stringsonly=1, the return value will be in the form of a tempstring, otherwise it'll be the original value argument exactly as it was. If requiretype is specified, then values not of the specified type will be ignored. Hurrah for multiple types with the same name. */

__variant(hashtable table, string name) hash_delete = #291; /* Part of FTE_QC_HASHTABLES
		removes the named key. returns the value of the object that was destroyed, or 0 on error. */

string(hashtable table, float idx) hash_getkey = #292; /* Part of FTE_QC_HASHTABLES
		gets some random key name. add+delete can change return values of this, so don't blindly increment the key index if you're removing all. */

float(string name) checkcommand = #294; /* Part of FTE_QC_CHECKCOMMAND
		Checks to see if the supplied name is a valid command, cvar, or alias. Returns 0 if it does not exist. */

string(string s) argescape = #295; /*
		Marks up a string so that it can be reliably tokenized as a single argument later. */

float(float mdlidx) modelframecount = #0:modelframecount; /*
		Retrieves the number of frames in the specified model. */

void() clearscene = #300; /*
		Forgets all rentities, polygons, and temporary dlights. Resets all view properties to their default values. */

void(float mask) addentities = #301; /*
		Walks through all entities effectively doing this:
		 if (ent.drawmask&mask){ if (!ent.predaw()) addentity(ent); }
		If mask&MASK_DELTA, non-csqc entities, particles, and related effects will also be added to the rentity list.
		 If mask&MASK_STDVIEWMODEL then the default view model will also be added. */

void(entity ent) addentity = #302; /*
		Copies the entity fields into a new rentity for later rendering via addscene. */

void(entity ent) removeentity = #0:removeentity; /*
		Undoes all addentities added to the scene from the given entity, without removing ALL entities (useful for splitscreen/etc, readd modified versions as desired). */

typedef float vec2[2];
typedef float vec3[3];
typedef float vec4[4];
typedef struct trisoup_simple_vert_s {vec3 xyz;vec2 st;vec4 rgba;} trisoup_simple_vert_t;
void(string texturename, int flags, struct trisoup_simple_vert_s *verts, int *indexes, int numindexes) addtrisoup_simple = #0:addtrisoup_simple; /*
		Adds the specified trisoup into the scene as additional geometry. This permits caching geometry to reduce builtin spam. Indexes are a triangle list (so eg quads will need 6 indicies to form two triangles). NOTE: this is not going to be a speedup over polygons if you're still generating lots of new data every frame. */

#define setviewprop setproperty
float(float property, ...) setproperty = #303; /*
		Allows you to override default view properties like viewport, fov, and whether the engine hud will be drawn. Different VF_ values have slightly different arguments, some are vectors, some floats. */

void() renderscene = #304; /*
		Draws all entities, polygons, and particles on the rentity list (which were added via addentities or addentity), using the various view properties set via setproperty. There is no ordering dependancy.
		The scene must generally be cleared again before more entities are added, as entities will persist even over to the next frame.
		You may call this builtin multiple times per frame, but should only be called from CSQC_UpdateView. */

float(vector org, float radius, vector lightcolours, optional float style, optional string cubemapname, optional float pflags) dynamiclight_add = #305; /*
		Adds a temporary dlight, ready to be drawn via addscene. Cubemap orientation will be read from v_forward/v_right/v_up. */

void(string texturename, optional float flags, optional float is2d) R_BeginPolygon = #306; /*
		Specifies the shader to use for the following polygons, along with optional flags.
		If is2d, the polygon will be drawn as soon as the EndPolygon call is made, rather than waiting for renderscene. This allows complex 2d effects. */

void(vector org, vector texcoords, vector rgb, float alpha) R_PolygonVertex = #307; /*
		Specifies a polygon vertex with its various properties. */

void() R_EndPolygon = #308; /*
		Ends the current polygon. At least 3 verticies must have been specified. You do not need to call beginpolygon if you wish to draw another polygon with the same shader. */

#define getviewprop getproperty
__variant(float property) getproperty = #309; /*
		Retrieve a currently-set (typically view) property, allowing you to read the current viewport or other things. Due to cheat protection, certain values may be unretrievable. */

vector (vector v) unproject = #310; /*
		Transform a 2d screen-space point (with depth) into a 3d world-space point, according the various origin+angle+fov etc settings set via setproperty. */

vector (vector v) project = #311; /*
		Transform a 3d world-space point into a 2d screen-space point, according the various origin+angle+fov etc settings set via setproperty. */

void(vector pos, vector size, float alignflags, string text) drawtextfield = #0:drawtextfield; /*
		Draws a multi-line block of text, including word wrapping and alignment. alignflags bits are RTLB, typically 3. */

void(float width, vector pos1, vector pos2, vector rgb, float alpha, optional float drawflag) drawline = #315; /*
		Draws a 2d line between the two 2d points. */

float(string name) iscachedpic = #316; /*
		Checks to see if the image is currently loaded. Engines might lie, or cache between maps. */

string(string name, optional float trywad) precache_pic = #317; /*
		Forces the engine to load the named image. If trywad is specified, the specified name must any lack path and extension. */

void(string imagename, int width, int height, int *pixeldata) r_uploadimage = #0:r_uploadimage; /* Part of FTE_CSQC_RAWIMAGES
		Updates a texture with the specified rgba data. Will be created if needed. */

int*(string filename, __out int width, __out int height) r_readimage = #0:r_readimage; /* Part of FTE_CSQC_RAWIMAGES
		Reads and decodes an image from disk, providing raw pixel data. Returns __NULL__ if the image could not be read for any reason. Use memfree to free the data once you're done with it. */

#define draw_getimagesize drawgetimagesize
vector(string picname) drawgetimagesize = #318; /*
		Returns the dimensions of the named image. Images specified with .lmp should give the original .lmp's dimensions even if texture replacements use a different resolution. */

void(string name) freepic = #319; /*
		Tells the engine that the image is no longer needed. The image will appear to be new the next time its needed. */

float(vector position, float character, vector size, vector rgb, float alpha, optional float drawflag) drawcharacter = #320; /*
		Draw the given quake character at the given position.
		If flag&4, the function will consider the char to be a unicode char instead (or display as a ? if outside the 32-127 range).
		size should normally be something like '8 8 0'.
		rgb should normally be '1 1 1'
		alpha normally 1.
		Software engines may assume the named defaults.
		Note that ALL text may be rescaled on the X axis due to variable width fonts. The X axis may even be ignored completely. */

float(vector position, string text, vector size, vector rgb, float alpha, optional float drawflag) drawrawstring = #321; /*
		Draws the specified string without using any markup at all, even in engines that support it.
		If UTF-8 is globally enabled in the engine, then that encoding is used (without additional markup), otherwise it is raw quake chars.
		Software engines may assume a size of '8 8 0', rgb='1 1 1', alpha=1, flag&3=0, but it is not an error to draw out of the screen. */

float(vector position, string pic, vector size, vector rgb, float alpha, optional float drawflag) drawpic = #322; /*
		Draws an shader within the given 2d screen box. Software engines may omit support for rgb+alpha, but must support rescaling, and must clip to the screen without crashing. */

float(vector position, vector size, vector rgb, float alpha, optional float drawflag) drawfill = #323; /*
		Draws a solid block over the given 2d box, with given colour, alpha, and blend mode (specified via flags).
		flags&3=0 simple blend.
		flags&3=1 additive blend */

void(float x, float y, float width, float height) drawsetcliparea = #324; /*
		Specifies a 2d clipping region (aka: scissor test). 2d draw calls will all be clipped to this 2d box, the area outside will not be modified by any 2d draw call (even 2d polygons). */

void(void) drawresetcliparea = #325; /*
		Reverts the scissor/clip area to the whole screen. */

float(vector position, string text, vector size, vector rgb, float alpha, float drawflag) drawstring = #326; /*
		Draws a string, interpreting markup and recolouring as appropriate. */

float(string text, float usecolours, optional vector fontsize) stringwidth = #327; /*
		Calculates the width of the screen in virtual pixels. If usecolours is 1, markup that does not affect the string width will be ignored. Will always be decoded as UTF-8 if UTF-8 is globally enabled.
		If the char size is not specified, '8 8 0' will be assumed. */

void(vector pos, vector sz, string pic, vector srcpos, vector srcsz, vector rgb, float alpha, optional float drawflag) drawsubpic = #328; /*
		Draws a rescaled subsection of an image to the screen. */

void(vector pivot, vector mins, vector maxs, string pic, vector rgb, float alpha, float angle) drawrotpic = #0:drawrotpic; /*
		Draws an image rotating at the pivot. To rotate in the center, use mins+maxs of half the size with mins negated. Angle is in degrees. */

void(vector pivot, vector mins, vector maxs, string pic, vector txmin, vector txsize, vector rgb, vector alphaandangles) drawrotsubpic = #0:drawrotsubpic; /*
		Overcomplicated draw function for over complicated people. Positions follow drawrotpic, while texture coords follow drawsubpic. Due to argument count limitations in builtins, the alpha value and angles are combined into separate fields of a vector (tip: use fteqcc's [alpha, angle] feature. */

#define getstati_punf(stnum) (float)(__variant)getstati(stnum)
int(float stnum) getstati = #330; /*
		Retrieves the numerical value of the given EV_INTEGER or EV_ENTITY stat. Use getstati_punf if you wish to type-pun a float stat as an int to avoid truncation issues in DP. */

#define getstatbits getstatf
float(float stnum, optional float firstbit, optional float bitcount) getstatf = #331; /*
		Retrieves the numerical value of the given EV_FLOAT stat. If firstbit and bitcount are specified, retrieves the upper bits of the STAT_ITEMS stat (converted into a float, so there are no VM dependancies). */

string(float stnum) getstats = #332; /*
		Retrieves the value of the given EV_STRING stat, as a tempstring.
		Older engines may use 4 consecutive integer stats, with a limit of 15 chars (yes, really. 15.), but FTE Quake uses a separate namespace for string stats and has a much higher length limit. */

__variant(float playernum, float statnum, float stattype) getplayerstat = #0:getplayerstat; /*
		Retrieves a specific player's stat, matching the type specified on the server. This builtin is primarily intended for mvd playback where ALL players are known. For EV_ENTITY, world will be returned if the entity is not in the pvs, use type-punning with EV_INTEGER to get the entity number if you just want to see if its set. STAT_ITEMS should be queried as an EV_INTEGER on account of runes and items2 being packed into the upper bits. */

void(entity e, float mdlindex) setmodelindex = #333; /*
		Sets a model by precache index instead of by name. Otherwise identical to setmodel. */

string(float mdlindex) modelnameforindex = #334; /*
		Retrieves the name of the model based upon a precache index. This can be used to reduce csqc network traffic by enabling model matching. */

float(string effectname) particleeffectnum = #335; /* Part of DP_ENT_TRAILEFFECTNUM, FTE_SV_POINTPARTICLES
		Precaches the named particle effect. If your effect name is of the form 'foo.bar' then particles/foo.cfg will be loaded by the client if foo.bar was not already defined.
		Different engines will have different particle systems, this specifies the QC API only. */

void(float effectnum, entity ent, vector start, vector end) trailparticles = #336; /* Part of FTE_SV_POINTPARTICLES
		Draws the given effect between the two named points. If ent is not world, distances will be cached in the entity in order to avoid framerate dependancies. The entity is not otherwise used. */

void(float effectnum, vector origin, optional vector dir, optional float count) pointparticles = #337; /* Part of FTE_SV_POINTPARTICLES
		Spawn a load of particles from the given effect at the given point traveling or aiming along the direction specified. The number of particles are scaled by the count argument.
		For regular particles, the dir vector is multiplied by the 'veladd' property (while orgadd will push the particles along it). Decals will use it as a hint to align to the correct surface. In both cases, it should normally be a unit vector, but other lengths will still work. If it has length 0 then FTE will assume downwards. */

void(string s, ...) cprint = #338; /*
		Print into the center of the screen just as ssqc's centerprint would appear. */

void(string s, ...) print = #339; /* Part of DP_SV_PRINT
		Unconditionally print on the local system's console, even in ssqc (doesn't care about the value of the developer cvar). */

string(float keynum) keynumtostring = #340; /*
		Returns a hunam-readable name for the given keycode, as a tempstring. */

float(string keyname) stringtokeynum = #341; /*
		Looks up the key name in the same way that the bind command would, returning the keycode for that key. */

string(float keynum) getkeybind = #342; /*
		Returns the current binding for the given key (returning only the command executed when no modifiers are pressed). */

void(float usecursor, optional string cursorimage, optional vector hotspot, optional float scale) setcursormode = #343; /*
		Pass TRUE if you want the engine to release the mouse cursor (absolute input events + touchscreen mode). Pass FALSE if you want the engine to grab the cursor (relative input events + standard looking). If the image name is specified, the engine will use that image for a cursor (use an empty string to clear it again), in a way that will not conflict with the console. Images specified this way will be hardware accelerated, if supported by the platform/port. */

float(float effective) getcursormode = #0:getcursormode; /*
		Reports the cursor mode this module previously attempted to use. If 'effective' is true, reports the cursor mode currently active (if was overriden by a different module which has precidence, for instance, or if there is only a touchscreen and no mouse). */

vector() getmousepos = #344; /*
		Nasty convoluted DP extension. Typically returns deltas instead of positions. Use CSQC_InputEvent for such things in csqc mods. */

float(float inputsequencenum) getinputstate = #345; /*
		Looks up an input frame from the log, setting the input_* globals accordingly.
		The sequence number range used for prediction should normally be servercommandframe < sequence <= clientcommandframe.
		The sequence equal to clientcommandframe will change between input frames. */

void(float sens) setsensitivityscaler = #346; /*
		Temporarily scales the player's mouse sensitivity based upon something like zoom, avoiding potential cvar saving and thus corruption. */

void(entity ent) runstandardplayerphysics = #347; /*
		Perform the engine's standard player movement prediction upon the given entity using the input_* globals to describe movement. */

string(float playernum, string keyname) getplayerkeyvalue = #348; /*
		Look up a player's userinfo, to discover things like their name, topcolor, bottomcolor, skin, team, *ver.
		Also includes scoreboard info like frags, ping, pl, userid, entertime, as well as voipspeaking and voiploudness. */

float(float playernum, string keyname, optional float assumevalue) getplayerkeyfloat = #0:getplayerkeyfloat; /*
		Cheaper version of getplayerkeyvalue that avoids the need for so many tempstrings. */

float() isdemo = #349; /*
		Returns if the client is currently playing a demo or not */

float() isserver = #350; /*
		Returns if the client is acting as the server (aka: listen server) */

void(vector origin, vector forward, vector right, vector up, optional float reverbtype) SetListener = #351; /*
		Sets the position of the view, as far as the audio subsystem is concerned. This should be called once per CSQC_UpdateView as it will otherwise revert to default. For reverbtype, see setup_reverb or treat as 'underwater'. */

typedef struct {
	float flDensity;
	float flDiffusion;
	float flGain;
	float flGainHF;
	float flGainLF;
	float flDecayTime;
	float flDecayHFRatio;
	float flDecayLFRatio;
	float flReflectionsGain;
	float flReflectionsDelay;
	vector flReflectionsPan;
	float flLateReverbGain;
	float flLateReverbDelay;
	vector flLateReverbPan;
	float flEchoTime;
	float flEchoDepth;
	float flModulationTime;
	float flModulationDepth;
	float flAirAbsorptionGainHF;
	float flHFReference;
	float flLFReference;
	float flRoomRolloffFactor;
	int   iDecayHFLimit;
} reverbinfo_t;
void(float reverbslot, reverbinfo_t *reverbinfo, int sizeofreverinfo_t) setup_reverb = #0:setup_reverb; /* Part of FTE_CSQC_REVERB
		Reconfigures a reverb slot for weird effects. Slot 0 is reserved for no effects. Slot 1 is reserved for underwater effects. Reserved slots will be reinitialised on snd_restart, but can otherwise be changed. These reverb slots can be activated with SetListener. Note that reverb will currently only work when using OpenAL. */

void(string cmdname) registercommand = #352; /*
		Register the given console command, for easy console use.
		Console commands that are later used will invoke CSQC_ConsoleCommand. */

float(entity ent) wasfreed = #353; /*
		Quickly check to see if the entity is currently free. This function is only valid during the two-second non-reuse window, after that it may give bad results. Try one second to make it more robust. */

string(string key) serverkey = #354; /*
		Look up a key in the server's public serverinfo string */

float(string key, optional float assumevalue) serverkeyfloat = #0:serverkeyfloat; /*
		Version of serverkey that returns the value as a float (which avoids tempstrings). */

string(optional string resetstring) getentitytoken = #355; /*
		Grab the next token in the map's entity lump.
		If resetstring is not specified, the next token will be returned with no other sideeffects.
		If empty, will reset from the map before returning the first token, probably {.
		If not empty, will tokenize from that string instead.
		Always returns tempstrings. */

float(string s) findfont = #356; /* Part of DP_GFX_FONTS
		Looks up a named font slot. Matches the actual font name as a last resort. */

float(string fontname, string fontmaps, string sizes, float slot, optional float fix_scale, optional float fix_voffset) loadfont = #357; /* Part of DP_GFX_FONTS
		too convoluted for me to even try to explain correct usage. Try drawfont = loadfont("", "cour", "16", -1, 0, 0); to switch to the courier font (optimised for 16 virtual pixels high), if you have the freetype2 library in windows.. */

void(string evname, string evargs, ...) sendevent = #359; /*
		Invoke CSEv_evname_evargs in ssqc. evargs must be a string of initials refering to the types of the arguments to pass. v=vector, e=entity(.entnum field is sent), f=float, i=int. 6 arguments max - you can get more if you pack your floats into vectors. */

float() readbyte = #360;
float() readchar = #361;
float() readshort = #362;
float() readlong = #363;
float() readcoord = #364;
float() readangle = #365;
string() readstring = #366;
float() readfloat = #367;
float() readentitynum = #368;
float(string modelname, float(float isnew) updatecallback, float flags) deltalisten = #371; /*
		Specifies a per-modelindex callback to listen for engine-networking entity updates. Such entities are automatically interpolated by the engine (unless flags specifies not to).
		The various standard entity fields will be overwritten each frame before the updatecallback function is called. */

float(vector org, float radius, vector rgb) dynamiclight_spawnstatic = #0:dynamiclight_spawnstatic; /*
		Creates a static persistent light at the given position with the specified colour. Additional properties must be set via dynamiclight_set. */

__variant(float lno, float fld) dynamiclight_get = #372; /*
		Retrieves a property from the given dynamic/rt light. Return type depends upon the light field requested. */

void(float lno, float fld, __variant value) dynamiclight_set = #373; /*
		Changes a property on the given dynamic/rt light. Value type depends upon the light field to be changed. */

string(float efnum, float body) particleeffectquery = #374; /*
		Retrieves either the name or the body of the effect with the given number. The effect body is regenerated from internal state, and can be changed before being reapplied via the localcmd builtin. */

void(string shadername, vector origin, vector up, vector side, vector rgb, float alpha) adddecal = #375; /*
		Adds a temporary clipped decal shader to the scene, centered at the given point with given orientation. Will be drawn by the next renderscene call, and freed by the next clearscene call. */

void(entity e, string skinfilename, optional string skindata) setcustomskin = #376; /* Part of FTE_QC_CUSTOMSKINS
		Sets an entity's skin overrides to a new skin object. Releases the entities old skin (refcounted). */

float(string skinfilename, optional string skindata) loadcustomskin = #377; /*
		Creates a new skin object and returns it. These are custom per-entity surface->shader lookups. The skinfilename/data should be in .skin format:
		surfacename,shadername - makes the named surface use the named shader
		replace "surfacename" "shadername" - same.
		qwskin "foo" - use an unmodified quakeworld player skin (including crop+repalette rules)
		q1lower 0xff0000 - specify an override for the entity's lower colour, in this case to red
		q1upper 0x0000ff - specify an override for the entity's lower colour, in this case to blue
		compose "surfacename" "shader" "imagename@x,y:w,h$s,t,s2,t2?r,g,b,a" - compose a skin texture from multiple images.
		  The texture is determined to be sufficient to hold the first named image, additional images can be named as extra tokens on the same line.
		  Use a + at the end of the line to continue reading image tokens from the next line also, the named shader must use 'map $diffuse' to read the composed texture (compatible with the defaultskin shader). Must be matched with a releasecustomskin call later, and is pointless without applycustomskin. */

void(entity e, float skinobj) applycustomskin = #378; /*
		Updates the entity's custom skin (refcounted). */

void(float skinobj) releasecustomskin = #379; /*
		Lets the engine know that the skin will no longer be needed. Thanks to refcounting any ents with the skin already applied will retain their skin until later changed. It is valid to destroy a skin just after applying it to an ent in the same function that it was created in, as the skin will only be destroyed once its refcount rops to 0. */

__variant*(int size) memalloc = #384; /* Part of FTE_MEMALLOC
		Allocate an arbitary block of memory */

void(__variant *ptr) memfree = #385; /* Part of FTE_MEMALLOC
		Frees a block of memory that was allocated with memfree */

void(__variant *dst, __variant *src, int size) memcpy = #386; /* Part of FTE_MEMALLOC
		Copys memory from one location to another */

void(__variant *dst, int val, int size) memfill8 = #387; /* Part of FTE_MEMALLOC
		Sets an entire block of memory to a specified value. Pretty much always 0. */

__variant(__variant *dst, float ofs) memgetval = #388; /*
		Looks up the 32bit value stored at a pointer-with-offset. */

void(__variant *dst, float ofs, __variant val) memsetval = #389; /*
		Changes the 32bit value stored at the specified pointer-with-offset. */

__variant*(__variant *base, float ofs) memptradd = #390; /*
		Perform some pointer maths. Woo. */

float(string s) memstrsize = #0:memstrsize; /*
		strlen, except ignores utf-8 */

string(string conname, string field, optional string newvalue) con_getset = #391; /* Part of FTE_CSQC_ALTCONSOLES
		Reads or sets a property from a console object. The old value is returned. Iterrate through consoles with the 'next' field. Valid properties: 	title, name, next, unseen, markup, forceutf8, close, clear, hidden, linecount */

void(string conname, string messagefmt, ...) con_printf = #392; /* Part of FTE_CSQC_ALTCONSOLES
		Prints onto a named console. */

void(string conname, vector pos, vector size, float fontsize) con_draw = #393; /* Part of FTE_CSQC_ALTCONSOLES
		Draws the named console. */

float(string conname, float inevtype, float parama, float paramb, float paramc) con_input = #394; /* Part of FTE_CSQC_ALTCONSOLES
		Forwards input events to the named console. Mouse updates should be absolute only. */

void(string newcaption) setwindowcaption = #0:setwindowcaption; /* Part of FTE_CSQC_WINDOWCAPTION
		Replaces the title of the game window, as seen when task switching or just running in windowed mode. */

float() cvars_haveunsaved = #0:cvars_haveunsaved; /*
		Returns true if any archived cvar has an unsaved value. */

float(entity e, float nowreadonly) entityprotection = #0:entityprotection; /*
		Changes the protection on the specified entity to protect it from further edits from QC. The return value is the previous setting. Note that this can be used to unprotect the world, but doing so long term is not advised as you will no longer be able to detect invalid entity references. Also, world is not networked, so results might not be seen by clients (or in other words, world.avelocity_y=64 is a bad idea). */

entity(entity from, optional entity to) copyentity = #400; /* Part of DP_QC_COPYENTITY
		Copies all fields from one entity to another. */

entity(.string field, string match, optional .entity chainfield) findchain = #402; /* Part of DP_QC_FINDCHAIN*/
entity(.float fld, float match, optional .entity chainfield) findchainfloat = #403; /* Part of DP_QC_FINDCHAINFLOAT*/
void(vector org, string modelname, float startframe, float endframe, float framerate) effect = #404; /* Part of DP_SV_EFFECT
		Spawns a self-animating sprite */

void(vector org, vector dir, float count) te_blood = #405; /* Part of DP_TE_BLOOD*/
void(vector mincorner, vector maxcorner, float explosionspeed, float howmany) te_bloodshower = #406; /* Part of _DP_TE_BLOODSHOWER*/
void(vector org, vector color) te_explosionrgb = #407; /* Part of DP_TE_EXPLOSIONRGB*/
void(vector mincorner, vector maxcorner, vector vel, float howmany, float color, float gravityflag, float randomveljitter) te_particlecube = #408; /* Part of DP_TE_PARTICLECUBE*/
void(vector mincorner, vector maxcorner, vector vel, float howmany, float color) te_particlerain = #409; /* Part of DP_TE_PARTICLERAIN*/
void(vector mincorner, vector maxcorner, vector vel, float howmany, float color) te_particlesnow = #410; /* Part of DP_TE_PARTICLESNOW*/
void(vector org, vector vel, float howmany) te_spark = #411; /* Part of DP_TE_SPARK*/
void(vector org) te_gunshotquad = #412; /* Part of _DP_TE_QUADEFFECTS1*/
void(vector org) te_spikequad = #413; /* Part of _DP_TE_QUADEFFECTS1*/
void(vector org) te_superspikequad = #414; /* Part of _DP_TE_QUADEFFECTS1*/
void(vector org) te_explosionquad = #415; /* Part of _DP_TE_QUADEFFECTS1*/
void(vector org) te_smallflash = #416; /* Part of DP_TE_SMALLFLASH*/
void(vector org, float radius, float lifetime, vector color) te_customflash = #417; /* Part of DP_TE_CUSTOMFLASH*/
void(vector org, optional float count) te_gunshot = #418; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_spike = #419; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_superspike = #420; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_explosion = #421; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_tarexplosion = #422; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_wizspike = #423; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_knightspike = #424; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_lavasplash = #425; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_teleport = #426; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org, float color, float colorlength) te_explosion2 = #427; /* Part of DP_TE_STANDARDEFFECTBUILTINS*/
void(entity own, vector start, vector end) te_lightning1 = #428; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(entity own, vector start, vector end) te_lightning2 = #429; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(entity own, vector start, vector end) te_lightning3 = #430; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(entity own, vector start, vector end) te_beam = #431; /* Part of DP_TE_STANDARDEFFECTBUILTINS*/
void(vector dir) vectorvectors = #432; /* Part of DP_QC_VECTORVECTORS*/
void(vector org) te_plasmaburn = #433; /* Part of _DP_TE_PLASMABURN*/
float(entity e, float s) getsurfacenumpoints = #434; /* Part of DP_QC_GETSURFACE*/
vector(entity e, float s, float n) getsurfacepoint = #435; /* Part of DP_QC_GETSURFACE*/
vector(entity e, float s) getsurfacenormal = #436; /* Part of DP_QC_GETSURFACE*/
string(entity e, float s) getsurfacetexture = #437; /* Part of DP_QC_GETSURFACE*/
float(entity e, vector p) getsurfacenearpoint = #438; /* Part of DP_QC_GETSURFACE*/
vector(entity e, float s, vector p) getsurfaceclippedpoint = #439; /* Part of DP_QC_GETSURFACE*/
float(string s) tokenize = #441; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND*/
string(float n) argv = #442; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND*/
void(entity e, entity tagentity, string tagname) setattachment = #443; /* Part of DP_GFX_QUAKE3MODELTAGS*/
searchhandle(string pattern, float caseinsensitive, float quiet) search_begin = #444; /* Part of DP_QC_FS_SEARCH
		initiate a filesystem scan based upon filenames. Be sure to call search_end on the returned handle. */

void(searchhandle handle) search_end = #445; /* Part of DP_QC_FS_SEARCH*/
float(searchhandle handle) search_getsize = #446; /* Part of DP_QC_FS_SEARCH
		Retrieves the number of files that were found. */

string(searchhandle handle, float num) search_getfilename = #447; /* Part of DP_QC_FS_SEARCH
		Retrieves name of one of the files that was found by the initial search. */

float(searchhandle handle, float num) search_getfilesize = #0:search_getfilesize; /* Part of FTE_QC_FS_SEARCH_SIZEMTIME
		Retrieves the size of one of the files that was found by the initial search. */

string(searchhandle handle, float num) search_getfilemtime = #0:search_getfilemtime; /* Part of FTE_QC_FS_SEARCH_SIZEMTIME
		Retrieves modification time of one of the files. */

string(string cvarname) cvar_string = #448; /* Part of DP_QC_CVAR_STRING*/
entity(entity start, .float fld, float match) findflags = #449; /* Part of DP_QC_FINDFLAGS*/
entity(.float fld, float match, optional .entity chainfield) findchainflags = #450; /* Part of DP_QC_FINDCHAINFLAGS*/
float(entity ent, string tagname) gettagindex = #451; /* Part of DP_MD3_TAGSINFO*/
vector(entity ent, float tagindex) gettaginfo = #452; /* Part of DP_MD3_TAGSINFO
		Obtains the current worldspace position+orientation of the bone or tag from the given entity. The return value is the world coord, v_forward, v_right, v_up are also set according to the bone/tag's orientation. */

void(vector org, vector vel, float howmany) te_flamejet = #457; /* Part of _DP_TE_FLAMEJET*/
entity(float entnum) edict_num = #459; /* Part of DP_QC_EDICT_NUM*/
strbuf() buf_create = #460; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle) buf_del = #461; /* Part of DP_QC_STRINGBUFFERS*/
float(strbuf bufhandle) buf_getsize = #462; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle_from, strbuf bufhandle_to) buf_copy = #463; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle, float sortprefixlen, float backward) buf_sort = #464; /* Part of DP_QC_STRINGBUFFERS*/
string(strbuf bufhandle, string glue) buf_implode = #465; /* Part of DP_QC_STRINGBUFFERS*/
string(strbuf bufhandle, float string_index) bufstr_get = #466; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle, float string_index, string str) bufstr_set = #467; /* Part of DP_QC_STRINGBUFFERS*/
float(strbuf bufhandle, string str, float ordered) bufstr_add = #468; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle, float string_index) bufstr_free = #469; /* Part of DP_QC_STRINGBUFFERS*/
float(float s) asin = #471; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float c) acos = #472; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float t) atan = #473; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float c, float s) atan2 = #474; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float a) tan = #475; /* Part of DP_QC_ASINACOSATANATAN2TAN
		Forgive me father, for I have a sunbed and I'm not afraid to use it. */

float(string s) strlennocol = #476; /* Part of DP_QC_STRINGCOLORFUNCTIONS
		Returns the number of characters in the string after any colour codes or other markup has been parsed. */

string(string s) strdecolorize = #477; /* Part of DP_QC_STRINGCOLORFUNCTIONS
		Flattens any markup/colours, removing them from the string. */

string(float uselocaltime, string format, ...) strftime = #478; /* Part of DP_QC_STRFTIME*/
float(string s, string separator1, ...) tokenizebyseparator = #479; /* Part of DP_QC_TOKENIZEBYSEPARATOR*/
string(string s) strtolower = #480; /* Part of DP_QC_STRING_CASE_FUNCTIONS*/
string(string s) strtoupper = #481; /* Part of DP_QC_STRING_CASE_FUNCTIONS*/
string(string s) cvar_defstring = #482; /* Part of DP_QC_CVAR_DEFSTRING*/
void(vector origin, string sample, float volume, float attenuation) pointsound = #483; /* Part of DP_SV_POINTSOUND*/
string(string search, string replace, string subject) strreplace = #484; /* Part of DP_QC_STRREPLACE*/
string(string search, string replace, string subject) strireplace = #485; /* Part of DP_QC_STRREPLACE*/
vector(entity e, float s, float n, float a) getsurfacepointattribute = #486; /* Part of DP_QC_GETSURFACEPOINTATTRIBUTE*/
float(string name, optional string initialURI) gecko_create = #487; /* Part of DP_GECKO_SUPPORT
		Create a new 'browser tab' shader with the specified name that can then be drawn via drawpic (shader should not already exist - including from map/model textures or disk). In order to function correctly, this builtin depends upon external plugins being available. Use gecko_navigate to navigate it to a page of your choosing. */

void(string name) gecko_destroy = #488; /* Part of DP_GECKO_SUPPORT
		Destroy a shader. */

void(string name, string URI) gecko_navigate = #489; /* Part of DP_GECKO_SUPPORT
		Sends a command to the media decoder attached to the specified shader. In the case of a browser decoder, this changes the url that the browser displays. 'cmd:[un]focus' will tell the decoder that it has focus. */

float(string name, float key, float eventtype, optional float charcode) gecko_keyevent = #490; /* Part of DP_GECKO_SUPPORT
		Send a key event to a media decoder. This applies only to interactive decoders like browsers. */

void(string name, float x, float y) gecko_mousemove = #491; /* Part of DP_GECKO_SUPPORT
		Sets a media decoder shader's mouse position. Values should be 0-1. */

void(string name, float w, float h) gecko_resize = #492; /* Part of DP_GECKO_SUPPORT
		Request to resize a media decoder. */

vector(string name) gecko_get_texture_extent = #493; /* Part of DP_GECKO_SUPPORT
		Retrieves a media decoder current image pixel sizes. */

string(string shadname, string propname) gecko_getproperty = #0:gecko_getproperty; /*
		Queries the media decoder (especially browser ones) for decoder-specific properties. The cef plugin recognises url, title, status. */

float(string file, string id) cin_open = #0:cin_open;
void(string id) cin_close = #0:cin_close;
void(string id, float newstate) cin_setstate = #0:cin_setstate;
float(string id) cin_getstate = #0:cin_getstate;
void(string file) cin_restart = #0:cin_restart;
float(float caseinsensitive, string s, ...) crc16 = #494; /* Part of DP_QC_CRC16*/
float(string name) cvar_type = #495; /* Part of DP_QC_CVAR_TYPE*/
float() numentityfields = #496; /* Part of DP_QC_ENTITYDATA
		Gives the number of named entity fields. Note that this is not the size of an entity, but rather just the number of unique names (ie: vectors use 4 names rather than 3). */

float(string fieldname) findentityfield = #0:findentityfield; /*
		Find a field index by name. */

typedef .__variant field_t;
field_t(float fieldnum) entityfieldref = #0:entityfieldref; /*
		Returns a field value that can be directly used to read entity fields. Be sure to validate the type with entityfieldtype before using. */

string(float fieldnum) entityfieldname = #497; /* Part of DP_QC_ENTITYDATA
		Retrieves the name of the given entity field. */

float(float fieldnum) entityfieldtype = #498; /* Part of DP_QC_ENTITYDATA
		Provides information about the type of the field specified by the field num. Returns one of the EV_ values. */

string(float fieldnum, entity ent) getentityfieldstring = #499; /* Part of DP_QC_ENTITYDATA*/
float(float fieldnum, entity ent, string s) putentityfieldstring = #500; /* Part of DP_QC_ENTITYDATA*/
string() ReadPicture = #501; /*
		Reads a picture that was written by ReadPicture, and returns a name that can be used in drawpic and other 2d drawing functions. In FTE, this acts as a readstring-with-downloadcheck - the image will appear normally once it has been downloaded, but its size may be incorrect until then. */

void(float effectindex, entity own, vector org_from, vector org_to, vector dir_from, vector dir_to, float countmultiplier, optional float flags) boxparticles = #502;
string(string filename, optional float makereferenced) whichpack = #503; /* Part of DP_QC_WHICHPACK
		Returns the pak file name that contains the file specified. progs/player.mdl will generally return something like 'pak0.pak'. If makereferenced is true, clients will automatically be told that the returned package should be pre-downloaded and used, even if allow_download_refpackages is not set. */

__variant(float entnum, float fieldnum) getentity = #504; /*
		Looks up fields from non-csqc-visible entities. The entity will need to be within the player's pvs. fieldnum should be one of the GE_ constants. */

string(string in) uri_escape = #510; /* Part of DP_QC_URI_ESCAPE*/
string(string in) uri_unescape = #511; /* Part of DP_QC_URI_ESCAPE*/
float(entity ent) num_for_edict = #512;
#define uri_post uri_get
float(string uril, float id, optional string postmimetype, optional string postdata) uri_get = #513; /* Part of DP_QC_URI_GET, DP_QC_URI_POST
		uri_get() gets content from an URL and calls a callback "uri_get_callback" with it set as string; an unique ID of the transfer is returned
		returns 1 on success, and then calls the callback with the ID, 0 or the HTTP status code, and the received data in a string
		For a POST request, you will typically want the postmimetype set to application/x-www-form-urlencoded.
		For a GET request, omit the mime+data entirely.
		Consult your webserver/php/etc documentation for best-practise. */

float(string str) tokenize_console = #514; /*
		Tokenize a string exactly as the console's tokenizer would do so. The regular tokenize builtin became bastardized for convienient string parsing, which resulted in a large disparity that can be exploited to bypass checks implemented in a naive SV_ParseClientCommand function, therefore you can use this builtin to make sure it exactly matches. */

float(float idx) argv_start_index = #515; /*
		Returns the character index that the tokenized arg started at. */

float(float idx) argv_end_index = #516; /*
		Returns the character index that the tokenized arg stopped at. */

void(strbuf strbuf, string pattern, string antipattern) buf_cvarlist = #517;
string(string cvarname) cvar_description = #518; /*
		Retrieves the description of a cvar, which might be useful for tooltips or help files. This may still not be useful. */

float(optional float timetype) gettime = #519;
string(float keynum) keynumtostring_omgwtf = #520;
string(string command, optional float bindmap) findkeysforcommand = #521; /*
		Returns a list of keycodes that perform the given console command in a format that can only be parsed via tokenize (NOT tokenize_console). This only and always returns two values - if only one key is actually bound, -1 will be returned. The bindmap argument is listed for compatibility with dp-specific defs, but is ignored in FTE. */

string(string command, optional float bindmap) findkeysforcommandex = #0:findkeysforcommandex; /*
		Returns a list of key bindings in keyname format instead of keynums. Use tokenize to parse. This list may contain modifiers. May return large numbers of keys. */

void(string s) loadfromdata = #529; /*
		Reads a set of entities from the given string. This string should have the same format as a .ent file or a saved game. Entities will be spawned as required. If you need to see the entities that were created, you should use parseentitydata instead. */

void(string s) loadfromfile = #530; /*
		Reads a set of entities from the named file. This file should have the same format as a .ent file or a saved game. Entities will be spawned as required. If you need to see the entities that were created, you should use parseentitydata instead. */

float(float v, optional float base) log = #532; /* Part of ??MVDSV_BUILTINS
		Determines the logarithm of the input value according to the specified base. This can be used to calculate how much something was shifted by. */

float(entity e, float channel, string newsample, float volume, float attenuation, float pitchpct, float flags, float timeoffset) soundupdate = #0:soundupdate; /*
		Changes the properties of the current sound being played on the given entity channel. newsample may be empty, and will be ignored in this case. timeoffset is relative to the current position (subtract the result of getsoundtime for absolute positions). Negative volume can be used to stop the sound. Return value is a fractional value based upon the number of audio devices that could be updated - test against TRUE rather than non-zero. */

float(entity e, float channel) getsoundtime = #533; /*
		Returns the current playback time of the sample on the given entity's channel. Beware CHAN_AUTO (in csqc, channels are not limited by network protocol). */

float(string sample) soundlength = #534; /*
		Provides a way to query the duration of a sound sample, allowing you to set up a timer to chain samples. */

float(string filename, strbuf bufhandle) buf_loadfile = #535; /*
		Appends the named file into a string buffer (which must have been created in advance). The return value merely says whether the file was readable. */

float(filestream filehandle, strbuf bufhandle, optional float startpos, optional float numstrings) buf_writefile = #536; /*
		Writes the contents of a string buffer onto the end of the supplied filehandle (you must have already used fopen). Additional optional arguments permit you to constrain the writes to a subsection of the stringbuffer. */

void(entity e, float physics_enabled) physics_enable = #540; /*
		Enable or disable the physics attached to a MOVETYPE_PHYSICS entity. Entities which have been disabled in this way will stop taking so much cpu time. */

void(entity e, vector force, vector relative_ofs) physics_addforce = #541; /*
		Apply some impulse directional force upon a MOVETYPE_PHYSICS entity. */

void(entity e, vector torque) physics_addtorque = #542; /*
		Apply some impulse rotational force upon a MOVETYPE_PHYSICS entity. */

void(float trg) setmousetarget = #603;
float() getmousetarget = #604;
void(.../*, string funcname*/) callfunction = #605; /*
		Invokes the named function. The function name is always passed as the last parameter and must always be present. The others are passed to the named function as-is */

void(filestream fh, entity e) writetofile = #606; /*
		Writes an entity's fields to the named frik_file file handle. */

float(string s) isfunction = #607; /*
		Returns true if the named function exists and can be called with the callfunction builtin. */

vector(float vidmode, optional float forfullscreen) getresolution = #608; /*
		Supposed to query the driver for supported video modes. FTE does not query drivers in this way, nor would it trust drivers anyway. */

string(float keynum) keynumtostring_menu = #609;
float(float type) gethostcachevalue = #611; /* Part of FTE_CSQC_SERVERBROWSER*/
string(float type, float hostnr) gethostcachestring = #612; /* Part of FTE_CSQC_SERVERBROWSER*/
float(entity e, string s, optional float offset) parseentitydata = #613; /*
		Reads a single entity's fields into an already-spawned entity. s should contain field pairs like in a saved game: {"foo1" "bar" "foo2" "5"}. Returns <=0 on failure, otherwise returns the offset in the string that was read to. */

string(entity e) generateentitydata = #0:generateentitydata; /*
		Dumps the entities fields into a string which can later be parsed with parseentitydata. */

float(string key) stringtokeynum_menu = #614;
void() resethostcachemasks = #615; /* Part of FTE_CSQC_SERVERBROWSER*/
void(float mask, float fld, string str, float op) sethostcachemaskstring = #616; /* Part of FTE_CSQC_SERVERBROWSER*/
void(float mask, float fld, float num, float op) sethostcachemasknumber = #617; /* Part of FTE_CSQC_SERVERBROWSER*/
void() resorthostcache = #618; /* Part of FTE_CSQC_SERVERBROWSER*/
void(float fld, float descending) sethostcachesort = #619; /* Part of FTE_CSQC_SERVERBROWSER*/
void(optional float dopurge) refreshhostcache = #620; /* Part of FTE_CSQC_SERVERBROWSER*/
float(float fld, float hostnr) gethostcachenumber = #621; /* Part of FTE_CSQC_SERVERBROWSER*/
float(string key) gethostcacheindexforkey = #622; /* Part of FTE_CSQC_SERVERBROWSER*/
void(string key) addwantedhostcachekey = #623; /* Part of FTE_CSQC_SERVERBROWSER*/
string() getextresponse = #624; /* Part of FTE_CSQC_SERVERBROWSER*/
string(string dnsname, optional float defport) netaddress_resolve = #625;
string(string fmt, ...) sprintf = #627; /* Part of DP_QC_SPRINTF*/
float(entity e, float s) getsurfacenumtriangles = #628;
vector(entity e, float s, float n) getsurfacetriangle = #629;
vector() getbindmaps = #631;
float(vector bm) setbindmaps = #632;
string(string digest, string data, ...) digest_hex = #639;
#if defined(CSQC) || defined(MENU)
#define K_TAB	9
#define K_ENTER	13
#define K_ESCAPE	27
#define K_SPACE	32
#define K_BACKSPACE	127
#define K_UPARROW	128
#define K_DOWNARROW	129
#define K_LEFTARROW	130
#define K_RIGHTARROW	131
#define K_LALT	132
#define K_RALT	-245
#define K_LCTRL	133
#define K_RCTRL	-246
#define K_LSHIFT	134
#define K_RSHIFT	-247
#define K_F1	135
#define K_F2	136
#define K_F3	137
#define K_F4	138
#define K_F5	139
#define K_F6	140
#define K_F7	141
#define K_F8	142
#define K_F9	143
#define K_F10	144
#define K_F11	145
#define K_F12	146
#define K_INS	147
#define K_DEL	148
#define K_PGDN	149
#define K_PGUP	150
#define K_HOME	151
#define K_END	152
#define K_KP_HOME	164
#define K_KP_UPARROW	165
#define K_KP_PGUP	166
#define K_KP_LEFTARROW	161
#define K_KP_5	162
#define K_KP_RIGHTARROW	163
#define K_KP_END	158
#define K_KP_DOWNARROW	159
#define K_KP_PGDN	160
#define K_KP_ENTER	172
#define K_KP_INS	157
#define K_KP_DEL	167
#define K_KP_SLASH	168
#define K_KP_MINUS	170
#define K_KP_PLUS	171
#define K_KP_NUMLOCK	154
#define K_KP_STAR	169
#define K_KP_EQUALS	173
#define K_MOUSE1	512
#define K_MOUSE2	513
#define K_MOUSE3	514
#define K_MOUSE4	517
#define K_MOUSE5	518
#define K_MOUSE6	519
#define K_MOUSE7	520
#define K_MOUSE8	521
#define K_MOUSE9	522
#define K_MOUSE10	523
#define K_MWHEELUP	515
#define K_MWHEELDOWN	516
#define K_LWIN	-239
#define K_RWIN	-240
#define K_APP	-241
#define K_SEARCH	-242
#define K_POWER	-130
#define K_VOLUP	-243
#define K_VOLDOWN	-244
#define K_JOY1	768
#define K_JOY2	769
#define K_JOY3	770
#define K_JOY4	771
#define K_AUX1	784
#define K_AUX2	785
#define K_AUX3	786
#define K_AUX4	787
#define K_AUX5	788
#define K_AUX6	789
#define K_AUX7	790
#define K_AUX8	791
#define K_AUX9	792
#define K_AUX10	793
#define K_AUX11	794
#define K_AUX12	795
#define K_AUX13	796
#define K_AUX14	797
#define K_AUX15	798
#define K_AUX16	799
#define K_AUX17	800
#define K_AUX18	801
#define K_AUX19	802
#define K_AUX20	803
#define K_AUX21	804
#define K_AUX22	805
#define K_AUX23	806
#define K_AUX24	807
#define K_AUX25	808
#define K_AUX26	809
#define K_AUX27	810
#define K_AUX28	811
#define K_AUX29	812
#define K_AUX30	813
#define K_AUX31	814
#define K_AUX32	815
#define K_PAUSE	153
#define K_PRINTSCREEN	174
#define K_CAPSLOCK	155
#define K_SCROLLLOCK	156
#define K_SEMICOLON	59
#define K_PLUS	43
#define K_MINUS	45
#define K_TILDE	126
#define K_BACKQUOTE	96
#define K_BACKSLASH	92
#define K_GP_A	826
#define K_GP_B	827
#define K_GP_X	828
#define K_GP_Y	829
#define K_GP_LSHOULDER	824
#define K_GP_RSHOULDER	825
#define K_GP_LTRIGGER	830
#define K_GP_RTRIGGER	831
#define K_GP_BACK	821
#define K_GP_START	820
#define K_GP_LTHUMB	822
#define K_GP_RTHUMB	823
#define K_GP_DPAD_UP	816
#define K_GP_DPAD_DOWN	817
#define K_GP_DPAD_LEFT	818
#define K_GP_DPAD_RIGHT	819
#define K_GP_GUIDE	-202
#define K_GP_UNKNOWN	-255
#define K_GP_LTHUMB_UP	832
#define K_GP_LTHUMB_DOWN	833
#define K_GP_LTHUMB_LEFT	834
#define K_GP_LTHUMB_RIGHT	835
#define K_GP_RTHUMB_UP	836
#define K_GP_RTHUMB_DOWN	837
#define K_GP_RTHUMB_LEFT	838
#define K_GP_RTHUMB_RIGHT	839
#endif
#ifdef _ACCESSORS
accessor strbuf : float
{
	inline get float asfloat[float idx] = {return stof(bufstr_get(this, idx));};
	inline set float asfloat[float idx] = {bufstr_set(this, idx, ftos(value));};
	get string[float] = bufstr_get;
	set string[float] = bufstr_set;
	get float length = buf_getsize;
};
accessor searchhandle : float
{
	get string[float] = search_getfilename;
	get float length = search_getsize;
};
accessor hashtable : float
{
	inline get vector v[string key] = {return hash_get(this, key, '0 0 0', EV_VECTOR);};
	inline set vector v[string key] = {hash_add(this, key, value, HASH_REPLACE|EV_VECTOR);};
	inline get string s[string key] = {return hash_get(this, key, "", EV_STRING);};
	inline set string s[string key] = {hash_add(this, key, value, HASH_REPLACE|EV_STRING);};
	inline get float f[string key] = {return hash_get(this, key, 0.0, EV_FLOAT);};
	inline set float f[string key] = {hash_add(this, key, value, HASH_REPLACE|EV_FLOAT);};
	inline get __variant[string key] = {return hash_get(this, key, __NULL__);};
	inline set __variant[string key] = {hash_add(this, key, value, HASH_REPLACE);};
};
accessor infostring : string
{
	get string[string] = infoget;
	inline seti& string[string fld] = {this = infoadd(this, fld, value);};
};
accessor filestream : float
{
	get string = fgets;
	inline set string = {fputs(this,value);};
};
#endif
#pragma noref 0
// Empty

void() CSQC_Ent_Remove =
{
	remove(self);
};

void() CSQC_Shutdown =
{
};

noref void(float apiver, string enginename, float enginever) CSQC_Init =
{
	drawfont = loadfont("", "Courier Prime Code", "12,16,24,32,64,72,128,256,512", -1, 0, 0);
	precache_everything();
};

noref void() CSQC_WorldLoaded =
{
};

noref void(float isnew) CSQC_Ent_Update =
{
	// printf("csqc ent update %f\n", isnew);
};

// CALLED EVERY CLIENT RENDER FRAME
void(float width, float height, float menushown) CSQC_UpdateView =
{
	//clear and update our global screen resolution vars
	clearscene();
	g_width = width;
	g_height = height;
	

	//disable quake status bar and quake crosshair
	setproperty(VF_DRAWENGINESBAR, 0);	
	setproperty(VF_DRAWCROSSHAIR, 0);

	campos = getproperty(VF_ORIGIN);
	camang = getproperty(VF_ANGLES);

	//autoadd entities received from servers for drawing	
	addentities(MASK_ENGINE);
	
	//does what you think it does
	renderscene();
	
	/*sui_pre_draw(g_width, g_height);
	
	test_sui_system();
	
	sui_draw();*/
};

float(string cmd) CSQC_ConsoleCommand =
{
	tokenize(cmd);
	switch(argv(0))
	{
		default:
			return FALSE;
	}
	return TRUE;
};

float(float evtype, float scanx, float chary, float devid) CSQC_InputEvent =
{
	// sui_input_event(evtype, scanx, chary, devid);
	switch(evtype)
	{
	case IE_KEYDOWN:
		return FALSE;
	case IE_KEYUP:
		return FALSE;
	case IE_MOUSEDELTA:
		return FALSE;
	case IE_MOUSEABS:
		cursor_pos_x = scanx;
		cursor_pos_y = chary;
		return FALSE;
	}
	return FALSE;
};


void() CSQC_Parse_Event =
{
	float first = readbyte();
	switch(first) {
		default:
			printf("No action for byte %f\n", first);
			break;
	}
};


float(string key, string val) find_player_id =
{
	for (int currentindex = 0; currentindex < maxclients; currentindex++)
	{
		if (getplayerkeyvalue(currentindex, key) == val) return currentindex;
	}
	return -1;
}

void(string printmsg, float printlvl) CSQC_Parse_Print =
{
	print(printmsg);
};




void() CSQC_Input_Frame =
{
	input_movevalues_x = bound(-350, input_movevalues_x, 350);
	input_movevalues_y = bound(-350, input_movevalues_y, 350);
	input_movevalues_z = bound(-350, input_movevalues_z, 350);
};


/*
This file was automatically generated by FTE Quake v1.06
This file can be regenerated by issuing the following command:
pr_dumpplatform -Ffte -Tmenu -O menudefs
Available options:
-Ffte       - target only FTE (optimations and additional extensions)
-Tnq        - dump specifically NQ fields
-Tqw        - dump specifically QW fields
-Tcs        - dump specifically CSQC fields
-Tmenu      - dump specifically menuqc fields
-Fdefines   - generate #defines instead of constants
-Faccessors - use accessors instead of basic types via defines
-O          - write to a different qc file
*/
#pragma noref 1
//#pragma flag enable logicops
#pragma warning error Q101 /*too many parms*/
#pragma warning error Q105 /*too few parms*/
#pragma warning error Q106 /*assignment to constant/lvalue*/
#pragma warning error Q208 /*system crc unknown*/
#pragma warning disable F211 /*system crc outdated (eg: dp's csqc)*/
#pragma warning enable F301 /*non-utf-8 strings*/
#pragma warning enable F302 /*uninitialised locals*/
#pragma target FTE
#ifndef MENU
#define MENU
#endif
#define FTE_PEXT_SETVIEW /* NQ's svc_setview works correctly even in quakeworld */
#define DP_ENT_SCALE
#define FTE_PEXT_LIGHTSTYLECOL
#define DP_ENT_ALPHA
#define FTE_PEXT_VIEW2
#define FTE_PEXT_ACURATETIMINGS
#define FTE_PEXT_SOUNDDBL
#define FTE_PEXT_FATNESS
#define DP_HALFLIFE_MAP
#define FTE_PEXT_TE_BULLET
#define FTE_PEXT_HULLSIZE
#define FTE_PEXT_MODELDBL
#define FTE_PEXT_ENTITYDBL
#define FTE_PEXT_ENTITYDBL2
#define FTE_PEXT_FLOATCOORDS
#define FTE_PEXT_VWEAP
#define FTE_PEXT_Q2BSP
#define FTE_PEXT_Q3BSP
#define DP_ENT_COLORMOD
#define FTE_HEXEN2
#define FTE_PEXT_SPAWNSTATIC
#define FTE_PEXT_CUSTOMTENTS
#define FTE_PEXT_256PACKETENTITIES
#define TEI_SHOWLMP2
#define DP_GFX_QUAKE3MODELTAGS
#define FTE_PK3DOWNLOADS
#define PEXT_CHUNKEDDOWNLOADS
#define EXT_CSQC_SHARED
#define PEXT_DPFLAGS
#define EXT_CSQC
#define BX_COLOREDTEXT
#define DP_CON_SET /* The 'set' console command exists, and can be used to create/set cvars. */
#define DP_CON_SETA /* The 'seta' console command exists, like the 'set' command, but also marks the cvar for archiving, allowing it to be written into the user's config. Use this command in your default.cfg file. */
#define DP_EF_ADDITIVE
#define DP_EF_BLUE
#define DP_EF_FULLBRIGHT
#define DP_EF_NODEPTHTEST
#define DP_EF_NODRAW
#define DP_EF_NOGUNBOB
#define DP_EF_NOSHADOW
#define DP_EF_RED
#define DP_ENT_CUSTOMCOLORMAP
#define DP_ENT_EXTERIORMODELTOCLIENT
#define DP_ENT_TRAILEFFECTNUM /* self.traileffectnum=particleeffectnum("myeffectname"); can be used to attach a particle trail to the given server entity. This is equivelent to calling trailparticles each frame. */
#define DP_ENT_VIEWMODEL
#define DP_GECKO_SUPPORT
#define DP_GFX_FONTS
#define DP_GFX_SKINFILES
#define DP_GFX_SKYBOX
#define DP_HALFLIFE_MAP_CVAR
#define DP_INPUTBUTTONS
#define DP_LIGHTSTYLE_STATICVALUE
#define DP_LITSUPPORT
#define DP_MONSTERWALK /* MOVETYPE_WALK is valid on non-player entities. Note that only players receive acceleration etc in line with none/bounce/fly/noclip movetypes on the player, thus you will have to provide your own accelerations (incluing gravity) yourself. */
#define DP_MOVETYPEBOUNCEMISSILE
#define DP_MOVETYPEFOLLOW
#define DP_QC_ASINACOSATANATAN2TAN
#define DP_QC_CHANGEPITCH
#define DP_QC_COPYENTITY
#define DP_QC_CRC16
#define DP_QC_CVAR_DEFSTRING
#define DP_QC_CVAR_STRING
#define DP_QC_CVAR_TYPE
#define DP_QC_EDICT_NUM
#define DP_QC_ENTITYDATA
#define DP_QC_ETOS
#define DP_QC_FINDCHAIN
#define DP_QC_FINDCHAINFLOAT
#define DP_QC_FINDFLAGS
#define DP_QC_FINDCHAINFLAGS
#define DP_QC_FINDFLOAT
#define DP_QC_FS_SEARCH
#define DP_QC_GETSURFACE
#define DP_QC_GETSURFACEPOINTATTRIBUTE
#define DP_QC_GETTAGINFO
#define DP_QC_MINMAXBOUND
#define DP_QC_MULTIPLETEMPSTRINGS /* Superseded by DP_QC_UNLIMITEDTEMPSTRINGS. Functions that return a temporary string will not overwrite/destroy previous temporary strings until at least 16 strings are returned (or control returns to the engine). */
#define DP_QC_RANDOMVEC
#define DP_QC_RENDER_SCENE /* clearscene+addentity+setviewprop+renderscene+setmodel are available to menuqc. WARNING: DP advertises this extension without actually supporting it, FTE does actually support it. */
#define DP_QC_SINCOSSQRTPOW
#define DP_QC_SPRINTF /* Provides the sprintf builtin, which allows for rich formatting along the lines of C's function with the same name. Not to be confused with QC's sprint builtin. */
#define DP_QC_STRFTIME
#define DP_QC_STRING_CASE_FUNCTIONS
#define DP_QC_STRINGBUFFERS
#define DP_QC_STRINGCOLORFUNCTIONS
#define DP_QC_STRREPLACE
#define DP_QC_TOKENIZEBYSEPARATOR
#define DP_QC_TRACEBOX
#define DP_QC_TRACETOSS
#define DP_QC_TRACE_MOVETYPE_HITMODEL
#define DP_QC_TRACE_MOVETYPE_WORLDONLY
#define DP_QC_TRACE_MOVETYPES
#define DP_QC_UNLIMITEDTEMPSTRINGS /* Supersedes DP_QC_MULTIPLETEMPSTRINGS, superseded by FTE_QC_PERSISTENTTEMPSTRINGS. Specifies that all temp strings will be valid at least until the QCVM returns. */
#define DP_QC_URI_ESCAPE
#define DP_QC_URI_GET
#define DP_QC_URI_POST
#define DP_QC_VECTOANGLES_WITH_ROLL
#define DP_QC_VECTORVECTORS
#define DP_QC_WHICHPACK
#define DP_QUAKE2_MODEL
#define DP_QUAKE2_SPRITE
#define DP_QUAKE3_MODEL
#define DP_REGISTERCVAR
#define DP_SND_SOUND7_WIP2
#define DP_SND_STEREOWAV
#define DP_SND_OGGVORBIS
#define DP_SOLIDCORPSE
#define DP_SPRITE32
#define DP_SV_BOTCLIENT
#define DP_SV_CLIENTCOLORS /* Provided only for compatibility with DP. */
#define DP_SV_CLIENTNAME /* Provided only for compatibility with DP. */
#define DP_SV_DRAWONLYTOCLIENT
#define DP_SV_DROPCLIENT /* Equivelent to quakeworld's stuffcmd(self,"disconnect\n"); hack */
#define DP_SV_EFFECT
#define DP_SV_EXTERIORMODELFORCLIENT
#define DP_SV_NODRAWTOCLIENT
#define DP_SV_PLAYERPHYSICS /* Allows reworking parts of NQ player physics. USE AT OWN RISK - this necessitates NQ physics and is thus guarenteed to break prediction. */
#define DP_SV_POINTSOUND
#define DP_SV_PRECACHEANYTIME /* Specifies that the various precache builtins can be called at any time. WARNING: precaches are sent reliably while sound events, modelindexes, and particle events are not. This can mean sounds and particles might not work the first time around, or models may take a while to appear (after the reliables are received and the model is loaded from disk). Always attempt to precache a little in advance in order to reduce these issues (preferably at the start of the map...) */
#define DP_SV_PRINT /* Says that the print builtin can be used from nqssqc (as well as just csqc), bypassing the developer cvar issues. */
#define DP_SV_SETCOLOR
#define DP_SV_SPAWNFUNC_PREFIX
#define DP_SV_WRITEPICTURE
#define DP_SV_WRITEUNTERMINATEDSTRING
#define DP_TE_BLOOD
#define DP_TE_CUSTOMFLASH
#define DP_TE_EXPLOSIONRGB
#define DP_TE_PARTICLECUBE
#define DP_TE_PARTICLERAIN
#define DP_TE_PARTICLESNOW
#define DP_TE_SMALLFLASH
#define DP_TE_SPARK
#define DP_TE_STANDARDEFFECTBUILTINS
#define DP_VIEWZOOM
#define EXT_BITSHIFT
#define EXT_DIMENSION_VISIBILITY
#define EXT_DIMENSION_PHYSICS
#define EXT_DIMENSION_GHOST
#define FRIK_FILE
#define FTE_CALLTIMEOFDAY /* Replication of mvdsv functionality (call calltimeofday to cause 'timeofday' to be called, with arguments that can be saved off to a global). Generally strftime is simpler to use. */
#define FTE_CSQC_ALTCONSOLES /* The engine tracks multiple consoles. These may or may not be directly visible to the user. */
#define FTE_CSQC_BASEFRAME /* Specifies that .basebone, .baseframe2, .baselerpfrac, baseframe1time, etc exist in csqc. These fields affect all bones in the entity's model with a lower index than the .basebone field, allowing you to give separate control to the legs of a skeletal model, without affecting the torso animations. */
#define FTE_CSQC_HALFLIFE_MODELS
#define FTE_CSQC_SERVERBROWSER /* Provides builtins to query the engine's serverbrowser servers list from ssqc. Note that these builtins are always available in menuqc. */
#define FTE_CSQC_SKELETONOBJECTS /* Provides container objects for skeletal bone data, which can be modified on a per bone basis if needed. This allows you to dynamically generate animations (or just blend them with greater customisation) instead of being limited to a single animation or two. */
#define FTE_CSQC_RAWIMAGES /* Provides raw rgba image access to csqc. With this, the csprogs can read textures into qc-accessible memory, modify it, and then upload it to the renderer. */
#define FTE_CSQC_RENDERTARGETS /* VF_RT_DESTCOLOUR exists and can be used to redirect any rendering to a texture instead of the screen. */
#define FTE_CSQC_REVERB /* Specifies that the mod can create custom reverb effects. Whether they will actually be used or not depends upon the sound driver. */
#define FTE_CSQC_WINDOWCAPTION /* Provides csqc with the ability to change the window caption as displayed when running windowed or in the task bar when switched out. */
#define FTE_ENT_SKIN_CONTENTS /* self.skin = CONTENTS_WATER; makes a brush entity into water. use -16 for a ladder. */
#define FTE_ENT_UNIQUESPAWNID
#define FTE_EXTENDEDTEXTCODES
#define FTE_FORCESHADER /* Allows csqc to override shaders on models with an explicitly named replacement. Also allows you to define shaders with a fallback if it does not exist on disk. */
#define FTE_FORCEINFOKEY /* Provides an easy way to change a user's userinfo from the server. */
#define FTE_GFX_QUAKE3SHADERS /* specifies that the engine has full support for vanilla quake3 shaders */
#define FTE_GFX_REMAPSHADER /* With the raw power of stuffcmds, the r_remapshader console command is exposed! This mystical command can be used to remap any shader to another. Remapped shaders that specify $diffuse etc in some form will inherit the textures implied by the surface. */
#define FTE_GFX_MODELEVENTS /* Provides a query for per-animation events in model files, including from progs/foo.mdl.events files. */
#define FTE_ISBACKBUFFERED /* Allows you to check if a client has too many reliable messages pending. */
#define FTE_MEMALLOC /* Allows dynamically allocating memory. Use pointers to access this memory. Memory will not be saved into saved games. */
#define FTE_MEDIA_AVI /* playfilm command supports avi files. */
#define FTE_MEDIA_CIN /* playfilm command supports q2 cin files. */
#define FTE_MEDIA_ROQ /* playfilm command supports q3 roq files. */
#define FTE_MULTIPROGS /* Multiple progs.dat files can be loaded inside the same qcvm. Insert new ones with addprogs inside the 'init' function, and use externvalue+externset to rewrite globals (and hook functions) to link them together. Note that the result is generally not very clean unless you carefully design for it beforehand. */
#define FTE_MULTITHREADED /* Faux multithreading, allowing multiple contexts to run in sequence. */
#define FTE_MVD_PLAYERSTATS /* In csqc, getplayerstat can be used to query any player's stats when playing back MVDs. isdemo will return 2 in this case. */
#define FTE_PART_SCRIPT /* Specifies that the r_particledesc cvar can be used to select a list of particle effects to load from particles/*.cfg, the format of which is documented elsewhere. */
#define FTE_PART_NAMESPACES /* Specifies that the engine can use foo.bar to load effect foo from particle description bar. When used via ssqc, this should cause the client to download whatever effects as needed. */
#define FTE_PART_NAMESPACE_EFFECTINFO /* Specifies that effectinfo.bar can load effects from effectinfo.txt for DP compatibility. */
#define FTE_QC_BASEFRAME /* Specifies that .basebone and .baseframe exist in ssqc. These fields affect all bones in the entity's model with a lower index than the .basebone field, allowing you to give separate control to the legs of a skeletal model, without affecting the torso animations, from ssqc. */
#define FTE_QC_FILE_BINARY /* Extends FRIK_FILE with binary read+write, as well as allowing seeking. Requires pointers. */
#define FTE_QC_CHANGELEVEL_HUB /* Adds an extra argument to changelevel which is carried over to the next map in the 'spawnspot' global. Maps will be saved+reloaded until the extra argument is omitted again, purging all saved maps. Saved games will contain a copy of each preserved map. parm1-parm64 globals can be used, giving more space to transfer more player data. */
#define FTE_QC_CHECKCOMMAND /* Provides a way to test if a console command exists, and whether its a command/alias/cvar. Does not say anything about the expected meanings of any arguments or values. */
#define FTE_QC_CHECKPVS
#define FTE_QC_CROSSPRODUCT
#define FTE_QC_CUSTOMSKINS /* The engine supports the use of q3 skins, as well as the use of such skin 'files' to specify rich top+bottom colours, qw skins, geomsets, or texture composition even on non-players.. */
#define FTE_QC_FS_SEARCH_SIZEMTIME
#define FTE_QC_HARDWARECURSORS /* setcursormode exists in both csqc+menuqc, and accepts additional arguments to specify a cursor image to use when this module has focus. If the image exceeds hardware limits (or hardware cursors are unsupported), it will be emulated using regular draws - this at least still avoids conflicting cursors as only one will ever be used, even if console+menu+csqc are all overlayed. */
#define FTE_QC_HASHTABLES /* Provides efficient string-based lookups. */
#define FTE_QC_INFOKEY /* QuakeWorld's infokey builtin works, and reports at least name+topcolor+bottomcolor+ping(in ms)+ip(unmasked, but not always ipv4)+team(aka bottomcolor in nq). Does not require actual localinfo/serverinfo/userinfo, but they're _highly_ recommended to any engines with csqc */
#define FTE_QC_INTCONV /* Provides string<>int conversions, including hex representations. */
#define FTE_QC_MATCHCLIENTNAME
#define FTE_QC_MULTICAST /* QuakeWorld's multicast builtin works along with MSG_MULTICAST, but also with unicast support. */
#define FTE_QC_PAUSED
#define FTE_QC_PERSISTENTTEMPSTRINGS /* Supersedes DP_QC_MULTIPLETEMPSTRINGS. Temp strings are garbage collected automatically, and do not expire while they're still in use. This makes strzone redundant. */
#define FTE_QC_RAGDOLL_WIP
#define FTE_QC_SENDPACKET /* Allows the use of out-of-band udp packets to/from other hosts. Includes the SV_ParseConnectionlessPacket event. */
#define FTE_QC_STUFFCMDFLAGS /* Variation on regular stuffcmd that gives control over how spectators/mvds should be treated. */
#define FTE_QC_TRACETRIGGER
#define FTE_QUAKE2_CLIENT /* This engine is able to act as a quake2 client */
#define FTE_QUAKE2_SERVER /* This engine is able to act as a quake2 server */
#define FTE_QUAKE3_CLIENT /* This engine is able to act as a quake3 client */
#define FTE_QUAKE3_SERVER /* This engine is able to act as a quake3 server */
#define FTE_SOLID_LADDER /* Allows a simple trigger to remove effects of gravity (solid 20). obsolete. will prolly be removed at some point as it is not networked properly. Use FTE_ENT_SKIN_CONTENTS */
#define FTE_SPLITSCREEN /* Client supports splitscreen, controlled via cl_splitscreen. Servers require allow_splitscreen 1 if splitscreen is to be used over the internet. Mods that use csqc will need to be aware for this to work properly. per-client networking may be problematic. */
#define FTE_SQL /* Provides sql* builtins which can be used for sql database access */
#define FTE_SQL_SQLITE /* SQL functionality is able to utilise sqlite databases */
#define FTE_STRINGS /* Extra builtins (and additional behaviour) to make string manipulation easier */
#define FTE_SV_POINTPARTICLES /* Specifies that particleeffectnum, pointparticles, and trailparticles exist in ssqc as well as csqc. particleeffectnum acts as a precache, allowing ssqc values to be networked up with csqc for use. Use in combination with FTE_PART_SCRIPT+FTE_PART_NAMESPACES to use custom effects. This extension is functionally identical to the DP version, but avoids any misplaced assumptions about the format of the client's particle descriptions. */
#define FTE_SV_REENTER
#define FTE_TE_STANDARDEFFECTBUILTINS /* Provides builtins to replace writebytes, with a QW compatible twist. */
#define FTE_TERRAIN_MAP /* This engine supports .hmp files, as well as terrain embedded within bsp files. */
#define FTE_RAW_MAP /* This engine supports directly loading .map files, as well as realtime editing of the various brushes. */
#define KRIMZON_SV_PARSECLIENTCOMMAND /* SSQC's SV_ParseClientCommand function is able to handle client 'cmd' commands. The tokenizing parts also work in csqc. */
#define NEH_CMD_PLAY2
#define NEH_RESTOREGAME
#define QSG_CVARSTRING
#define QW_ENGINE
#define QWE_MVD_RECORD /* You can use the easyrecord command to record MVD demos serverside. */
#define TEI_MD3_MODEL
#define TENEBRAE_GFX_DLIGHTS /* Allows ssqc to attach rtlights to entities with various special properties. */
#define ZQ_MOVETYPE_FLY /* MOVETYPE_FLY works on players. */
#define ZQ_MOVETYPE_NOCLIP /* MOVETYPE_NOCLIP works on players. */
#define ZQ_MOVETYPE_NONE /* MOVETYPE_NONE works on players. */
#define ZQ_VWEP
#define ZQ_QC_STRINGS /* The strings-only subset of FRIK_FILE is supported. */

#ifdef _ACCESSORS
accessor strbuf : float;
accessor searchhandle : float;
accessor hashtable : float;
accessor infostring : string;
accessor filestream : float;
accessor filestream : float;
#else
#define strbuf float
#define searchhandle float
#define hashtable float
#define infostring string
#define filestream float
#endif

entity self;	/* The magic me */
void end_sys_globals;
void end_sys_fields;
float time;	/* The current local time. Increases while paused. */
void(float reqid, float responsecode, string resourcebody) URI_Get_Callback;	/* Called as an eventual result of the uri_get builtin. */
void(string cmdtext) GameCommand;
string(string uri, string method, string postdata, __in string requestheaders, __inout string responseheaders) Cef_GeneratePage;	/* Provides an entrypoint to generate pages for the CEF plugin from within QC. Headers are 
-separated key/value pairs (use tokenizebyseparator). */
void() m_init;
void() m_shutdown;
void(vector screensize) m_draw;	/* Provides the menuqc with a chance to draw. Will be called even if the menu does not have focus, so be sure to avoid that. COMPAT: screensize is not provided in DP. */
void(vector screensize, float opaque) m_drawloading;	/* Additional drawing function to draw loading screens. If opaque is set, then this function must ensure that the entire screen is overdrawn (even if just by a black drawfill). */
float(float evtype, float scanx, float chary, float devid) Menu_InputEvent;	/* If present, this is called instead of m_keydown and m_keyup
Called whenever a key is pressed, the mouse is moved, etc. evtype will be one of the IE_* constants. The other arguments vary depending on the evtype. Key presses are not guarenteed to have both scan and unichar values set at the same time. */
void(float scan, float chr) m_keydown;
void(float scan, float chr) m_keyup;
void(float wantmode) m_toggle;
float(string cmd) m_consolecommand;
var vector drawfontscale = '1 1 0';	/* Specifies a scaler for all text rendering. There are other ways to implement this. */
float drawfont;	/* Allows you to choose exactly which font is to be used to draw text. Fonts can be registered/allocated with the loadfont builtin. */
const float FONT_DEFAULT = 0;
const float TRUE = 1;
const float FALSE = 0;	/* File not found... */
const float M_PI = 3.14159;
const float RESTYPE_MODEL = 0;	/* RESTYPE_* constants are used as arguments with the resourcestatus builtin. */
const float RESTYPE_SOUND = 1;	/* precache_sound */
const float RESTYPE_PARTICLE = 2;	/* particleeffectnum */
const float RESTYPE_PIC = 3;	/* precache_pic. Status results are an amalgomation of the textures used by the named shader. */
const float RESTYPE_SKIN = 4;	/* setcustomskin */
const float RESTYPE_TEXTURE = 5;	/* Individual textures within shaders. These are not directly usable, but may be named as part of a skin file, or a shader. */
const float RESSTATE_NOTKNOWN = 0;	/* RESSTATE_* constants are return values from the resourcestatus builtin. The engine doesn't know about the resource if it is in this state. This means you will need to precache it. Attempting to use it anyway may result in warnings, errors, or silently succeed, depending on engine version and resource type. */
const float RESSTATE_NOTLOADED = 1;	/* The resource was precached, but has been flushed and there has not been an attempt to reload it. If you use the resource normally, chances are it'll be loaded but at the cost of a stall. */
const float RESSTATE_LOADING = 2;	/* Resources in this this state are queued for loading, and will be loaded at the engine's convienience. If you attempt to query the resource now, the engine will stall until the result is available. sounds in this state may be delayed, while models/pics/shaders may be invisible. */
const float RESSTATE_FAILED = 3;	/* Resources in this state are unusable/could not be loaded. You will get placeholders or dummy results. Queries will not stall the engine. The engine may display placeholder content. */
const float RESSTATE_LOADED = 4;	/* Resources in this state are finally usable, everything will work okay. Hurrah. Queries will not stall the engine. */
hashtable gamestate;	/* Special hash table index for hash_add and hash_get. Entries in this table will persist over map changes (and doesn't need to be created/deleted). */
const float HASH_REPLACE = 256;	/* Used with hash_add. Attempts to remove the old value instead of adding two values for a single key. */
const float HASH_ADD = 512;	/* Used with hash_add. The new entry will be inserted in addition to the existing entry. */
const float VF_MIN = 1;	/* The top-left of the 3d viewport in screenspace. The VF_ values are used via the setviewprop/getviewprop builtins. */
const float VF_MIN_X = 2;
const float VF_MIN_Y = 3;
const float VF_SIZE = 4;	/* The width+height of the 3d viewport in screenspace. */
const float VF_SIZE_X = 5;
const float VF_SIZE_Y = 6;
const float VF_VIEWPORT = 7;	/* vector+vector. Two argument shortcut for VF_MIN and VF_SIZE */
const float VF_FOV = 8;	/* sets both fovx and fovy. consider using afov instead. */
const float VF_FOVX = 9;	/* horizontal field of view. does not consider aspect at all. */
const float VF_FOVY = 10;	/* vertical field of view. does not consider aspect at all. */
const float VF_ORIGIN = 11;	/* The origin of the view. Not of the player. */
const float VF_ORIGIN_X = 12;
const float VF_ORIGIN_Y = 13;
const float VF_ORIGIN_Z = 14;
const float VF_ANGLES = 15;	/* The angles the view will be drawn at. Not the angle the client reports to the server. */
const float VF_ANGLES_X = 16;
const float VF_ANGLES_Y = 17;
const float VF_ANGLES_Z = 18;
const float VF_MINDIST = 23;	/* The distance of the near clip plane from the view position. Should generally not be <=0, as this would introduce NANs. */
const float VF_MAXDIST = 24;	/* The distance of the far clip plane from the view position. If 0, will be considered infinite. */
const float VF_PERSPECTIVE = 200;	/* 1: regular rendering. Fov specifies the angle. 0: isometric-style. Fov specifies the number of Quake Units each side of the viewport, and mindist restrictions are removed, pvs culling should be disabled. */
const float VF_AFOV = 203;	/* Aproximate fov. Matches the 'fov' cvar. The engine handles the aspect ratio for you. */
const float VF_SCREENVSIZE = 204;	/* Provides a reliable way to retrieve the current virtual screen size (even if the screen is automatically scaled to retain aspect). */
const float VF_SCREENPSIZE = 205;	/* Provides a reliable way to retrieve the current physical screen size (cvars need vid_restart for them to take effect). */
const float VF_RT_DESTCOLOUR = 212;	/* The texture name to write colour info into, this includes both 3d and 2d drawing.
Additional arguments are: format (rgba8=1,rgba16f=2,rgba32f=3), sizexy.
Written to by both 3d and 2d rendering.
Note that any rendertarget textures may be destroyed on video mode changes or so. Shaders can name render targets by prefixing texture names with '$rt:', or $sourcecolour. */
const float VF_RT_SOURCECOLOUR = 209;	/* The texture name to use with shaders that specify a $sourcecolour map. */
const float VF_RT_DEPTH = 210;	/* The texture name to use as a depth buffer. Also used for shaders that specify $sourcedepth. 1-based. Additional arguments are: format (16bit=4,24bit=5,32bit=6), sizexy. */
const float VF_RT_RIPPLE = 211;	/* The texture name to use as a ripplemap (target for shaders with 'sort ripple'). Also used for shaders that specify $ripplemap. 1-based. Additional arguments are: format, sizexy. */
const float VF_ENVMAP = 220;	/* The cubemap name to use as a fallback for $reflectcube, if a shader was unable to load one. Note that this doesn't automatically change shader permutations or anything. */
const float VF_USERDATA = 221;	/* Pointer (and byte size) to an array of vec4s. This data is then globally visible to all glsl via the w_user uniform. */
const float RF_DEPTHHACK = 4;	/* Hacks the depth values such that the entity uses depth values as if it were closer to the screen. This is useful when combined with viewmodels to avoid weapons poking in to walls. */
const float RF_ADDITIVE = 8;	/* Shaders from this entity will temporarily be hacked to use an additive blend mode instead of their normal blend mode. */
const float FILE_READ = 0;	/* The file may be read via fgets to read a single line at a time. */
const float FILE_APPEND = 1;	/* Like FILE_WRITE, but writing starts at the end of the file. */
const float FILE_WRITE = 2;	/* fputs will be used to write to the file. */
const float SLIST_HOSTCACHEVIEWCOUNT = 0;
const float SLIST_HOSTCACHETOTALCOUNT = 1;
const float SLIST_MASTERQUERYCOUNT = 2;
const float SLIST_MASTERREPLYCOUNT = 3;
const float SLIST_SERVERQUERYCOUNT = 4;
const float SLIST_SERVERREPLYCOUNT = 5;
const float SLIST_SORTFIELD = 6;
const float SLIST_SORTDESCENDING = 7;
const float SLIST_TEST_CONTAINS = 0;
const float SLIST_TEST_NOTCONTAIN = 1;
const float SLIST_TEST_LESSEQUAL = 2;
const float SLIST_TEST_LESS = 3;
const float SLIST_TEST_EQUAL = 4;
const float SLIST_TEST_GREATER = 5;
const float SLIST_TEST_GREATEREQUAL = 6;
const float SLIST_TEST_NOTEQUAL = 7;
const float SLIST_TEST_STARTSWITH = 8;
const float SLIST_TEST_NOTSTARTSWITH = 9;
float(string ext) checkextension = #1; /*
		Checks if the named extension is supported by the running engine. */

void(string err,...) error = #2;
void(string err,...) objerror = #3;
void(string text,...) print = #4; /* Part of DP_SV_PRINT*/
void(string text,...) bprint = #5;
void(float clientnum, string text,...) msprint = #6;
void(string text,...) cprint = #7;
vector(vector) normalize = #8;
float(vector) vlen = #9;
float(vector) vectoyaw = #10;
vector(vector) vectoangles = #11;
float() random = #12;
void(string,...) localcmd = #13;
float(string name) cvar = #14;
void(string name, string value) cvar_set = #15;
void(string text) dprint = #16;
string(float) ftos = #17;
float(float) fabs = #18;
string(vector) vtos = #19;
string(entity) etos = #20; /* Part of DP_QC_ETOS*/
float(string) stof = #21; /* Part of FRIK_FILE, FTE_QC_INFOKEY, FTE_STRINGS, QW_ENGINE, ZQ_QC_STRINGS*/
entity() spawn = #22;
void(entity) remove = #23;
entity(entity start, .string field, string match) find = #24;
entity(entity start, .__variant field, __variant match) findfloat = #25; /* Part of DP_QC_FINDFLOAT*/
entity(.string field, string match) findchain = #26; /* Part of DP_QC_FINDCHAIN*/
entity(.__variant field, __variant match) findchainfloat = #27; /* Part of DP_QC_FINDCHAINFLOAT*/
string(string file) precache_file = #28;
string(string sample) precache_sound = #29;
void() coredump = #30;
void() traceon = #31;
void() traceoff = #32;
void(entity) eprint = #33;
float(float) rint = #34;
float(float) floor = #35;
float(float) ceil = #36;
entity(entity) nextent = #37;
float(float) sin = #38; /* Part of DP_QC_SINCOSSQRTPOW*/
float(float) cos = #39; /* Part of DP_QC_SINCOSSQRTPOW*/
float(float) sqrt = #40; /* Part of DP_QC_SINCOSSQRTPOW*/
vector() randomvector = #41;
float(string name, string value, float flags) registercvar = #42; /* Part of DP_REGISTERCVAR*/
float(float,...) min = #43; /* Part of DP_QC_MINMAXBOUND*/
float(float,...) max = #44; /* Part of DP_QC_MINMAXBOUND*/
float(float min,float value,float max) bound = #45; /* Part of DP_QC_MINMAXBOUND*/
float(float,float) pow = #46; /* Part of DP_QC_SINCOSSQRTPOW*/
void(entity src, entity dst) copyentity = #47; /* Part of DP_QC_COPYENTITY*/
filestream(string filename, float mode) fopen = #48; /* Part of FRIK_FILE*/
void(filestream fhandle) fclose = #49; /* Part of FRIK_FILE*/
string(filestream fhandle) fgets = #50; /* Part of FRIK_FILE*/
void(filestream fhandle, string s) fputs = #51; /* Part of FRIK_FILE*/
float(string) strlen = #52; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
string(string, optional string, optional string, optional string, optional string, optional string, optional string, optional string) strcat = #53; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
string(string s, float start, float length) substring = #54; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
vector(string) stov = #55; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
string(string) strzone = #56; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
void(string) strunzone = #57; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
float(string) tokenize = #58; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND*/
string(float) argv = #59; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND*/
float() isserver = #60;
float() clientcount = #61;
float() clientstate = #62;
void(string map) changelevel = #64;
void(string sample, optional float channel, optional float volume) localsound = #65;
vector() getmousepos = #66;
float(optional float timetype) gettime = #67;
void(string data) loadfromdata = #68;
void(string data) loadfromfile = #69;
float(float val, float m) mod = #70;
string(string name) cvar_string = #71; /* Part of DP_QC_CVAR_STRING*/
void() crash = #72;
void() stackdump = #73;
searchhandle(string pattern, float caseinsensitive, float quiet) search_begin = #74; /* Part of DP_QC_FS_SEARCH*/
void(searchhandle handle) search_end = #75; /* Part of DP_QC_FS_SEARCH*/
float(searchhandle handle) search_getsize = #76; /* Part of DP_QC_FS_SEARCH*/
string(searchhandle handle, float num) search_getfilename = #77; /* Part of DP_QC_FS_SEARCH*/
float(entity) etof = #79;
entity(float) ftoe = #80;
float(string) validstring = #81;
float(string str) altstr_count = #82;
string(string str) altstr_prepare = #83;
string(string str, float num) altstr_get = #84;
string(string str, float num, string set)  altstr_set = #85;
entity(entity start, .float field, float match) findflags = #87; /* Part of DP_QC_FINDFLAGS*/
entity(.float field, float match) findchainflags = #88; /* Part of DP_QC_FINDCHAINFLAGS*/
void(entity ent, string mname) setmodel = #90; /*
		Menuqc-specific version. */

void(string mname) precache_model = #91; /*
		Menuqc-specific version. */

void(entity ent, vector neworg) setorigin = #92; /*
		Menuqc-specific version. */

float(float v, optional float base) logarithm = #0:logarithm; /*
		Determines the logarithm of the input value according to the specified base. This can be used to calculate how much something was shifted by. */

float(__variant funcref) checkbuiltin = #0:checkbuiltin; /*
		Checks to see if the specified builtin is supported/mapped. This is intended as a way to check for #0 functions, allowing for simple single-builtin functions. Warning, if two different engines map different builtins to the same number, then this function will not tell you which will be called, only that it won't crash (the exception being #0, which are remapped as available). */

int(filestream fhandle, void *ptr, int size) fread = #0:fread; /* Part of FTE_QC_FILE_BINARY
		Reads binary data out of the file. Returns truncated lengths if the read exceeds the length of the file. */

int(filestream fhandle, void *ptr, int size) fwrite = #0:fwrite; /* Part of FTE_QC_FILE_BINARY
		Writes binary data out of the file. */

#define ftell fseek //c compat
int(filestream fhandle, optional int newoffset) fseek = #0:fseek; /* Part of FTE_QC_FILE_BINARY
		Changes the current position of the file, if specified. Returns prior position, in bytes. */

int(filestream fhandle, optional int newsize) fsize = #0:fsize; /* Part of FTE_QC_FILE_BINARY
		Reports the total size of the file, in bytes. Can also be used to truncate/extend the file */

void(optional __variant ret) abort = #211; /* Part of FTE_MULTITHREADED
		QC execution is aborted. Parent QC functions on the stack will be skipped, effectively this forces all QC functions to 'return ret' until execution returns to the engine. If ret is ommited, it is assumed to be 0. */

float(string s1, string sub, optional float startidx) strstrofs = #221; /* Part of FTE_STRINGS
		Returns the 0-based offset of sub within the s1 string, or -1 if sub is not in s1.
		If startidx is set, this builtin will ignore matches before that 0-based offset. */

float(string str, float index) str2chr = #222; /* Part of FTE_STRINGS
		Retrieves the character value at offset 'index'. */

string(float chr, ...) chr2str = #223; /* Part of FTE_STRINGS
		The input floats are considered character values, and are concatenated. */

string(float ccase, float redalpha, float redchars, string str, ...) strconv = #224; /* Part of FTE_STRINGS
		Converts quake chars in the input string amongst different representations.
		ccase specifies the new case for letters.
		 0: not changed.
		 1: forced to lower case.
		 2: forced to upper case.
		redalpha and redchars switch between colour ranges.
		 0: no change.
		 1: Forced white.
		 2: Forced red.
		 3: Forced gold(low) (numbers only).
		 4: Forced gold (high) (numbers only).
		 5+6: Forced to white and red alternately.
		You should not use this builtin in combination with UTF-8. */

string(float pad, string str1, ...) strpad = #225; /* Part of FTE_STRINGS
		Pads the string with spaces, to ensure its a specific length (so long as a fixed-width font is used, anyway). If pad is negative, the spaces are added on the left. If positive the padding is on the right. */

string(infostring old, string key, string value) infoadd = #226; /* Part of FTE_STRINGS
		Returns a new tempstring infostring with the named value changed (or added if it was previously unspecified). Key and value may not contain the \ character. */

string(infostring info, string key) infoget = #227; /* Part of FTE_STRINGS
		Reads a named value from an infostring. The returned value is a tempstring */

#define strcmp strncmp
float(string s1, string s2, optional float len, optional float s1ofs, optional float s2ofs) strncmp = #228; /* Part of FTE_STRINGS
		Compares up to 'len' chars in the two strings. s1ofs allows you to treat s2 as a substring to compare against, or should be 0.
		Returns 0 if the two strings are equal, a negative value if s1 appears numerically lower, and positive if s1 appears numerically higher. */

float(string s1, string s2) strcasecmp = #229; /* Part of FTE_STRINGS
		Compares the two strings without case sensitivity.
		Returns 0 if they are equal. The sign of the return value may be significant, but should not be depended upon. */

float(string s1, string s2, float len, optional float s1ofs, optional float s2ofs) strncasecmp = #230; /* Part of FTE_STRINGS
		Compares up to 'len' chars in the two strings without case sensitivity. s1ofs allows you to treat s2 as a substring to compare against, or should be 0.
		Returns 0 if they are equal. The sign of the return value may be significant, but should not be depended upon. */

string(string s) strtrim = #0:strtrim; /*
		Trims the whitespace from the start+end of the string. */

float(string shadername, optional string defaultshader, ...) shaderforname = #238; /* Part of FTE_FORCESHADER
		Caches the named shader and returns a handle to it.
		If the shader could not be loaded from disk (missing file or ruleset_allow_shaders 0), it will be created from the 'defaultshader' string if specified, or a 'skin shader' default will be used.
		defaultshader if not empty should include the outer {} that you would ordinarily find in a shader. */

void(string destaddress, string content) sendpacket = #242; /* Part of FTE_QC_SENDPACKET
		Sends a UDP packet to the specified destination. Note that the payload will be prefixed with four 255 bytes as a sort of security feature. */

int(float) ftoi = #0:ftoi; /* Part of FTE_QC_INTCONV
		Converts the given float into a true integer without depending on extended qcvm instructions. */

float(int) itof = #0:itof; /* Part of FTE_QC_INTCONV
		Converts the given true integer into a float without depending on extended qcvm instructions. */

#define dotproduct(v1,v2) ((vector)(v1)*(vector)(v2))
vector(vector v1, vector v2) crossproduct = #0:crossproduct; /* Part of FTE_QC_CROSSPRODUCT
		Small helper function to calculate the crossproduct of two vectors. */

hashtable(float tabsize, optional float defaulttype) hash_createtab = #287; /* Part of FTE_QC_HASHTABLES
		Creates a hash table object with at least 'tabsize' slots. hash table with index 0 is a game-persistant table and will NEVER be returned by this builtin (except as an error return). */

void(hashtable table) hash_destroytab = #288; /* Part of FTE_QC_HASHTABLES
		Destroys a hash table object. */

void(hashtable table, string name, __variant value, optional float typeandflags) hash_add = #289; /* Part of FTE_QC_HASHTABLES
		Adds the given key with the given value to the table.
		If flags&HASH_REPLACE, the old value will be removed, if not set then multiple values may be added for a single key, they won't overwrite.
		The type argument describes how the value should be stored and saved to files. While you can claim that all variables are just vectors, being more precise can result in less issues with tempstrings or saved games. */

__variant(hashtable table, string name, optional __variant deflt, optional float requiretype, optional float index) hash_get = #290; /* Part of FTE_QC_HASHTABLES
		looks up the specified key name in the hash table. returns deflt if key was not found. If stringsonly=1, the return value will be in the form of a tempstring, otherwise it'll be the original value argument exactly as it was. If requiretype is specified, then values not of the specified type will be ignored. Hurrah for multiple types with the same name. */

__variant(hashtable table, string name) hash_delete = #291; /* Part of FTE_QC_HASHTABLES
		removes the named key. returns the value of the object that was destroyed, or 0 on error. */

string(hashtable table, float idx) hash_getkey = #292; /* Part of FTE_QC_HASHTABLES
		gets some random key name. add+delete can change return values of this, so don't blindly increment the key index if you're removing all. */

float(string name) checkcommand = #294; /* Part of FTE_QC_CHECKCOMMAND
		Checks to see if the supplied name is a valid command, cvar, or alias. Returns 0 if it does not exist. */

string(string s) argescape = #295; /*
		Marks up a string so that it can be reliably tokenized as a single argument later. */

void() clearscene = #300; /*
		Forgets all rentities, polygons, and temporary dlights. Resets all view properties to their default values. */

void(entity ent) addentity = #302; /*
		Copies the entity fields into a new rentity for later rendering via addscene. */

#define setviewprop setproperty
float(float property, ...) setproperty = #303; /*
		Allows you to override default view properties like viewport, fov, and whether the engine hud will be drawn. Different VF_ values have slightly different arguments, some are vectors, some floats. */

void() renderscene = #304; /*
		Draws all entities, polygons, and particles on the rentity list (which were added via addentities or addentity), using the various view properties set via setproperty. There is no ordering dependancy.
		The scene must generally be cleared again before more entities are added, as entities will persist even over to the next frame.
		You may call this builtin multiple times per frame, but should only be called from CSQC_UpdateView. */

void(string texturename, optional float flags, optional float is2d) R_BeginPolygon = #306; /*
		Specifies the shader to use for the following polygons, along with optional flags.
		If is2d, the polygon will be drawn as soon as the EndPolygon call is made, rather than waiting for renderscene. This allows complex 2d effects. */

void(vector org, vector texcoords, vector rgb, float alpha) R_PolygonVertex = #307; /*
		Specifies a polygon vertex with its various properties. */

void() R_EndPolygon = #308; /*
		Ends the current polygon. At least 3 verticies must have been specified. You do not need to call beginpolygon if you wish to draw another polygon with the same shader. */

#define getviewprop getproperty
__variant(float property) getproperty = #309; /*
		Retrieve a currently-set (typically view) property, allowing you to read the current viewport or other things. Due to cheat protection, certain values may be unretrievable. */

void(vector pos, vector size, float alignflags, string text) drawtextfield = #0:drawtextfield; /*
		Draws a multi-line block of text, including word wrapping and alignment. alignflags bits are RTLB, typically 3. */

void(string imagename, int width, int height, void *pixeldata, optional int datasize, optional int format) r_uploadimage = #0:r_uploadimage; /* Part of FTE_CSQC_RAWIMAGES
		Updates a texture with the specified rgba data. Will be created if needed. If blobsize is specified then the image is decoded (eg .ktx or .dds data) instead of being raw R8G8B8A data. You'll typically want shaderforname to also generate a shader to use the texture. */

int*(string filename, __out int width, __out int height) r_readimage = #0:r_readimage; /* Part of FTE_CSQC_RAWIMAGES
		Reads and decodes an image from disk, providing raw R8G8B8A pixel data. Should not be used for dds or ktx etc formats. Returns __NULL__ if the image could not be read for any reason. Use memfree to free the data once you're done with it. */

void(vector pivot, vector mins, vector maxs, string pic, vector rgb, float alpha, float angle) drawrotpic = #0:drawrotpic; /*
		Draws an image rotating at the pivot. To rotate in the center, use mins+maxs of half the size with mins negated. Angle is in degrees. */

void(vector pivot, vector mins, vector maxs, string pic, vector txmin, vector txsize, vector rgb, vector alphaandangles) drawrotsubpic = #0:drawrotsubpic; /*
		Overcomplicated draw function for over complicated people. Positions follow drawrotpic, while texture coords follow drawsubpic. Due to argument count limitations in builtins, the alpha value and angles are combined into separate fields of a vector (tip: use fteqcc's [alpha, angle] feature. */

string(float keynum) keynumtostring_csqc = #340; /*
		Returns a hunam-readable name for the given keycode, as a tempstring. */

float(string keyname) stringtokeynum_csqc = #341; /*
		Looks up the key name in the same way that the bind command would, returning the keycode for that key. */

string(float keynum) getkeybind = #342; /*
		Returns the current binding for the given key (returning only the command executed when no modifiers are pressed). */

void(float usecursor, optional string cursorimage, optional vector hotspot, optional float scale) setcursormode = #343; /*
		Pass TRUE if you want the engine to release the mouse cursor (absolute input events + touchscreen mode). Pass FALSE if you want the engine to grab the cursor (relative input events + standard looking). If the image name is specified, the engine will use that image for a cursor (use an empty string to clear it again), in a way that will not conflict with the console. Images specified this way will be hardware accelerated, if supported by the platform/port. */

float(float effective) getcursormode = #0:getcursormode; /*
		Reports the cursor mode this module previously attempted to use. If 'effective' is true, reports the cursor mode currently active (if was overriden by a different module which has precidence, for instance, or if there is only a touchscreen and no mouse). */

float() isdemo = #349; /*
		Returns if the client is currently playing a demo or not. Returns 2 when playing an mvd (where other player's stats can be queried, or the pov can be changed freely). */

void(string cmdname) registercommand = #352; /*
		Register the given console command, for easy console use.
		Console commands that are later used will invoke CSQC_ConsoleCommand. */

float(string s) findfont = #356; /* Part of DP_GFX_FONTS
		Looks up a named font slot. Matches the actual font name as a last resort. */

float(string fontname, string fontmaps, string sizes, float slot, optional float fix_scale, optional float fix_voffset) loadfont = #357; /* Part of DP_GFX_FONTS
		too convoluted for me to even try to explain correct usage. Try drawfont = loadfont("", "cour", "16", -1, 0, 0); to switch to the courier font (optimised for 16 virtual pixels high), if you have the freetype2 library in windows.. */

void(entity e, string skinfilename, optional string skindata) setcustomskin = #376; /* Part of FTE_QC_CUSTOMSKINS
		Sets an entity's skin overrides to a new skin object. Releases the entities old skin (refcounted). */

__variant*(int size) memalloc = #384; /* Part of FTE_MEMALLOC
		Allocate an arbitary block of memory */

void(__variant *ptr) memfree = #385; /* Part of FTE_MEMALLOC
		Frees a block of memory that was allocated with memfree */

void(__variant *dst, __variant *src, int size) memcpy = #386; /* Part of FTE_MEMALLOC
		Copys memory from one location to another */

void(__variant *dst, int val, int size) memfill8 = #387; /* Part of FTE_MEMALLOC
		Sets an entire block of memory to a specified value. Pretty much always 0. */

__variant(__variant *dst, float ofs) memgetval = #388; /*
		Looks up the 32bit value stored at a pointer-with-offset. */

void(__variant *dst, float ofs, __variant val) memsetval = #389; /*
		Changes the 32bit value stored at the specified pointer-with-offset. */

__variant*(__variant *base, float ofs) memptradd = #390; /*
		Perform some pointer maths. Woo. */

float(string s) memstrsize = #0:memstrsize; /*
		strlen, except ignores utf-8 */

string(string conname, string field, optional string newvalue) con_getset = #391; /* Part of FTE_CSQC_ALTCONSOLES
		Reads or sets a property from a console object. The old value is returned. Iterrate through consoles with the 'next' field. Valid properties: 	title, name, next, unseen, markup, forceutf8, close, clear, hidden, linecount */

void(string conname, string messagefmt, ...) con_printf = #392; /* Part of FTE_CSQC_ALTCONSOLES
		Prints onto a named console. */

void(string conname, vector pos, vector size, float fontsize) con_draw = #393; /* Part of FTE_CSQC_ALTCONSOLES
		Draws the named console. */

float(string conname, float inevtype, float parama, float paramb, float paramc) con_input = #394; /* Part of FTE_CSQC_ALTCONSOLES
		Forwards input events to the named console. Mouse updates should be absolute only. */

float() cvars_haveunsaved = #0:cvars_haveunsaved; /*
		Returns true if any archived cvar has an unsaved value. */

float(entity e, float nowreadonly) entityprotection = #0:entityprotection; /*
		Changes the protection on the specified entity to protect it from further edits from QC. The return value is the previous setting. Note that this can be used to unprotect the world, but doing so long term is not advised as you will no longer be able to detect invalid entity references. Also, world is not networked, so results might not be seen by clients (or in other words, world.avelocity_y=64 is a bad idea). */

strbuf() buf_create = #440; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle) buf_del = #441; /* Part of DP_QC_STRINGBUFFERS*/
float(strbuf bufhandle) buf_getsize = #442; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle_from, float bufhandle_to) buf_copy = #443; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle, float sortprefixlen, float backward) buf_sort = #444; /* Part of DP_QC_STRINGBUFFERS*/
string(strbuf bufhandle, string glue) buf_implode = #445; /* Part of DP_QC_STRINGBUFFERS*/
string(strbuf bufhandle, float string_index) bufstr_get = #446; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle, float string_index, string str) bufstr_set = #447; /* Part of DP_QC_STRINGBUFFERS*/
float(strbuf bufhandle, string str, float ordered) bufstr_add = #448; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle, float string_index) bufstr_free = #449; /* Part of DP_QC_STRINGBUFFERS*/
float(string name) iscachedpic = #451;
string(string name, optional float trywad) precache_pic = #452;
float(vector position, float character, vector scale, vector rgb, float alpha, optional float flag) drawcharacter = #454;
float(vector position, string text, vector scale, vector rgb, float alpha, optional float flag) drawrawstring = #455;
float(vector position, string pic, vector size, vector rgb, float alpha, optional float flag) drawpic = #456;
float(vector position, vector size, vector rgb, float alpha, optional float flag) drawfill = #457;
void(float x, float y, float width, float height) drawsetcliparea = #458;
void(void) drawresetcliparea = #459;
vector(string picname) drawgetimagesize = #460;
float(vector position, string text, vector scale, vector rgb, float alpha, float flag) drawstring = #467;
float(string text, float usecolours, optional vector fontsize) stringwidth = #468;
void(vector pos, vector sz, string pic, vector srcpos, vector srcsz, vector rgb, float alpha, float flag) drawsubpic = #469;
float(searchhandle handle, float num) search_getfilesize = #0:search_getfilesize; /* Part of FTE_QC_FS_SEARCH_SIZEMTIME
		Retrieves the size of one of the files that was found by the initial search. */

string(searchhandle handle, float num) search_getfilemtime = #0:search_getfilemtime; /* Part of FTE_QC_FS_SEARCH_SIZEMTIME
		Retrieves modification time of one of the files. */

float(float s) asin = #471; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float c) acos = #472; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float t) atan = #473; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float c, float s) atan2 = #474; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float a) tan = #475; /* Part of DP_QC_ASINACOSATANATAN2TAN
		Forgive me father, for I have a sunbed and I'm not afraid to use it. */

float(string s) strlennocol = #476; /* Part of DP_QC_STRINGCOLORFUNCTIONS
		Returns the number of characters in the string after any colour codes or other markup has been parsed. */

string(string s) strdecolorize = #477; /* Part of DP_QC_STRINGCOLORFUNCTIONS
		Flattens any markup/colours, removing them from the string. */

string(float uselocaltime, string format, ...) strftime = #478; /* Part of DP_QC_STRFTIME*/
float(string s, string separator1, ...) tokenizebyseparator = #479; /* Part of DP_QC_TOKENIZEBYSEPARATOR*/
string(string s) strtolower = #480; /* Part of DP_QC_STRING_CASE_FUNCTIONS*/
string(string s) strtoupper = #481; /* Part of DP_QC_STRING_CASE_FUNCTIONS*/
string(string s) cvar_defstring = #482; /* Part of DP_QC_CVAR_DEFSTRING*/
string(string search, string replace, string subject) strreplace = #484; /* Part of DP_QC_STRREPLACE*/
string(string search, string replace, string subject) strireplace = #485; /* Part of DP_QC_STRREPLACE*/
float(string name, optional string initialURI) gecko_create = #487; /* Part of DP_GECKO_SUPPORT
		Create a new 'browser tab' shader with the specified name that can then be drawn via drawpic (shader should not already exist - including from map/model textures or disk). In order to function correctly, this builtin depends upon external plugins being available. Use gecko_navigate to navigate it to a page of your choosing. */

void(string name) gecko_destroy = #488; /* Part of DP_GECKO_SUPPORT
		Destroy a shader. */

void(string name, string URI) gecko_navigate = #489; /* Part of DP_GECKO_SUPPORT
		Sends a command to the media decoder attached to the specified shader. In the case of a browser decoder, this changes the url that the browser displays. 'cmd:[un]focus' will tell the decoder that it has focus. */

float(string name, float key, float eventtype, optional float charcode) gecko_keyevent = #490; /* Part of DP_GECKO_SUPPORT
		Send a key event to a media decoder. This applies only to interactive decoders like browsers. */

void(string name, float x, float y) gecko_mousemove = #491; /* Part of DP_GECKO_SUPPORT
		Sets a media decoder shader's mouse position. Values should be 0-1. */

void(string name, float w, float h) gecko_resize = #492; /* Part of DP_GECKO_SUPPORT
		Request to resize a media decoder. */

vector(string name) gecko_get_texture_extent = #493; /* Part of DP_GECKO_SUPPORT
		Retrieves a media decoder current image pixel sizes. */

string(string shadname, string propname) gecko_getproperty = #0:gecko_getproperty; /*
		Queries the media decoder (especially browser ones) for decoder-specific properties. The cef plugin recognises url, title, status. */

float(float caseinsensitive, string s, ...) crc16 = #494; /* Part of DP_QC_CRC16*/
float(string name) cvar_type = #495; /* Part of DP_QC_CVAR_TYPE*/
float() numentityfields = #496; /* Part of DP_QC_ENTITYDATA
		Gives the number of named entity fields. Note that this is not the size of an entity, but rather just the number of unique names (ie: vectors use 4 names rather than 3). */

float(string fieldname) findentityfield = #0:findentityfield; /*
		Find a field index by name. */

typedef .__variant field_t;
field_t(float fieldnum) entityfieldref = #0:entityfieldref; /*
		Returns a field value that can be directly used to read entity fields. Be sure to validate the type with entityfieldtype before using. */

string(float fieldnum) entityfieldname = #497; /* Part of DP_QC_ENTITYDATA
		Retrieves the name of the given entity field. */

float(float fieldnum) entityfieldtype = #498; /* Part of DP_QC_ENTITYDATA
		Provides information about the type of the field specified by the field num. Returns one of the EV_ values. */

string(float fieldnum, entity ent) getentityfieldstring = #499; /* Part of DP_QC_ENTITYDATA*/
float(float fieldnum, entity ent, string s) putentityfieldstring = #500; /* Part of DP_QC_ENTITYDATA*/
string(string filename, optional float makereferenced) whichpack = #503; /* Part of DP_QC_WHICHPACK
		Returns the pak file name that contains the file specified. progs/player.mdl will generally return something like 'pak0.pak'. If makereferenced is true, clients will automatically be told that the returned package should be pre-downloaded and used, even if allow_download_refpackages is not set. */

string(string in) uri_escape = #510; /* Part of DP_QC_URI_ESCAPE*/
string(string in) uri_unescape = #511; /* Part of DP_QC_URI_ESCAPE*/
float(entity ent) num_for_edict = #512;
#define uri_post uri_get
float(string uril, float id, optional string postmimetype, optional string postdata) uri_get = #513; /* Part of DP_QC_URI_GET, DP_QC_URI_POST
		uri_get() gets content from an URL and calls a callback "uri_get_callback" with it set as string; an unique ID of the transfer is returned
		returns 1 on success, and then calls the callback with the ID, 0 or the HTTP status code, and the received data in a string
		For a POST request, you will typically want the postmimetype set to application/x-www-form-urlencoded.
		For a GET request, omit the mime+data entirely.
		Consult your webserver/php/etc documentation for best-practise. */

float(string str) tokenize_console = #514; /*
		Tokenize a string exactly as the console's tokenizer would do so. The regular tokenize builtin became bastardized for convienient string parsing, which resulted in a large disparity that can be exploited to bypass checks implemented in a naive SV_ParseClientCommand function, therefore you can use this builtin to make sure it exactly matches. */

float(float idx) argv_start_index = #515; /*
		Returns the character index that the tokenized arg started at. */

float(float idx) argv_end_index = #516; /*
		Returns the character index that the tokenized arg stopped at. */

void(strbuf strbuf, string pattern, string antipattern) buf_cvarlist = #517;
string(string cvarname) cvar_description = #518; /*
		Retrieves the description of a cvar, which might be useful for tooltips or help files. This may still not be useful. */

float(float v, optional float base) log = #532; /* Part of ??MVDSV_BUILTINS
		Determines the logarithm of the input value according to the specified base. This can be used to calculate how much something was shifted by. */

float(string sample) soundlength = #534; /*
		Provides a way to query the duration of a sound sample, allowing you to set up a timer to chain samples. */

float(string filename, strbuf bufhandle) buf_loadfile = #535; /*
		Appends the named file into a string buffer (which must have been created in advance). The return value merely says whether the file was readable. */

float(filestream filehandle, strbuf bufhandle, optional float startpos, optional float numstrings) buf_writefile = #536; /*
		Writes the contents of a string buffer onto the end of the supplied filehandle (you must have already used fopen). Additional optional arguments permit you to constrain the writes to a subsection of the stringbuffer. */

void(float dest) setkeydest = #601;
float() getkeydest = #602;
void(float trg) setmousetarget = #603;
float() getmousetarget = #604;
void(.../*, string funcname*/) callfunction = #605; /*
		Invokes the named function. The function name is always passed as the last parameter and must always be present. The others are passed to the named function as-is */

void(filestream fh, entity e) writetofile = #606; /*
		Writes an entity's fields to the named frik_file file handle. */

float(string s) isfunction = #607; /*
		Returns true if the named function exists and can be called with the callfunction builtin. */

vector(float vidmode, optional float forfullscreen) getresolution = #608; /*
		Supposed to query the driver for supported video modes. FTE does not query drivers in this way, nor would it trust drivers anyway. */

string(float keynum) keynumtostring = #609; /*
		Converts a qscancode key number into a mostly-human-readable name, matching the bind command. */

string(string command, optional float bindmap) findkeysforcommand = #610;
float(float type) gethostcachevalue = #611; /* Part of FTE_CSQC_SERVERBROWSER*/
string(float type, float hostnr) gethostcachestring = #612; /* Part of FTE_CSQC_SERVERBROWSER*/
float(entity e, string s, optional float offset) parseentitydata = #613; /*
		Reads a single entity's fields into an already-spawned entity. s should contain field pairs like in a saved game: {"foo1" "bar" "foo2" "5"}. Returns <=0 on failure, otherwise returns the offset in the string that was read to. */

string(entity e) generateentitydata = #0:generateentitydata; /*
		Dumps the entities fields into a string which can later be parsed with parseentitydata. */

float(string key) stringtokeynum = #614; /*
		Returns the qscancode of a key from its name. Names are identical to the bind command. ctrl/shift/alt modifiers are ignored. */

void() resethostcachemasks = #615; /* Part of FTE_CSQC_SERVERBROWSER*/
void(float mask, float fld, string str, float op) sethostcachemaskstring = #616; /* Part of FTE_CSQC_SERVERBROWSER*/
void(float mask, float fld, float num, float op) sethostcachemasknumber = #617; /* Part of FTE_CSQC_SERVERBROWSER*/
void() resorthostcache = #618; /* Part of FTE_CSQC_SERVERBROWSER*/
void(float fld, float descending) sethostcachesort = #619; /* Part of FTE_CSQC_SERVERBROWSER*/
void(optional float dopurge) refreshhostcache = #620; /* Part of FTE_CSQC_SERVERBROWSER*/
float(float fld, float hostnr) gethostcachenumber = #621; /* Part of FTE_CSQC_SERVERBROWSER*/
float(string key) gethostcacheindexforkey = #622; /* Part of FTE_CSQC_SERVERBROWSER*/
void(string key) addwantedhostcachekey = #623; /* Part of FTE_CSQC_SERVERBROWSER*/
string() getextresponse = #624; /* Part of FTE_CSQC_SERVERBROWSER*/
string(string dnsname, optional float defport) netaddress_resolve = #625;
string(string fmt, ...) sprintf = #627; /* Part of DP_QC_SPRINTF
		'prints' to a formatted temp-string. Mostly acts as in C, however %d assumes floats (fteqcc has arg checking. Use it.).
		type conversions: l=arg is an int, h=arg is a float, and will work as a prefix for any float or int representation.
		float representations: d=decimal, e,E=exponent-notation, f,F=floating-point notation, g,G=terse float, c=char code, x,X=hex
		other representations: i=int, s=string, S=quoted and marked-up string, v=vector, p=pointer
		so %ld will accept an int arg, while %hi will expect a float arg.
		entities, fields, and functions will generally need to be printed as ints with %i. */

vector() getbindmaps = #631;
float(vector bm) setbindmaps = #632;
string(string digest, string data, ...) digest_hex = #639;
string(string digest, void *data, int length) digest_ptr = #0:digest_ptr; /*
		Calculates the digest of a single contiguous block of memory (including nulls) using the specified hash function. */

#if defined(CSQC) || defined(MENU)
#define K_TAB	9
#define K_ENTER	13
#define K_ESCAPE	27
#define K_SPACE	32
#define K_BACKSPACE	127
#define K_UPARROW	128
#define K_DOWNARROW	129
#define K_LEFTARROW	130
#define K_RIGHTARROW	131
#define K_LALT	132
#define K_RALT	-245
#define K_LCTRL	133
#define K_RCTRL	-246
#define K_LSHIFT	134
#define K_RSHIFT	-247
#define K_F1	135
#define K_F2	136
#define K_F3	137
#define K_F4	138
#define K_F5	139
#define K_F6	140
#define K_F7	141
#define K_F8	142
#define K_F9	143
#define K_F10	144
#define K_F11	145
#define K_F12	146
#define K_INS	147
#define K_DEL	148
#define K_PGDN	149
#define K_PGUP	150
#define K_HOME	151
#define K_END	152
#define K_KP_HOME	164
#define K_KP_UPARROW	165
#define K_KP_PGUP	166
#define K_KP_LEFTARROW	161
#define K_KP_5	162
#define K_KP_RIGHTARROW	163
#define K_KP_END	158
#define K_KP_DOWNARROW	159
#define K_KP_PGDN	160
#define K_KP_ENTER	172
#define K_KP_INS	157
#define K_KP_DEL	167
#define K_KP_SLASH	168
#define K_KP_MINUS	170
#define K_KP_PLUS	171
#define K_KP_NUMLOCK	154
#define K_KP_STAR	169
#define K_KP_EQUALS	173
#define K_MOUSE1	512
#define K_MOUSE2	513
#define K_MOUSE3	514
#define K_MOUSE4	517
#define K_MOUSE5	518
#define K_MOUSE6	519
#define K_MOUSE7	520
#define K_MOUSE8	521
#define K_MOUSE9	522
#define K_MOUSE10	523
#define K_MWHEELUP	515
#define K_MWHEELDOWN	516
#define K_LWIN	-239
#define K_RWIN	-240
#define K_APP	-241
#define K_SEARCH	-242
#define K_POWER	-130
#define K_VOLUP	-243
#define K_VOLDOWN	-244
#define K_JOY1	768
#define K_JOY2	769
#define K_JOY3	770
#define K_JOY4	771
#define K_AUX1	784
#define K_AUX2	785
#define K_AUX3	786
#define K_AUX4	787
#define K_AUX5	788
#define K_AUX6	789
#define K_AUX7	790
#define K_AUX8	791
#define K_AUX9	792
#define K_AUX10	793
#define K_AUX11	794
#define K_AUX12	795
#define K_AUX13	796
#define K_AUX14	797
#define K_AUX15	798
#define K_AUX16	799
#define K_AUX17	800
#define K_AUX18	801
#define K_AUX19	802
#define K_AUX20	803
#define K_AUX21	804
#define K_AUX22	805
#define K_AUX23	806
#define K_AUX24	807
#define K_AUX25	808
#define K_AUX26	809
#define K_AUX27	810
#define K_AUX28	811
#define K_AUX29	812
#define K_AUX30	813
#define K_AUX31	814
#define K_AUX32	815
#define K_PAUSE	153
#define K_PRINTSCREEN	174
#define K_CAPSLOCK	155
#define K_SCROLLLOCK	156
#define K_SEMICOLON	59
#define K_PLUS	43
#define K_MINUS	45
#define K_TILDE	126
#define K_BACKQUOTE	96
#define K_BACKSLASH	92
#define K_GP_A	826
#define K_GP_B	827
#define K_GP_X	828
#define K_GP_Y	829
#define K_GP_LSHOULDER	824
#define K_GP_RSHOULDER	825
#define K_GP_LTRIGGER	830
#define K_GP_RTRIGGER	831
#define K_GP_BACK	821
#define K_GP_START	820
#define K_GP_LTHUMB	822
#define K_GP_RTHUMB	823
#define K_GP_DPAD_UP	816
#define K_GP_DPAD_DOWN	817
#define K_GP_DPAD_LEFT	818
#define K_GP_DPAD_RIGHT	819
#define K_GP_GUIDE	-202
#define K_GP_UNKNOWN	-255
#define K_GP_LTHUMB_UP	832
#define K_GP_LTHUMB_DOWN	833
#define K_GP_LTHUMB_LEFT	834
#define K_GP_LTHUMB_RIGHT	835
#define K_GP_RTHUMB_UP	836
#define K_GP_RTHUMB_DOWN	837
#define K_GP_RTHUMB_LEFT	838
#define K_GP_RTHUMB_RIGHT	839
#endif
#ifdef _ACCESSORS
accessor strbuf : float
{
	inline get float asfloat[float idx] = {return stof(bufstr_get(this, idx));};
	inline set float asfloat[float idx] = {bufstr_set(this, idx, ftos(value));};
	get string[float] = bufstr_get;
	set string[float] = bufstr_set;
	get float length = buf_getsize;
};
accessor searchhandle : float
{
	get string[float] = search_getfilename;
	get float length = search_getsize;
};
accessor hashtable : float
{
	inline get vector v[string key] = {return hash_get(this, key, '0 0 0', EV_VECTOR);};
	inline set vector v[string key] = {hash_add(this, key, value, HASH_REPLACE|EV_VECTOR);};
	inline get string s[string key] = {return hash_get(this, key, "", EV_STRING);};
	inline set string s[string key] = {hash_add(this, key, value, HASH_REPLACE|EV_STRING);};
	inline get float f[string key] = {return hash_get(this, key, 0.0, EV_FLOAT);};
	inline set float f[string key] = {hash_add(this, key, value, HASH_REPLACE|EV_FLOAT);};
	inline get __variant[string key] = {return hash_get(this, key, __NULL__);};
	inline set __variant[string key] = {hash_add(this, key, value, HASH_REPLACE);};
};
accessor infostring : string
{
	get string[string] = infoget;
	inline seti& string[string fld] = {this = infoadd(this, fld, value);};
};
accessor filestream : float
{
	get string = fgets;
	inline set string = {fputs(this,value);};
};
#endif
#pragma noref 0

float menu_active;

float splash_time;

void() m_init =
{
	splash_time = time + 2.5;
	registercommand("togglemenu2");
	// drawfont = loadfont("", "Courier Prime Code", "12,16,24,32,48,64,72,128,256,512", -1, 0, 0);
	setcursormode(TRUE,"gfx/xhair", [16, 16], cvar("vid_conautoscale"));
	current_menu = MENU_MAIN;
};

vector() randomofs = { return [random() - 0.5, random() - 0.5] * 2; };

void(vector screensize) m_draw =
{
//	clearscene();

	
	vector realsize = getproperty(VF_SCREENPSIZE);
	float target_conauto = 2;
	if (realsize_y < 600) target_conauto = 1;
	else if (realsize_y < 1200) target_conauto = 2;
	else target_conauto = 4;
	
	if (target_conauto != cvar("vid_conautoscale")) localcmd(sprintf("vid_conautoscale %f\n", target_conauto));
	
	
	sui_begin(screensize_x, screensize_y);
	if (menu_active)
		root_menu(screensize);
		
		
	if (time < splash_time)
	{
		sui_set_align([SUI_ALIGN_CENTER, SUI_ALIGN_CENTER]);
		float diff = splash_time - time;
		float a;
		if (diff > 2.5)
		{
			a = 1 - (diff - 2.5) * 2;
			float xstretch = (diff - 2.5) * 4;
			sui_fill([0, 0], screensize, '0 0 0', 1, 0);
			sui_pic(randomofs() * 1, [screensize_y * (0.7 + xstretch), screensize_y * 0.7], "gfx/splash.tga", '1 1 1', a * 0.75, 1);
			sui_pic(randomofs() * 1, [screensize_y * (0.7 + xstretch), screensize_y * 0.7], "gfx/splash.tga", '1 1 1', a * 0.75, 1);
		}
		else 
		{
			a = diff * 0.6;
			sui_fill([0, 0], screensize, '0 0 0', a * 2, 0);
			sui_pic(randomofs() * a, [screensize_y * 0.7, screensize_y * 0.7], "gfx/splash.tga", '1 1 1', a, 1);
			sui_pic(randomofs() * a, [screensize_y * (0.7 + random() * 0.05), screensize_y * 0.7], "gfx/splash.tga", '1 1 1', a * 0.5, 1);
		}
	}
	
	sui_end();
};

void() m_close =
{
	setkeydest(0);
	menu_active = FALSE;
};

void() m_open =
{
	setkeydest(2);
	menu_active = TRUE;
};

float(float evtype, float scanx, float chary, float devid) Menu_InputEvent =
{
	float used = sui_input_event(evtype, scanx, chary, devid);
	
	if (evtype == IE_KEYDOWN && !used)
	{
		string cmd = getkeybind(scanx);
		switch (cmd)
		{
		case "togglemenu":
			m_close();
			return TRUE;
			break;
		default: break;
		}
	}
	return FALSE;
};

float(string cmd) m_consolecommand =
{
	tokenize(cmd);
	switch (argv(0))
	{
	default: break;
	}

	return FALSE;
};

void(float wantmode) m_toggle =
{
	if (menu_active) m_close();
	else m_open();
};

void() m_shutdown =
{
};
vector MENU_BG = '0.2 0.3 0.4';
vector MENU_BG_DARK = '0.1 0.15 0.2';
vector MENU_BORDER = '0.3 0.4 0.5';
vector MENU_BUTTON = '0.3 0.4 0.5';
vector MENU_BUTTON_BORDER = '0.35 0.45 0.55';
vector MENU_TEXT_1 = '1 1 1';
vector MENU_TEXT_2 = '0.7 0.75 0.75';
vector MENU_HIGHLIGHT = '1 1 1';
vector MENU_DARKEN = '1 1 1';

vector MENU_TEXT_SMALL = '8 8 0';
vector MENU_TEXT_MEDIUM = '16 16 0';
vector MENU_TEXT_LARGE = '24 24 0';

void() input_tester =
{
	float char = 0;
	float scan = 0;
	string printme = "";
	while (sui_get_input(char, scan))
	{
		printme = strcat(printme, chr2str(char));
	}
	if (printme != "") printf("INPUT: %s\n", printme); 
};

void(string id, vector pos, vector size, float maxlen, __inout string text, __inout float cursor) text_input_control =
{
	vector textsize = [size_y - 4, size_y - 4];
	sui_push_frame(pos, size);
	vector basecolor = sui_is_hovered(id) ? MENU_BG_DARK + MENU_HIGHLIGHT * 0.08 : MENU_BG_DARK; 
	sui_fill([0, 0], size, basecolor, 0.6, 0);
	
	sui_text_input(id, [0, 0], size, text, cursor);
	
	sui_set_align([SUI_ALIGN_START, SUI_ALIGN_CENTER]);
	float focused = sui_is_last_clicked(id);
	// Under focus
	focused ? sui_border_box([0, 0], size, 1, MENU_BORDER, 0.6, 0) : 0;	
	
	sui_push_frame([2, 0], [size_x - 4, size_y - 4]);
	
	float cursorx;
	if (stringwidth(text, 1, textsize) > size_x - 4)
	{
		sui_clip_to_frame();
		cursorx = 0;
		sui_set_align([SUI_ALIGN_END, SUI_ALIGN_CENTER]);
		sui_text([0, 0], textsize, text, MENU_TEXT_1, 1, 0);
	}
	else
	{
		cursorx = stringwidth(substring(text, 0, cursor), 1, textsize);
		sui_text([0, 0], textsize, text, MENU_TEXT_1, 1, 0);
	}
	if (focused) 
	{
		sui_fill([cursorx, 0], [2, textsize_y], MENU_TEXT_1, fabs(sin(time * 4)), 0);
	}
	sui_reset_clip();
	sui_pop_frame();
	
	sui_pop_frame();
};

float(string id, vector pos, vector size, string text) my_button =
{
	sui_push_frame(pos, size);
	vector basecolor = sui_is_hovered(id) ? MENU_BUTTON + MENU_HIGHLIGHT * 0.1 : MENU_BUTTON; 
	basecolor = sui_is_held(id) ? MENU_BUTTON - MENU_DARKEN * 0.1 : basecolor;
	sui_fill([0, 0], size, basecolor, 0.6, 0);
	sui_border_box([0, 0], size, 1, MENU_BUTTON_BORDER, 0.4, 0);
	
	sui_set_align([SUI_ALIGN_CENTER, SUI_ALIGN_CENTER]);
	sui_text([0, 0], MENU_TEXT_SMALL, text, MENU_TEXT_1, 1, 0);	
	sui_action_element([0, 0], size, id, sui_noop);
	sui_pop_frame();
	
	return sui_is_clicked(id);
};


void(string id, vector pos, vector size, vector minmaxsteps, __inout float value) my_slider =
{
	sui_push_frame(pos, size);
	
	value = sui_slidercontrol(id, [0, 0], size, minmaxsteps, value, sui_slider_noop);
	float maxval = minmaxsteps[1];
	float sliderx = (value / maxval) * size_x;
	sui_fill([0, size_y * 0.25], [size_x, size_y * 0.5], MENU_BG_DARK, 1.0, 0);
	
	float is_active = sui_is_held(id) || (sui_is_hovered(id) && !sui_click_held());
	vector slider_ctrl_color = is_active ? MENU_BUTTON + MENU_HIGHLIGHT * 0.1 : MENU_BUTTON;
	sui_fill([sliderx - 2, 0], [4, size_y], slider_ctrl_color, 1.0, 0);
	
	sui_pop_frame();
};

void(vector pos, vector size, vector minmaxsteps, string cvar_s, string name, string format) cvar_slider =
{
	float current = cvar(cvar_s);
	float old = current;
	sui_push_frame(pos, [size_x, size_y * 0.5 - 4]);
	sui_text([0, 0], MENU_TEXT_SMALL, name, MENU_TEXT_1, 1, 0);
	sui_set_align([SUI_ALIGN_END, SUI_ALIGN_START]);
	sui_text([0, 0], MENU_TEXT_SMALL, sprintf(format, current), MENU_TEXT_1, 1, 0);
	sui_pop_frame();
	my_slider(strcat(cvar_s, "sldr"), [pos_x, pos_y + size_y * 0.5], [size_x, size_y * 0.5], minmaxsteps, current);
	if (current != old) cvar_set(cvar_s, ftos(current));
};

struct name_command {
	string name;
	string command;
};

name_command bindlist[] = 
{
	{ "Forward", "+forward" },
	{ "Back", "+back" },
	{ "Left", "+moveleft" },
	{ "Right", "+moveright" },
	{ "Jump", "+jump" }
};

void(string id, vector pos, vector size, string name, string command) bind_button =
{
	sui_push_frame(pos, size);
	sui_set_align([SUI_ALIGN_START, SUI_ALIGN_CENTER]);
	string key = sui_binder(id, [0, 0], size, name, command);
	if (sui_is_hovered(id)) sui_fill([0, 0], size, MENU_HIGHLIGHT, 0.1, 0);
	sui_text([6, 0], MENU_TEXT_SMALL, name, MENU_TEXT_1, 1, 0);
	sui_set_align([SUI_ALIGN_END, SUI_ALIGN_CENTER]);
	sui_text([-6, 0], MENU_TEXT_SMALL, key, MENU_TEXT_1, 1, 0);
	
	sui_pop_frame();
};


void(string id, vector pos, vector size, __inout vector scrollofs) bind_list =
{
	sui_fill(pos, size, MENU_BG_DARK, 0.75, 0);
	sui_list_view_begin(strcat(id, "scrl"), pos, size, [size_x - 6, 24], bindlist.length, scrollofs, [0, 6]);
	vector listitem_pos = '0 0 0';
	for (float index = sui_list_item(listitem_pos); index > -1; index = sui_list_item(listitem_pos))
	{
		sui_push_frame(listitem_pos, [size_x - 6, 24]);
		bind_button(strcat(id, ftos(index)), [0, 0], [size_x - 6, 24], bindlist[index].name, bindlist[index].command);
		sui_pop_frame();
	}
	sui_list_view_end();	
};


float current_menu;
const float MENU_MAIN = 1;
const float MENU_SETTINGS = 2;
const float MENU_HELP = 3;

vector binds_scroll;
void() settings_menu =
{
	vector pos = [0, 0];
	vector size = [360, 280];
	
	sui_push_frame(pos, size);

	sui_fill([0, 0], size, MENU_BG, 0.75, 0);
	sui_border_box([0, 0], size, 2, MENU_BORDER, 0.3, 0);
	
	sui_set_align([SUI_ALIGN_CENTER, SUI_ALIGN_START]);
	sui_text([0, 4], MENU_TEXT_MEDIUM, "Settings", MENU_TEXT_1, 1, 0);

	
	sui_set_align([SUI_ALIGN_START, SUI_ALIGN_START]);
	
	float xpos = 8;
	float ypos = 32;
	float width = size_x * 0.5 - 8 * 2;
	sui_text([xpos, ypos], MENU_TEXT_SMALL, "Controls", MENU_TEXT_1, 1, 0);
	ypos += 16;
	bind_list("bindlist", [xpos, ypos], [width, 160], binds_scroll);
	ypos += 160 + 8;

	cvar_slider([xpos, ypos], [width, 32], [0.1, 10], "sensitivity", "Sensitivity", "%.2f");
	ypos += 32;

	ypos = 32;
	xpos = 8 + width + 8 + 8;
	
	cvar_slider([xpos, ypos], [width, 32], [0, 1], "volume", "Volume", "%.2f");
	ypos += 32 + 4;
	cvar_slider([xpos, ypos], [width, 32], [0, 1], "musicvolume", "Music Volume", "%.2f");
	ypos += 32 + 4 + 8;
	
	sui_text([xpos, ypos], MENU_TEXT_SMALL, "Video", MENU_TEXT_1, 1, 0);
	ypos += 16;
	my_button("fs_btn", [xpos, ypos], [width, 20], "Fullscreen") ? localcmd("vid_fullscreen 2; vid_restart\n") : 0;
	ypos += 24;
	my_button("wn_btn", [xpos, ypos], [width, 20], "Windowed") ? localcmd("vid_fullscreen 0; vid_width 1024; vid_height 768; vid_restart\n") : 0;
	ypos += 24;
	sui_text([xpos, ypos], MENU_TEXT_SMALL, "Window can be resized.", MENU_TEXT_1, 0.8, 0);
	ypos += 16;
	sui_set_align([SUI_ALIGN_END, SUI_ALIGN_END]);
	my_button("stg_back", [-8, -8], [80, 20], "Back") ? current_menu = MENU_MAIN : 0;
	
	sui_pop_frame();
};

void() help_menu =
{
	vector pos = [0, 0];
	vector size = [360, 280];
	
	sui_push_frame(pos, size);

	sui_fill([0, 0], size, MENU_BG, 0.75, 0);
	sui_border_box([0, 0], size, 2, MENU_BORDER, 0.3, 0);
	
	sui_set_align([SUI_ALIGN_CENTER, SUI_ALIGN_START]);
	sui_text([0, 4], MENU_TEXT_MEDIUM, "Help", MENU_TEXT_1, 1, 0);
	
	float xpos = 0;
	float ypos = 32;
	sui_text([xpos, ypos], MENU_TEXT_SMALL, "Bunch of Help and About", MENU_TEXT_1, 1, 0);
	
	sui_set_align([SUI_ALIGN_END, SUI_ALIGN_END]);
	my_button("hlp_back", [-8, -8], [80, 20], "Back") ? current_menu = MENU_MAIN : 0;

	sui_pop_frame();	
};

void() main_menu =
{
	sui_set_align([SUI_ALIGN_CENTER, SUI_ALIGN_START]);
	sui_text([0, 64], MENU_TEXT_LARGE, "Title Screen", [1, 1, 1], 1, 0);
	
	vector pos = [0, -24];
	vector size = [120, 140];
	sui_set_align([SUI_ALIGN_CENTER, SUI_ALIGN_END]);
	sui_push_frame(pos, size);
	
	sui_fill([0, 0], size, MENU_BG, 0.3, 0);
	sui_border_box([0, 0], size, 2, MENU_BORDER, 0.2, 0);
	
	sui_set_align([SUI_ALIGN_CENTER, SUI_ALIGN_START]);
	
	my_button("mm_start", [0, 8], [size_x - 16, 20], "Start Game") ? localcmd("map test\n") : 0;
	my_button("mm_settings", [0, 8 + 24], [size_x - 16, 20], "Settings") ? current_menu = MENU_SETTINGS : 0;
	my_button("mm_help", [0, 8 + 48], [size_x - 16, 20], "Help") ? current_menu = MENU_HELP : 0;
	sui_set_align([SUI_ALIGN_CENTER, SUI_ALIGN_END]);
	my_button("mm_quit", [0, -8], [size_x - 16, 20], "Quit") ? localcmd("quit\n") : 0;
	sui_pop_frame();	
};

void(vector size) root_menu =
{
	sui_set_align([SUI_ALIGN_CENTER, SUI_ALIGN_CENTER]);
	sui_fill([0, 0], size, '0 0 0', 0.5, 0);
	switch (current_menu)
	{
		case MENU_MAIN: main_menu(); break;
		case MENU_SETTINGS: settings_menu(); break;
		case MENU_HELP: help_menu();
		default: break;
	}
};
//shared definitions

#define printf(x, ...) print(sprintf(x, __VA_ARGS__))


void() precache_everything =
{
	precache_sound("demon/dland2.wav");
	precache_model("models/testplayer.iqm");
};
// Shpuld's Simple UI lib - sui
// Created 11/2018
//
// sui is a simple QuakeC UI lib for drawing and handling game interfaces.
// The API is made simple and easy to build upon, but cuts have been made
// to keep complexity low.
//


#ifdef MENU
const float IE_KEYDOWN = 0;	/* Specifies that a key was pressed. Second argument is the scan code. Third argument is the unicode (printable) char value. Fourth argument denotes which keyboard(or mouse, if its a mouse 'scan' key) the event came from. Note that some systems may completely separate scan codes and unicode values, with a 0 value for the unspecified argument. */
const float IE_KEYUP = 1;	/* Specifies that a key was released. Arguments are the same as IE_KEYDOWN. On some systems, this may be fired instantly after IE_KEYDOWN was fired. */
const float IE_MOUSEDELTA = 2;	/* Specifies that a mouse was moved (touch screens and tablets typically give IE_MOUSEABS events instead, use _windowed_mouse 0 to test code to cope with either). Second argument is the X displacement, third argument is the Y displacement. Fourth argument is which mouse or touch event triggered the event. */
const float IE_MOUSEABS = 3;	/* Specifies that a mouse cursor or touch event was moved to a specific location relative to the virtual screen space. Second argument is the new X position, third argument is the new Y position. Fourth argument is which mouse or touch event triggered the event. */
const float IE_ACCELEROMETER = 4;
const float IE_FOCUS = 5;	/* Specifies that input focus was given. parama says mouse focus, paramb says keyboard focus. If either are -1, then it is unchanged. */
const float IE_JOYAXIS = 6;	/* Specifies that what value a joystick/controller axis currently specifies. x=axis, y=value. Will be called multiple times, once for each axis of each active controller. */

#define printf(x, ...) print(sprintf(x, __VA_ARGS__))

#endif
float _sui_draw_initialized;


// framing

// pseudo windowing, sets a new "frame" for whatever we're drawing, instead of
// always using screen [0, 0] as min and [screen_width, screen_height] as max.
// also allows for aligning content to frame start/end/center on both axis

struct _frame_t {
	vector pos;
	vector size;
	vector align;
};
const float MAX_FRAMES = 64;
_frame_t _frames[MAX_FRAMES];
float _frame_index;

const float SUI_ALIGN_START = 0;
const float SUI_ALIGN_CENTER = 1;
const float SUI_ALIGN_END = 2;

void() sui_reset_align =
{
	_frames[_frame_index].align = [SUI_ALIGN_START, SUI_ALIGN_START];
};

void(float align) sui_set_x_align =
{
	_frames[_frame_index].align.x = align;
};

void(float align) sui_set_y_align =
{
	_frames[_frame_index].align.y = align;
};

void(vector align) sui_set_align =
{
	_frames[_frame_index].align = align;
};

void(__inout vector point) sui_transform_point =
{
	int idx = _frame_index;
	switch (_frames[idx].align.x) 
	{
		case SUI_ALIGN_START:	point_x += _frames[idx].pos.x; break;
		case SUI_ALIGN_CENTER:	point_x += _frames[idx].pos.x + _frames[idx].size.x * 0.5; break;
		case SUI_ALIGN_END:		point_x += _frames[idx].pos.x + _frames[idx].size.x; break;
		default: break;
	}
	switch (_frames[idx].align.y) 
	{
		case SUI_ALIGN_START:	point_y += _frames[idx].pos.y; break;
		case SUI_ALIGN_CENTER:	point_y += _frames[idx].pos.y + _frames[idx].size.y * 0.5; break;
		case SUI_ALIGN_END:		point_y += _frames[idx].pos.y + _frames[idx].size.y; break;
		default: break;
	}
};

void(__inout vector point, vector size) sui_transform_box =
{
	int idx = _frame_index;
	switch (_frames[idx].align.x) 
	{
		case SUI_ALIGN_START:
			point_x += _frames[idx].pos.x; 
			break;
		case SUI_ALIGN_CENTER:
			point_x += _frames[idx].pos.x + _frames[idx].size.x * 0.5 - size_x * 0.5; 
			break;
		case SUI_ALIGN_END:
			point_x += _frames[idx].pos.x + _frames[idx].size.x - size_x; 
			break;
		default: break;
	}
	switch (_frames[idx].align.y) 
	{
		case SUI_ALIGN_START:
			point_y += _frames[idx].pos.y; 
			break;
		case SUI_ALIGN_CENTER:
			point_y += _frames[idx].pos.y + _frames[idx].size.y * 0.5 - size_y * 0.5; 
			break;
		case SUI_ALIGN_END:
			point_y += _frames[idx].pos.y + _frames[idx].size.y - size_y; 
			break;
		default: break;
	}
};

vector() sui_current_frame_pos = 
{ 
	return _frames[_frame_index].pos;
};

vector() sui_current_frame_size =
{
	 return _frames[_frame_index].size;
};

float _sui_is_clipping;
vector _sui_clip_area_mins;
vector _sui_clip_area_maxs; 
void() sui_clip_to_frame =
{
	vector pos = _frames[_frame_index].pos;
	vector size = _frames[_frame_index].size;
	_sui_is_clipping = TRUE;
	_sui_clip_area_mins = pos;
	_sui_clip_area_maxs = pos + size;
	drawsetcliparea(pos.x, pos.y, size.x, size.y);
};

void() sui_reset_clip =
{
	_sui_is_clipping = FALSE;
	drawresetcliparea();
};

float() sui_is_clipping =
{
	return _sui_is_clipping;
};

void(vector pos, vector size) sui_push_frame =
{
	sui_transform_box(pos, size);
	
	_frame_index += 1;
	if (_frame_index >= MAX_FRAMES)
	{
		printf("^3sui warning: amount of frames = %.0f exceeds MAX_FRAMES = %.0f, consider increasing MAX_FRAMES\n", _frame_index, MAX_FRAMES);
		return;
	}
	
	_frames[_frame_index].pos = pos;
	_frames[_frame_index].size = size;
	_frames[_frame_index].align = [SUI_ALIGN_START, SUI_ALIGN_START]; // TODO allow customizing this
};

void() sui_pop_frame =
{
	if (_frame_index > 0) _frame_index -= 1;
};

void() sui_reset_frame = 
{
	_frame_index = 0;
	sui_reset_align();
};


// actions

// interaction for sui elements, relies a lot on reading globals to see which
// element id is under cursor or held or whatever, not the most elegant
// solution but in this highly imperative world of QuakeC we can live with it

float _holding_click;
vector _cursor_click;
vector _cursor_position;
vector _cursor_relative_click;
vector _cursor_relative_hover;
struct _action_element_t {
	vector pos;
	vector size;
	string id;
	void(float index, vector click_ratios) action;
};
const float MAX_ACTION_ELEMENTS = 256;
_action_element_t _action_elements[MAX_ACTION_ELEMENTS];
float _action_elements_index;


// TODO better naming
float(vector point, vector min, vector max) is_2dpoint_in_bounds =
{
	if (point_x <= min_x || point_y <= min_y) return FALSE;
	if (point_x > max_x || point_y > max_y) return FALSE;
	return TRUE;
};

// TODO better naming
float(vector point, vector pos, vector size) is_2dpoint_in_bbox =
{
	return is_2dpoint_in_bounds(point, pos, pos + size);
};

void() _action_element_count_sanity =
{
	if (_action_elements_index > MAX_ACTION_ELEMENTS)
	{
		// let the user know if they're hitting the bounds
		printf("^3sui warning: amount of action elements = %.0f exceeds MAX_ACTION_ELEMENTS = %.0f, consider increasing MAX_ACTION_ELEMENTS\n", _action_elements_index, MAX_ACTION_ELEMENTS);
	}
};

const float MAX_MOUSE_ACTIONS = 16;
string _hover_actions[MAX_MOUSE_ACTIONS];
string _click_actions[MAX_MOUSE_ACTIONS];
string _hold_actions[MAX_MOUSE_ACTIONS];
string _release_actions[MAX_MOUSE_ACTIONS];
string _last_clicked_actions[MAX_MOUSE_ACTIONS];

float _hover_action_count;
float _click_action_count;
float _hold_action_count;
float _release_action_count;
float _last_clicked_action_count;


// Resets things you might want to persist normally
void() sui_reset_actions =
{
	_hover_action_count = 0;
	_click_action_count = 0;
	_hold_action_count = 0;
	_release_action_count = 0;
	_last_clicked_action_count = 0;
	_holding_click = FALSE;
};

// Per frame reset?
void() sui_reset_click =
{
	_hold_action_count = 0;
	_click_action_count = 0;
	_holding_click = FALSE;
};

float() sui_click_held = { return _holding_click; };


// click: on mouse1 button down AND button op, once

// Returns true if id was the topmost click (what usually is cared about the most)
float(string id) sui_is_clicked =
{
	return _click_action_count > 0 && _click_actions[0] == id;
};

// Returns the index of the clicked id, -1 if wasn't hit at all. 0 is topmost
float(string id) sui_click_index =
{
	for (int i = 0; i < _click_action_count; i++)
	{
		if (_click_actions[i] == id) return i;
	}
	return -1;
};


// hover: mouse is on top of the action element id

float(string id) sui_is_hovered =
{
	return _hover_action_count > 0 && _hover_actions[0] == id;
};

float(string id) sui_hover_index =
{
	for (int i = 0; i < _hover_action_count; i++)
	{
		if (_hover_actions[i] == id) return i;
	}
	return -1;
};


// hold: mouse button was clicked on top of this id and is held down, but not necessarily over this id anymore

float(string id) sui_is_held =
{
	return _hold_action_count > 0 && _hold_actions[0] == id;
};

float(string id) sui_hold_index =
{
	for (int i = 0; i < _hold_action_count; i++)
	{
		if (_hold_actions[i] == id) return i;
	}
	return -1;
};


// last clicked: is this the last action element that was clicked, good for focusing on input boxes for example

float(string id) sui_is_last_clicked =
{
	return _last_clicked_action_count > 0 && _last_clicked_actions[0] == id;
};

float(string id) sui_last_clicked_index =
{
	for (int i = 0; i < _last_clicked_action_count; i++)
	{
		if (_last_clicked_actions[i] == id) return i;
	}
	return -1;
};


// release: a thing was held, but now it was released, once

float(string id) sui_is_released =
{
	return _release_action_count > 0 && _release_actions[0] == id;
};

float(string id) sui_release_index =
{
	for (int i = 0; i < _release_action_count; i++)
	{
		if (_release_actions[i] == id) return i;
	}
	return -1;
};


float(float num) mouse_action_sanity =
{
	if (num >= MAX_MOUSE_ACTIONS)
	{
		printf("^3sui warning: you have exceeded the amount of overlapping action elements with %.0f, MAX_MOUSE_ACTIONS = %.0f\n", num, MAX_MOUSE_ACTIONS);
		return TRUE;
	}
	return FALSE;
};

// mouse move, mostly just update hovers

void(vector pos) _sui_mouse_move =
{
	_cursor_position = pos;
	_action_element_count_sanity();
	
	// Reset hover, it'll be back to what it used to be before draw gets called if mouse is still on same element
	_hover_action_count = 0;
	
	// Iterate front to back, so topmost element gets the click/hover
	for (int i = min(MAX_ACTION_ELEMENTS, _action_elements_index) - 1; i >= 0; i--)
	{
		if (is_2dpoint_in_bbox(_cursor_position, _action_elements[i].pos, _action_elements[i].size))
		{
			if (mouse_action_sanity(_hover_action_count)) break;
			
			if (_hover_action_count == 0) _cursor_relative_hover = _cursor_position - _action_elements[i].pos; 
			_hover_actions[_hover_action_count] = _action_elements[i].id;
			_hover_action_count += 1;
		}
	}
};

// JERK ALERT: hard to pass input params for it without them just being the globals
// ... so it just straight up uses the globals... optimization
void() _sui_mouse1_down =
{
	// Cheap but it should work...
	_cursor_click = _cursor_position;
	_cursor_relative_click = _cursor_relative_hover;
	for (int i = 0; i < _hover_action_count; i++) _hold_actions[i] = _hover_actions[i];
	_hold_action_count = _hover_action_count;
	_holding_click = TRUE;
	_last_clicked_action_count = 0;
};

void() _sui_mouse1_up =
{
	// Can't be cheap here, we have to get the action fn of the element anyway so..
	_action_element_count_sanity();
	
	// Assume we won't hit anything
	_click_action_count = 0;
	_last_clicked_action_count = 0;
	
	// Iterate front to back, so topmost element gets the click/hover
	for (int i = min(MAX_ACTION_ELEMENTS, _action_elements_index) - 1; i >= 0; i--)
	{
		// If the thing wasn't the same thing we started pressing down on, ignore
		for (int j = 0; j < _hold_action_count; j++)
		{
			if (_hold_actions[j] == _action_elements[i].id) // yes this element was held
			{		
				// Still in bounds?
				if (is_2dpoint_in_bbox(_cursor_position, _action_elements[i].pos, _action_elements[i].size))
				{
					if (mouse_action_sanity(_click_action_count)) break;
					
					// Register click
					_click_actions[_click_action_count] = _action_elements[i].id;
					_last_clicked_actions[_last_clicked_action_count] = _action_elements[i].id;
					_click_action_count += 1;
					_last_clicked_action_count += 1;
				}
			}
		}
	}
	
	// In case someone is keeping state on hold and wants to do stuff on release, even if cursor has moved
	for (int i = 0; i < _hold_action_count; i++) _release_actions[i] = _hold_actions[i];
	_release_action_count = _hold_action_count;
	_hold_action_count = 0;
	_holding_click = FALSE;
};

void(vector pos, vector size, string id, void(float index, vector click_ratios) action) sui_action_element =
{
	if (!_sui_draw_initialized) 
	{
		print("^1sui error: adding sui elements before sui_pre_draw!\n^1  Always do your sui menus between sui_pre_draw and sui_draw!\n");
	}
	if (_action_elements_index >= MAX_ACTION_ELEMENTS)
	{
		// Silently fail here, sui will let us know another way, increase the count
		// so that the error in click/mousemove handlers prints correct numbers.
		_action_elements_index += 1;
		return;
	}
	
	sui_transform_box(pos, size);
	
	if (_sui_is_clipping)
	{
		vector oldpos = pos;
		pos_x = max(pos_x, _sui_clip_area_mins_x);
		pos_y = max(pos_y, _sui_clip_area_mins_y);
		
		size -= pos - oldpos;
		
		size_x -= bound(0, (pos_x + size_x - _sui_clip_area_maxs_x), size_x);
		size_y -= bound(0, (pos_y + size_y - _sui_clip_area_maxs_y), size_y);
	}
	
	_action_elements[_action_elements_index].pos = pos;
	_action_elements[_action_elements_index].size = size;
	_action_elements[_action_elements_index].id = id;
	_action_elements[_action_elements_index].action = action;
	
	_action_elements_index += 1;
};


// Input related stuff

string _sui_binding_command;
string _sui_binding_command_name;

struct _input_t {
	float char;
	float scan;
};
const float MAX_INPUTS = 64;

_input_t _input_buffer[MAX_INPUTS];
float _input_index;
float _input_length;


// probably good to use it like while (sui_get_input(char, scan)) { ... };
float(__inout float char, __inout float scan) sui_get_input =
{
	if (_input_index >= _input_length) return FALSE;
	
	char = _input_buffer[_input_index].char;
	scan = _input_buffer[_input_index].scan;
	_input_index++;
	
	return TRUE;
};

// if 2 controls want to read the same input for some reason..
void() sui_reread_input =
{
	_input_index = 0;
};

void() sui_clear_input =
{
	_input_length = 0;
	_input_index = 0;
};

float(float char, float scan) _sui_add_input =
{
	// TODO check if input was listened, return FALSE if not
	if (_input_length >= MAX_INPUTS)
	{
		printf("^3sui warning: exceeded amount of per frame inputs count MAX_INPUTS = %.0f\n"
			"^3 - make sure sui_input_event isn't being called without sui_draw being called in update loop\n"
			"^3 - consider increasing MAX_INPUTS\n", MAX_INPUTS);
		return TRUE;
	}
	_input_buffer[_input_length].char = char;
	_input_buffer[_input_length].scan = scan;
	_input_length += 1;
	return TRUE;
};

// Listen to a certain keycode if it was pressed, this way sui know it was requested
float(float keycode) sui_listen_keycode_down =
{
	return FALSE;
};

// all text that was input between last and current frame
string() sui_listen_text_input =
{
	return "";
};

void(float char, float scan, __inout string text, __inout float cursor) sui_handle_text_input =
{
	float maxlen = 128;
	
	string prev = text;
	string pre_cursor, post_cursor;
	float length = strlen(prev);
	if (char > 31 && char < 128) //an actual input
	{
		if (length >= maxlen) return;
		pre_cursor = substring(prev, 0, cursor);
		post_cursor = substring(prev, cursor, length);
		
		text = sprintf("%s%s%s", pre_cursor, chr2str(char), post_cursor);
		cursor += 1;
	}
	else if (char == 8) // backspace
	{
		if (cursor <= 0) return;
		pre_cursor = substring(prev, 0, cursor - 1);
		post_cursor = substring(prev, cursor, length);
		cursor -= 1;
		cursor = max(0, cursor);
		text = strcat(pre_cursor, post_cursor);
	}
	else if (scan == K_DEL)
	{
		if (cursor >= length) return;
		pre_cursor = substring(prev, 0, cursor);
		post_cursor = substring(prev, cursor + 1, length);
		text = strcat(pre_cursor, post_cursor);
	}
	else if (char == 13 || char == 27) // enter or escape
	{
		// Commit and deselect...
		// Let's try a hack..
		_last_clicked_action_count = 0;
	}
	else if (scan == K_LEFTARROW)
	{
		cursor -= 1;
		cursor = max(0, cursor);
	}
	else if (scan == K_RIGHTARROW)
	{
		cursor += 1;
		cursor = min(strlen(prev), cursor);
	}
};

void(float maxlen, __inout string text, __inout float cursor) sui_cap_input_length =
{
	if (strlen(text) > maxlen)
	{
		text = substring(text, 0, strlen(text));
		cursor = strlen(text);
	}
};

void(string command) _sui_unbind =
{
	tokenize(findkeysforcommand(command));
	string keyname = keynumtostring(stof(argv(0)));
	string altkeyname = keynumtostring(stof(argv(1)));
	localcmd(sprintf("unbind %s\n", keyname));
	localcmd(sprintf("unbind %s\n", altkeyname));
};

void(float scan, string command) _sui_do_keybind =
{
	if (scan == K_ESCAPE) 
	{
		_sui_binding_command = "";
		_sui_binding_command_name = "";
		return;
	}
	if (scan == K_BACKSPACE)
	{
		_sui_unbind(command);
		_sui_binding_command = "";
		_sui_binding_command_name = "";
		return;
	}
	string keyname = keynumtostring(scan);
	_sui_unbind(command);
	localcmd(sprintf("bind %s %s\n", keyname, command));
	_sui_binding_command = "";
	_sui_binding_command_name = "";
};

void(string command, string command_name) sui_start_bind =
{
	_sui_binding_command = command;
	_sui_binding_command_name = command_name;
};

// void(float evtype, float scanx, float chary, float devid) sui_input_event
//	 same args is CSQC_InputEvent.
//	 return value tells you if sui used the event or not, in case you want to
//	 not let engine handle it if it was used.
// Sets all the internal sui action stuff, call it in CSQC_InputEvent
float(float evtype, float scanx, float chary, float devid) sui_input_event =
{
	switch (evtype)
	{
	case IE_MOUSEABS:
		_sui_mouse_move([scanx, chary]);
		return TRUE;
		break;
	case IE_MOUSEDELTA:
		// Big question mark...
		// maybe make our own delta based sui_cursor here..
		// maybe just ignore delta and let user fake mouseabs with their own
		// delta cursor by passing different params to this func...?
		// for MVP let's just use mouseabs only
		return FALSE;
		break;
	case IE_KEYDOWN:
		if (_sui_binding_command != "")
		{
			// Nothing
			return TRUE;
		}
		else if (scanx == K_MOUSE1)
		{
			_sui_mouse1_down();
			return TRUE;
		}
		else
		{
			if ((scanx == K_ESCAPE || scanx == K_BACKSPACE) && _sui_binding_command != "")
				return TRUE;
			else if (scanx == K_ESCAPE)
				return FALSE;
			return _sui_add_input(chary, scanx);
		}
		break;
	case IE_KEYUP:
		if (_sui_binding_command != "")
		{
			_sui_do_keybind(scanx, _sui_binding_command);
			return TRUE;
		}
		else if (scanx == K_MOUSE1)
		{
			_sui_mouse1_up();
			return TRUE;
		}
		break;
	default: 
		break;
	}
	
	return FALSE;
};


// void() sui_pre_draw 
// Resets state for sui actions so that no trouble happens. 
// Call it before your menu code per frame in your draw/updateview.
void(float width, float height) sui_begin =
{
	_action_elements_index = 0;
	_sui_draw_initialized = TRUE;
	
	sui_reset_frame();
	sui_push_frame([0, 0], [width, height]);
}

void() sui_draw_bind_overlay;

// void() sui_end
// Call after your menu code per frame in your draw/updateview.
void() sui_end =
{
	// Todo: move overlay drawing elsewhere:
	sui_draw_bind_overlay();
	// Dirty part:
	_sui_draw_initialized = FALSE;
	// reset "once" type actions
	_click_action_count = 0;
	_release_action_count = 0;
	// empty input buffer
	sui_clear_input();
};


// Different draw components:

void(vector pos, vector size, vector color, float alpha, float flags) sui_fill =
{
	sui_transform_box(pos, size);
	
	drawfill(pos, size, color, alpha, flags);
};

void(vector pos, vector size, string pic, vector color, float alpha, float flags) sui_pic =
{
	sui_transform_box(pos, size);
	
	drawpic(pos, pic, size, color, alpha, flags);
};

void(vector pos, vector size, float width, vector color, float alpha, float flags) sui_border_box =
{
	sui_transform_box(pos, size);
	
	// Top line
	drawfill(pos, [size_x, width], color, alpha, flags);
	// Bottom line
	drawfill([pos_x, pos_y + size_y - width], [size_x, width], color, alpha, flags);
	// Left line
	drawfill([pos_x, pos_y + width], [width, size_y - width * 2], color, alpha, flags);
	// Right line
	drawfill([pos_x + size_x - width, pos_y + width], [width, size_y - width * 2], color, alpha, flags);
};


void(vector pos, vector size, string text, vector color, float alpha, float flags) sui_text =
{
	sui_transform_box(pos, [stringwidth(text, 1, size), size_y]);
	
	drawstring(pos, text, size, color, alpha, flags);
};

void(float index, vector click_ratios) sui_noop = {};

void(float value) sui_slider_noop = {};

float(string id, vector pos, vector size, vector minmaxsteps, float value, void(float value) action) sui_slidercontrol =
{
	sui_action_element(pos, size, id, sui_noop);
	float newvalue = value;
	
	sui_transform_box(pos, size);
	// user is clicking and holding the slider
	if (sui_is_held(id))
	{
		float min = minmaxsteps[0];
		float max = minmaxsteps[1];
		float steps = minmaxsteps[2];
		float click_ratio = (_cursor_position_x - pos_x) / size_x;
		click_ratio = bound(0, click_ratio, 1);
		if (steps > 0) click_ratio = rint(click_ratio * steps) / steps;
		newvalue = min + click_ratio * (max - min);
		if (newvalue != value) action(newvalue);
	}
	return newvalue;
};

void(string id, vector pos, vector size, __inout string text, __inout float cursor) sui_text_input =
{
	sui_action_element(pos, size, id, sui_noop);
	if (sui_is_clicked(id)) cursor = strlen(text);
	if (sui_is_last_clicked(id))
	{
		float char = 0;
		float scan = 0;
		while(sui_get_input(char, scan)) sui_handle_text_input(char, scan, text, cursor);
	}
};


void(string id, vector size, vector contentsize, __inout vector offset, vector scrollbar_widths) sui_scrollbar =
{
	vector maxoffset = contentsize - size;
	maxoffset_x = max(0, maxoffset_x);
	maxoffset_y = max(0, maxoffset_y);
	sui_push_frame([0, 0], size);
	float ofs;
	float length;
	vector barpos, barsize;
	float scan = 0;
	float char = 0;
	string barname;
	if (maxoffset_y > 0 && contentsize_y > 0)
	{
		sui_set_align([SUI_ALIGN_END, SUI_ALIGN_START]);
		sui_push_frame([0, 0], [scrollbar_widths_y, size_y]);
		ofs = (offset_y / contentsize_y) * size_y;
		length = (size_y / contentsize_y) * size_y;
		barpos = [0, ofs];
		barsize = [scrollbar_widths_y, length];
		barname = strcat(id, "vbar");
		
		if (sui_is_held(barname))
		{
			vector anchor = barpos + _cursor_relative_click;
			sui_transform_point(anchor);
			float diff = _cursor_position_y - anchor_y;
			offset_y += (diff * contentsize_y) / size_y; //  * contentsize_y; // (size_y / contentsize_y);
		}

		sui_fill(barpos, barsize, '0.1 0.1 0.1' * (1 - sui_is_hovered(barname)), 0.66, 0);
		sui_action_element(barpos, barsize, barname, sui_noop);
		sui_pop_frame();
	} 
	sui_pop_frame();
};

void(string id, vector pos, vector size, vector contentsize, __inout vector offset, vector scrollbar_widths) sui_scroll_view_begin =
{
	// make space for scrollbars
	sui_push_frame(pos, size - [scrollbar_widths_y, scrollbar_widths_x]);
	sui_action_element([0, 0], size, id, sui_noop);
	
	if (sui_hover_index(id) > -1)
	{		
		float scrollamount = 0;
		float char = 0;
		float scan = 0;
		sui_reread_input();
		while (sui_get_input(char, scan))
		{
			if (scan == K_MWHEELUP) scrollamount -= 20;
			if (scan == K_MWHEELDOWN) scrollamount += 20;
		}
		offset_y += scrollamount;
	}
	
	vector maxoffset = contentsize - size;
	maxoffset_x = max(0, maxoffset_x);
	maxoffset_y = max(0, maxoffset_y);
	offset_x = bound(0, offset_x, maxoffset_x);
	offset_y = bound(0, offset_y, maxoffset_y);

	sui_scrollbar(id, size, contentsize, offset, scrollbar_widths);
	
	offset_x = bound(0, offset_x, maxoffset_x);
	offset_y = bound(0, offset_y, maxoffset_y);
	
	sui_clip_to_frame();
	

	sui_push_frame(-1 * offset, contentsize);
};

void() sui_scroll_view_end =
{
	sui_pop_frame();
	sui_reset_clip();
	sui_pop_frame();
};

float _sui_list_item_height;
float _sui_list_first;
float _sui_list_last;
float _sui_list_pos;
int _sui_list_index;
void(string id, vector pos, vector size, vector itemsize, float numitems, __inout vector offset, vector scrollbar_widths) sui_list_view_begin =
{
	vector contentsize = [itemsize_x, itemsize_y * numitems];
	sui_scroll_view_begin(id, pos, size, contentsize, offset, scrollbar_widths);
	
	_sui_list_item_height = itemsize_y;
	float hidden_above = floor(offset_y / itemsize_y);
	_sui_list_first = max(0, hidden_above); // Index of first elem
	_sui_list_last = min(_sui_list_first + rint(size_y / itemsize_y) + 1, numitems);
	_sui_list_pos = hidden_above * itemsize_y;
	_sui_list_index = _sui_list_first;
};

float(__inout vector pos) sui_list_item =
{
	if (_sui_list_index >= _sui_list_last) return -1;
	pos = _sui_list_index * [0, _sui_list_item_height];
	_sui_list_index += 1;
	return _sui_list_index - 1;
};

void() sui_list_view_end =
{
	sui_scroll_view_end();
};

string(string id, vector pos, vector size, string name, string command) sui_binder =
{
	sui_action_element(pos, size, id, sui_noop);
	if (sui_is_released(id))
	{
		sui_start_bind(command, name);
	}
	
	tokenize(findkeysforcommand(command));
	string keyname = keynumtostring(stof(argv(0)));
	if (keyname == "01") keyname = "unbound";
	
	return keyname;
};

void() sui_draw_bind_overlay =
{
	if (_sui_binding_command != "")
	{
		vector size = sui_current_frame_size();
		sui_fill([0, 0], size, '0 0 0', 0.5, 0);
		sui_set_align([SUI_ALIGN_CENTER, SUI_ALIGN_CENTER]);
		float textsize = 16;
		sui_text([0, -16], [textsize, textsize], "Press a key for", '1 1 1', 1, 0);
		sui_text([0, 0], [textsize, textsize], sprintf("'%s'", _sui_binding_command_name), '1 1 1', 1, 0);
		sui_text([0, 16], [textsize - 4, textsize - 4], "ESC to cancel, BACKSPACE to remove", '1 1 1', 1, 0);
	}
};


// -------------------- END OF SUI SYSTEM STUFF --------------------
// put custom server-only globals and fields here

const float FL_JUMPRELEASED = 4096;

void() sub_remove =
{
	remove(self);
};

void() sub_noop = {};

void(float event) BeginEvent =
{
	WriteByte(MSG_MULTICAST, SVC_CGAMEPACKET);
	WriteByte(MSG_MULTICAST, event);
};

void(vector vec) MulticastVector =
{
	WriteCoord(MSG_MULTICAST, vec_x);
	WriteCoord(MSG_MULTICAST, vec_y);
	WriteCoord(MSG_MULTICAST, vec_z);
};

void(float val) MulticastByte =
{
	WriteByte(MSG_MULTICAST, val);
};

void(float val) MulticastShort =
{
	WriteShort(MSG_MULTICAST, val);
};

void(float val) MulticastFloat =
{
	WriteFloat(MSG_MULTICAST, val);
};

void(entity e) MulticastEnt =
{
	WriteEntity(MSG_MULTICAST, e);
};

void(string s) MulticastString =
{
	WriteString(MSG_MULTICAST, s);
};

void() light =
{
	remove(self);
};

entity player_chain_head;
.entity player_chain_next;
.entity player_chain_prev;

// Put an entity as the first of the linked list
void(entity adding) player_chain_add =
{
	if (adding.player_chain_prev || adding.player_chain_next || (adding == player_chain_head && !adding.player_chain_next)) 
	{
		print("Trying to adding an entity into player chain while it already is in chain!\n");
		return;
	}
	if (player_chain_head) player_chain_head.player_chain_prev = adding;
	adding.player_chain_next = player_chain_head;
	player_chain_head = adding;
};

// Remove entity from linked list
void(entity removing) player_chain_remove =
{
	if (removing == player_chain_head)
	{
		player_chain_head = removing.player_chain_next;
	}
	
	if (removing.player_chain_next) removing.player_chain_next.player_chain_prev = removing.player_chain_prev;
	if (removing.player_chain_prev) removing.player_chain_prev.player_chain_next = removing.player_chain_next;
	removing.player_chain_next = world;
	removing.player_chain_prev = world;
};

/*
This file was automatically generated by FTE Quake v1.06
This file can be regenerated by issuing the following command:
pr_dumpplatform -O ssdefs -Tqw -Ffte
Available options:
-Ffte       - target only FTE (optimations and additional extensions)
-Tnq        - dump specifically NQ fields
-Tqw        - dump specifically QW fields
-Tcs        - dump specifically CSQC fields
-Tmenu      - dump specifically menuqc fields
-Fdefines   - generate #defines instead of constants
-Faccessors - use accessors instead of basic types via defines
-O          - write to a different qc file
*/
#pragma noref 1
//#pragma flag enable logicops
#pragma warning error Q101 /*too many parms*/
#pragma warning error Q105 /*too few parms*/
#pragma warning error Q106 /*assignment to constant/lvalue*/
#pragma warning error Q208 /*system crc unknown*/
#pragma warning disable F211 /*system crc outdated (eg: dp's csqc)*/
#pragma warning enable F301 /*non-utf-8 strings*/
#pragma warning enable F302 /*uninitialised locals*/
#pragma target FTE
#ifndef QUAKEWORLD
#define QUAKEWORLD
#endif
#ifndef QWSSQC
#define QWSSQC
#endif
#ifndef SSQC
#define SSQC
#endif
#define FTE_PEXT_SETVIEW /* NQ's svc_setview works correctly even in quakeworld */
#define DP_ENT_SCALE
#define FTE_PEXT_LIGHTSTYLECOL
#define DP_ENT_ALPHA
#define FTE_PEXT_VIEW2
#define FTE_PEXT_ACURATETIMINGS
#define FTE_PEXT_SOUNDDBL
#define FTE_PEXT_FATNESS
#define DP_HALFLIFE_MAP
#define FTE_PEXT_TE_BULLET
#define FTE_PEXT_HULLSIZE
#define FTE_PEXT_MODELDBL
#define FTE_PEXT_ENTITYDBL
#define FTE_PEXT_ENTITYDBL2
#define FTE_PEXT_FLOATCOORDS
#define FTE_PEXT_VWEAP
#define FTE_PEXT_Q2BSP
#define FTE_PEXT_Q3BSP
#define DP_ENT_COLORMOD
#define FTE_HEXEN2
#define FTE_PEXT_SPAWNSTATIC
#define FTE_PEXT_CUSTOMTENTS
#define FTE_PEXT_256PACKETENTITIES
#define TEI_SHOWLMP2
#define DP_GFX_QUAKE3MODELTAGS
#define FTE_PK3DOWNLOADS
#define PEXT_CHUNKEDDOWNLOADS
#define EXT_CSQC_SHARED
#define PEXT_DPFLAGS
#define EXT_CSQC
#define BX_COLOREDTEXT
#define DP_CON_SET /* The 'set' console command exists, and can be used to create/set cvars. */
#define DP_CON_SETA /* The 'seta' console command exists, like the 'set' command, but also marks the cvar for archiving, allowing it to be written into the user's config. Use this command in your default.cfg file. */
#define DP_EF_ADDITIVE
#define DP_EF_BLUE
#define DP_EF_FULLBRIGHT
#define DP_EF_NODEPTHTEST
#define DP_EF_NODRAW
#define DP_EF_NOGUNBOB
#define DP_EF_NOSHADOW
#define DP_EF_RED
#define DP_ENT_CUSTOMCOLORMAP
#define DP_ENT_EXTERIORMODELTOCLIENT
#define DP_ENT_TRAILEFFECTNUM /* self.traileffectnum=particleeffectnum("myeffectname"); can be used to attach a particle trail to the given server entity. This is equivelent to calling trailparticles each frame. */
#define DP_ENT_VIEWMODEL
#define DP_GECKO_SUPPORT
#define DP_GFX_FONTS
#define DP_GFX_SKINFILES
#define DP_GFX_SKYBOX
#define DP_HALFLIFE_MAP_CVAR
#define DP_INPUTBUTTONS
#define DP_LIGHTSTYLE_STATICVALUE
#define DP_LITSUPPORT
#define DP_MD3_TAGSINFO
#define DP_MONSTERWALK /* MOVETYPE_WALK is valid on non-player entities. Note that only players receive acceleration etc in line with none/bounce/fly/noclip movetypes on the player, thus you will have to provide your own accelerations (incluing gravity) yourself. */
#define DP_MOVETYPEBOUNCEMISSILE
#define DP_MOVETYPEFOLLOW
#define DP_QC_ASINACOSATANATAN2TAN
#define DP_QC_CHANGEPITCH
#define DP_QC_COPYENTITY
#define DP_QC_CRC16
#define DP_QC_CVAR_DEFSTRING
#define DP_QC_CVAR_STRING
#define DP_QC_CVAR_TYPE
#define DP_QC_EDICT_NUM
#define DP_QC_ENTITYDATA
#define DP_QC_ETOS
#define DP_QC_FINDCHAIN
#define DP_QC_FINDCHAINFLOAT
#define DP_QC_FINDFLAGS
#define DP_QC_FINDCHAINFLAGS
#define DP_QC_FINDFLOAT
#define DP_QC_FS_SEARCH
#define DP_QC_GETSURFACE
#define DP_QC_GETSURFACEPOINTATTRIBUTE
#define DP_QC_MINMAXBOUND
#define DP_QC_MULTIPLETEMPSTRINGS /* Superseded by DP_QC_UNLIMITEDTEMPSTRINGS. Functions that return a temporary string will not overwrite/destroy previous temporary strings until at least 16 strings are returned (or control returns to the engine). */
#define DP_QC_RANDOMVEC
#define DP_QC_RENDER_SCENE /* clearscene+addentity+setviewprop+renderscene+setmodel are available to menuqc. WARNING: DP advertises this extension without actually supporting it, FTE does actually support it. */
#define DP_QC_SINCOSSQRTPOW
#define DP_QC_SPRINTF /* Provides the sprintf builtin, which allows for rich formatting along the lines of C's function with the same name. Not to be confused with QC's sprint builtin. */
#define DP_QC_STRFTIME
#define DP_QC_STRING_CASE_FUNCTIONS
#define DP_QC_STRINGBUFFERS
#define DP_QC_STRINGCOLORFUNCTIONS
#define DP_QC_STRREPLACE
#define DP_QC_TOKENIZEBYSEPARATOR
#define DP_QC_TRACEBOX
#define DP_QC_TRACETOSS
#define DP_QC_TRACE_MOVETYPE_HITMODEL
#define DP_QC_TRACE_MOVETYPE_WORLDONLY
#define DP_QC_TRACE_MOVETYPES
#define DP_QC_UNLIMITEDTEMPSTRINGS /* Supersedes DP_QC_MULTIPLETEMPSTRINGS, superseded by FTE_QC_PERSISTENTTEMPSTRINGS. Specifies that all temp strings will be valid at least until the QCVM returns. */
#define DP_QC_URI_ESCAPE
#define DP_QC_URI_GET
#define DP_QC_URI_POST
#define DP_QC_VECTOANGLES_WITH_ROLL
#define DP_QC_VECTORVECTORS
#define DP_QC_WHICHPACK
#define DP_QUAKE2_MODEL
#define DP_QUAKE2_SPRITE
#define DP_QUAKE3_MODEL
#define DP_REGISTERCVAR
#define DP_SND_SOUND7_WIP2
#define DP_SND_STEREOWAV
#define DP_SND_OGGVORBIS
#define DP_SOLIDCORPSE
#define DP_SPRITE32
#define DP_SV_BOTCLIENT
#define DP_SV_CLIENTCOLORS /* Provided only for compatibility with DP. */
#define DP_SV_CLIENTNAME /* Provided only for compatibility with DP. */
#define DP_SV_DRAWONLYTOCLIENT
#define DP_SV_DROPCLIENT /* Equivelent to quakeworld's stuffcmd(self,"disconnect\n"); hack */
#define DP_SV_EFFECT
#define DP_SV_EXTERIORMODELFORCLIENT
#define DP_SV_NODRAWTOCLIENT
#define DP_SV_PLAYERPHYSICS /* Allows reworking parts of NQ player physics. USE AT OWN RISK - this necessitates NQ physics and is thus guarenteed to break prediction. */
#define DP_SV_POINTSOUND
#define DP_SV_PRECACHEANYTIME /* Specifies that the various precache builtins can be called at any time. WARNING: precaches are sent reliably while sound events, modelindexes, and particle events are not. This can mean sounds and particles might not work the first time around, or models may take a while to appear (after the reliables are received and the model is loaded from disk). Always attempt to precache a little in advance in order to reduce these issues (preferably at the start of the map...) */
#define DP_SV_PRINT /* Says that the print builtin can be used from nqssqc (as well as just csqc), bypassing the developer cvar issues. */
#define DP_SV_SETCOLOR
#define DP_SV_SPAWNFUNC_PREFIX
#define DP_SV_WRITEPICTURE
#define DP_SV_WRITEUNTERMINATEDSTRING
#define DP_TE_BLOOD
#define DP_TE_CUSTOMFLASH
#define DP_TE_EXPLOSIONRGB
#define DP_TE_PARTICLECUBE
#define DP_TE_PARTICLERAIN
#define DP_TE_PARTICLESNOW
#define DP_TE_SMALLFLASH
#define DP_TE_SPARK
#define DP_TE_STANDARDEFFECTBUILTINS
#define DP_VIEWZOOM
#define EXT_BITSHIFT
#define EXT_DIMENSION_VISIBILITY
#define EXT_DIMENSION_PHYSICS
#define EXT_DIMENSION_GHOST
#define FRIK_FILE
#define FTE_CALLTIMEOFDAY /* Replication of mvdsv functionality (call calltimeofday to cause 'timeofday' to be called, with arguments that can be saved off to a global). Generally strftime is simpler to use. */
#define FTE_CSQC_ALTCONSOLES /* The engine tracks multiple consoles. These may or may not be directly visible to the user. */
#define FTE_CSQC_BASEFRAME /* Specifies that .basebone, .baseframe2, .baselerpfrac, baseframe1time, etc exist in csqc. These fields affect all bones in the entity's model with a lower index than the .basebone field, allowing you to give separate control to the legs of a skeletal model, without affecting the torso animations. */
#define FTE_CSQC_HALFLIFE_MODELS
#define FTE_CSQC_SERVERBROWSER /* Provides builtins to query the engine's serverbrowser servers list from ssqc. Note that these builtins are always available in menuqc. */
#define FTE_CSQC_SKELETONOBJECTS /* Provides container objects for skeletal bone data, which can be modified on a per bone basis if needed. This allows you to dynamically generate animations (or just blend them with greater customisation) instead of being limited to a single animation or two. */
#define FTE_CSQC_RAWIMAGES /* Provides raw rgba image access to csqc. With this, the csprogs can read textures into qc-accessible memory, modify it, and then upload it to the renderer. */
#define FTE_CSQC_RENDERTARGETS /* VF_RT_DESTCOLOUR exists and can be used to redirect any rendering to a texture instead of the screen. */
#define FTE_CSQC_REVERB /* Specifies that the mod can create custom reverb effects. Whether they will actually be used or not depends upon the sound driver. */
#define FTE_CSQC_WINDOWCAPTION /* Provides csqc with the ability to change the window caption as displayed when running windowed or in the task bar when switched out. */
#define FTE_ENT_SKIN_CONTENTS /* self.skin = CONTENTS_WATER; makes a brush entity into water. use -16 for a ladder. */
#define FTE_ENT_UNIQUESPAWNID
#define FTE_EXTENDEDTEXTCODES
#define FTE_FORCESHADER /* Allows csqc to override shaders on models with an explicitly named replacement. Also allows you to define shaders with a fallback if it does not exist on disk. */
#define FTE_FORCEINFOKEY /* Provides an easy way to change a user's userinfo from the server. */
#define FTE_GFX_QUAKE3SHADERS /* specifies that the engine has full support for vanilla quake3 shaders */
#define FTE_GFX_REMAPSHADER /* With the raw power of stuffcmds, the r_remapshader console command is exposed! This mystical command can be used to remap any shader to another. Remapped shaders that specify $diffuse etc in some form will inherit the textures implied by the surface. */
#define FTE_GFX_MODELEVENTS /* Provides a query for per-animation events in model files, including from progs/foo.mdl.events files. */
#define FTE_ISBACKBUFFERED /* Allows you to check if a client has too many reliable messages pending. */
#define FTE_MEMALLOC /* Allows dynamically allocating memory. Use pointers to access this memory. Memory will not be saved into saved games. */
#define FTE_MEDIA_AVI /* playfilm command supports avi files. */
#define FTE_MEDIA_CIN /* playfilm command supports q2 cin files. */
#define FTE_MEDIA_ROQ /* playfilm command supports q3 roq files. */
#define FTE_MULTIPROGS /* Multiple progs.dat files can be loaded inside the same qcvm. Insert new ones with addprogs inside the 'init' function, and use externvalue+externset to rewrite globals (and hook functions) to link them together. Note that the result is generally not very clean unless you carefully design for it beforehand. */
#define FTE_MULTITHREADED /* Faux multithreading, allowing multiple contexts to run in sequence. */
#define FTE_MVD_PLAYERSTATS /* In csqc, getplayerstat can be used to query any player's stats when playing back MVDs. isdemo will return 2 in this case. */
#define FTE_QC_NPCCHAT
#define FTE_PART_SCRIPT /* Specifies that the r_particledesc cvar can be used to select a list of particle effects to load from particles/*.cfg, the format of which is documented elsewhere. */
#define FTE_PART_NAMESPACES /* Specifies that the engine can use foo.bar to load effect foo from particle description bar. When used via ssqc, this should cause the client to download whatever effects as needed. */
#define FTE_PART_NAMESPACE_EFFECTINFO /* Specifies that effectinfo.bar can load effects from effectinfo.txt for DP compatibility. */
#define FTE_QC_BASEFRAME /* Specifies that .basebone and .baseframe exist in ssqc. These fields affect all bones in the entity's model with a lower index than the .basebone field, allowing you to give separate control to the legs of a skeletal model, without affecting the torso animations, from ssqc. */
#define FTE_QC_FILE_BINARY /* Extends FRIK_FILE with binary read+write, as well as allowing seeking. Requires pointers. */
#define FTE_QC_CHANGELEVEL_HUB /* Adds an extra argument to changelevel which is carried over to the next map in the 'spawnspot' global. Maps will be saved+reloaded until the extra argument is omitted again, purging all saved maps. Saved games will contain a copy of each preserved map. parm1-parm64 globals can be used, giving more space to transfer more player data. */
#define FTE_QC_CHECKCOMMAND /* Provides a way to test if a console command exists, and whether its a command/alias/cvar. Does not say anything about the expected meanings of any arguments or values. */
#define FTE_QC_CHECKPVS
#define FTE_QC_CROSSPRODUCT
#define FTE_QC_CUSTOMSKINS /* The engine supports the use of q3 skins, as well as the use of such skin 'files' to specify rich top+bottom colours, qw skins, geomsets, or texture composition even on non-players.. */
#define FTE_QC_FS_SEARCH_SIZEMTIME
#define FTE_QC_HARDWARECURSORS /* setcursormode exists in both csqc+menuqc, and accepts additional arguments to specify a cursor image to use when this module has focus. If the image exceeds hardware limits (or hardware cursors are unsupported), it will be emulated using regular draws - this at least still avoids conflicting cursors as only one will ever be used, even if console+menu+csqc are all overlayed. */
#define FTE_QC_HASHTABLES /* Provides efficient string-based lookups. */
#define FTE_QC_INFOKEY /* QuakeWorld's infokey builtin works, and reports at least name+topcolor+bottomcolor+ping(in ms)+ip(unmasked, but not always ipv4)+team(aka bottomcolor in nq). Does not require actual localinfo/serverinfo/userinfo, but they're _highly_ recommended to any engines with csqc */
#define FTE_QC_INTCONV /* Provides string<>int conversions, including hex representations. */
#define FTE_QC_MATCHCLIENTNAME
#define FTE_QC_MULTICAST /* QuakeWorld's multicast builtin works along with MSG_MULTICAST, but also with unicast support. */
#define FTE_QC_PAUSED
#define FTE_QC_PERSISTENTTEMPSTRINGS /* Supersedes DP_QC_MULTIPLETEMPSTRINGS. Temp strings are garbage collected automatically, and do not expire while they're still in use. This makes strzone redundant. */
#define FTE_QC_RAGDOLL_WIP
#define FTE_QC_SENDPACKET /* Allows the use of out-of-band udp packets to/from other hosts. Includes the SV_ParseConnectionlessPacket event. */
#define FTE_QC_STUFFCMDFLAGS /* Variation on regular stuffcmd that gives control over how spectators/mvds should be treated. */
#define FTE_QC_TRACETRIGGER
#define FTE_QUAKE2_CLIENT /* This engine is able to act as a quake2 client */
#define FTE_QUAKE2_SERVER /* This engine is able to act as a quake2 server */
#define FTE_QUAKE3_CLIENT /* This engine is able to act as a quake3 client */
#define FTE_QUAKE3_SERVER /* This engine is able to act as a quake3 server */
#define FTE_SOLID_LADDER /* Allows a simple trigger to remove effects of gravity (solid 20). obsolete. will prolly be removed at some point as it is not networked properly. Use FTE_ENT_SKIN_CONTENTS */
#define FTE_SPLITSCREEN /* Client supports splitscreen, controlled via cl_splitclients. Servers require allow_splitscreen 1 if splitscreen is to be used over the internet. Mods that use csqc will need to be aware for this to work properly. per-client networking may be problematic. */
#define FTE_SQL /* Provides sql* builtins which can be used for sql database access */
#define FTE_SQL_SQLITE /* SQL functionality is able to utilise sqlite databases */
#define FTE_STRINGS /* Extra builtins (and additional behaviour) to make string manipulation easier */
#define FTE_SV_POINTPARTICLES /* Specifies that particleeffectnum, pointparticles, and trailparticles exist in ssqc as well as csqc. particleeffectnum acts as a precache, allowing ssqc values to be networked up with csqc for use. Use in combination with FTE_PART_SCRIPT+FTE_PART_NAMESPACES to use custom effects. This extension is functionally identical to the DP version, but avoids any misplaced assumptions about the format of the client's particle descriptions. */
#define FTE_SV_REENTER
#define FTE_TE_STANDARDEFFECTBUILTINS /* Provides builtins to replace writebytes, with a QW compatible twist. */
#define FTE_TERRAIN_MAP /* This engine supports .hmp files, as well as terrain embedded within bsp files. */
#define FTE_RAW_MAP /* This engine supports directly loading .map files, as well as realtime editing of the various brushes. */
#define KRIMZON_SV_PARSECLIENTCOMMAND /* SSQC's SV_ParseClientCommand function is able to handle client 'cmd' commands. The tokenizing parts also work in csqc. */
#define NEH_CMD_PLAY2
#define NEH_RESTOREGAME
#define QSG_CVARSTRING
#define QW_ENGINE
#define QWE_MVD_RECORD /* You can use the easyrecord command to record MVD demos serverside. */
#define TEI_MD3_MODEL
#define TENEBRAE_GFX_DLIGHTS /* Allows ssqc to attach rtlights to entities with various special properties. */
#define ZQ_MOVETYPE_FLY /* MOVETYPE_FLY works on players. */
#define ZQ_MOVETYPE_NOCLIP /* MOVETYPE_NOCLIP works on players. */
#define ZQ_MOVETYPE_NONE /* MOVETYPE_NONE works on players. */
#define ZQ_VWEP
#define ZQ_QC_STRINGS /* The strings-only subset of FRIK_FILE is supported. */

#ifdef _ACCESSORS
accessor strbuf : float;
accessor searchhandle : float;
accessor hashtable : float;
accessor infostring : string;
accessor filestream : float;
accessor filestream : float;
#else
#define strbuf float
#define searchhandle float
#define hashtable float
#define infostring string
#define filestream float
#endif

entity self;	/* The magic me */
entity other;	/* Valid in touch functions, this is the entity that we touched. */
entity world;	/* The null entity. Hurrah. Readonly after map spawn time. */
float time;	/* The current game time. Stops when paused. */
float frametime;	/* The time since the last physics/render/input frame. */
entity newmis;	/* A named entity that should be run soon, to reduce the effects of latency. */
float force_retouch;	/* If positive, causes all entities to check for triggers. */
string mapname;	/* The short name of the map. */
float serverflags;
float total_secrets;
float total_monsters;
float found_secrets;
float killed_monsters;
float parm1, parm2, parm3, parm4, parm5, parm6, parm7, parm8, parm9, parm10, parm11, parm12, parm13, parm14, parm15, parm16;
vector v_forward, v_up, v_right;
float trace_allsolid, trace_startsolid, trace_fraction;
vector trace_endpos, trace_plane_normal;
float trace_plane_dist;
entity trace_ent;
float trace_inopen;
float trace_inwater;
entity msg_entity;
void() main;
void() StartFrame;
void() PlayerPreThink;
void() PlayerPostThink;
void() ClientKill;
void() ClientConnect;
void() PutClientInServer;
void() ClientDisconnect;
void() SetNewParms;
void() SetChangeParms;
void end_sys_globals;
.float modelindex;	/* This is the model precache index for the model that was set on the entity, instead of having to look up the model according to the .model field. Use setmodel to change it. */
.vector absmin;	/* Set by the engine when the entity is relinked (by setorigin, setsize, or setmodel). This is in world coordinates. */
.vector absmax;	/* Set by the engine when the entity is relinked (by setorigin, setsize, or setmodel). This is in world coordinates. */
.float ltime;	/* On MOVETYPE_PUSH entities, this is used as an alternative to the 'time' global, and .nextthink is synced to this instead of time. This allows time to effectively freeze if the entity is blocked, ensuring the think happens when the entity reaches the target point instead of randomly. */
.float lastruntime;	/* This field used to be used to avoid running an entity multiple times in a single frame due to quakeworld's out-of-order thinks. It is no longer used by FTE due to precision issues, but may still be updated for compatibility reasons. */
.float movetype;	/* Describes how the entity moves. One of the MOVETYPE_ constants. */
.float solid;	/* Describes whether the entity is solid or not, and any special properties infered by that. Must be one of the SOLID_ constants */
.vector origin;	/* The current location of the entity in world space. Inline bsp entities (ie: ones placed by a mapper) will typically have a value of '0 0 0' in their neutral pose, as the geometry is offset from that. It is the reference point of the entity rather than the center of its geometry, for non-bsp models, this is often not a significant distinction. */
.vector oldorigin;	/* This is often used on players to reset the player back to where they were last frame if they somehow got stuck inside something due to fpu precision. Never change a player's oldorigin field to inside a solid, because that might cause them to become pemanently stuck. */
.vector velocity;	/* The direction and speed that the entity is moving in world space. */
.vector angles;	/* The eular angles the entity is facing in, in pitch, yaw, roll order. Due to a legacy bug, mdl/iqm/etc formats use +x=UP, bsp/spr/etc formats use +x=DOWN. */
.vector avelocity;	/* The amount the entity's angles change by per second. Note that this is direct eular angles, and thus the angular change is non-linear and often just looks buggy if you're changing more than one angle at a time. */
.string classname;	/* Identifies the class/type of the entity. Useful for debugging, also used for loading, but its value is not otherwise significant to the engine, this leaves the mod free to set it to whatever it wants and randomly test strings for values in whatever inefficient way it chooses fit. */
.string model;	/* The model name that was set via setmodel, in theory. Often, this is cleared to null to prevent the engine from being seen by clients while not changing modelindex. This behaviour allows inline models to remain solid yet be invisible. */
.float frame;	/* The current frame the entity is meant to be displayed in. In CSQC, note the lerpfrac and frame2 fields as well. if it specifies a framegroup, the framegroup will autoanimate in ssqc, but not in csqc. */
.float skin;	/* The skin index to use. on a bsp entity, setting this to 1 will switch to the 'activated' texture instead. A negative value will be understood as a replacement contents value, so setting it to CONTENTS_WATER will make a movable pool of water. */
.float effects;	/* Lots of random flags that change random effects. See EF_* constants. */
.vector mins;	/* The minimum extent of the model (ie: the bottom-left coordinate relative to the entity's origin). Change via setsize. May also be changed by setmodel. */
.vector maxs;	/* like mins, but in the other direction. */
.vector size;	/* maxs-mins. Updated when the entity is relinked (by setorigin, setsize, setmodel) */
.void() touch;
.void() use;
.void() think;
.void() blocked;
.float nextthink;	/* The time at which the entity is next scheduled to fire its think event. For MOVETYPE_PUSH entities, this is relative to that entity's ltime field, for all other entities it is relative to the time gloal. */
.entity groundentity;
.float health;
.float frags;
.float weapon;
.string weaponmodel;
.float weaponframe;
.float currentammo;
.float ammo_shells;
.float ammo_nails;
.float ammo_rockets;
.float ammo_cells;
.float items;
.float takedamage;
.entity chain;
.float deadflag;
.vector view_ofs;
.float button0;
.float button1;
.float button2;
.float impulse;
.float fixangle;	/* Forces the clientside view angles to change to the value of .angles (has some lag). If set to 1/TRUE, the server will guess whether to send a delta or an explicit angle. If 2, will always send a delta (due to lag between transmission and acknowledgement, this cannot be spammed reliably). If 3, will always send an explicit angle. */
.vector v_angle;	/* The angles a player is viewing. +x is DOWN (pitch, yaw, roll) */
.string netname;
.entity enemy;
.float flags;
.float colormap;
.float team;
.float max_health;
.float teleport_time;	/* While active, prevents the player from using the +back command, also blocks waterjumping. */
.float armortype;
.float armorvalue;
.float waterlevel;
.float watertype;
.float ideal_yaw;
.float yaw_speed;
.entity aiment;
.entity goalentity;
.float spawnflags;
.string target;
.string targetname;
.float dmg_take;
.float dmg_save;
.entity dmg_inflictor;
.entity owner;
.vector movedir;
.string message;
.float sounds;
.string noise;
.string noise1;
.string noise2;
.string noise3;
void end_sys_fields;
float input_timelength;
vector input_angles;	/* +x=DOWN */
vector input_movevalues;
float input_buttons;
float input_impulse;
int trace_endcontents;
int trace_surfaceflags;
int trace_brush_id;
int trace_brush_faceid;
int trace_surface_id;	/* 1-based. 0 if not known. */
int trace_bone_id;	/* 1-based. 0 if not known. typically needs MOVE_HITMODEL. */
int trace_triangle_id;	/* 1-based. 0 if not known. */
vector global_gravitydir = '0 0 -1';	/* The direction gravity should act in if not otherwise specified per entity. */
int serverid;	/* The unique id of this server within the server cluster. */
.vector punchangle;
.float gravity;
.float hull;	/* Overrides the hull used by the entity for walkmove/movetogoal and not traceline/tracebox. */
.entity movechain;	/* This is a linked list of entities which will be moved whenever this entity moves, logically they are attached to this entity. */
.void() chainmoved;	/* Called when the entity is moved as a result of being part of another entity's .movechain */
.void(float old, float new) contentstransition;	/* This function is called when the entity moves between water and air. If specified, default splash sounds will be disabled allowing you to provide your own. */
.float dimension_solid;	/* This is the bitmask of dimensions which the entity is solid within. */
.float dimension_hit;	/* This is the bitmask of dimensions which the entity will be blocked by. If other.dimension_solid & self.dimension_hit, our traces will impact and not proceed. If its false, the traces will NOT impact, allowing self to pass straight through. */
.int hitcontentsmaski;	/* Traces performed for this entity will impact against surfaces that match this contents mask. */
.float dphitcontentsmask;	/* Some crappy field that inefficiently requires translating to the native contents flags. Ditch the 'dp', do it properly. */
.float scale;	/* Multiplier that resizes the entity. 1 is normal sized, 2 is double sized. scale 0 is remapped to 1. In SSQC, this is limited to 1/16th precision, with a maximum just shy of 16. */
.float fatness;	/* How many QuakeUnits to push the entity's verticies along their normals by. */
.float alpha;	/* The transparency of the entity. 1 means opaque, 0.0001 means virtually invisible. 0 is remapped to 1, for compatibility. */
.float modelflags;	/* Used to override the flags set in the entity's model. Should be set according to the MF_ constants. Use effects|=EF_NOMODELFLAGS to ignore the model's flags completely. The traileffectnum field is more versatile. */
.float frame1time;	/* This controls the time into the framegroup/animation named by .frame, you should increment this value according to frametime or to distance moved, depending on the sort of animation you're attempting. You may wish to avoid incrementing this while lerpfrac is still changing, to avoid wasting parts of the animation. */
.float basebone;	/* The base* frame animations are equivelent to their non-base versions, except that they only affect bone numbers below the 'basebone' value. This means that the base* animation can affect the legs of a skeletal model independantly of the normal animation fields affecting the torso area. For more complex animation than this, use skeletal objects. */
.float baseframe;	/* See basebone */
.void() customphysics;	/* Called once each physics frame, overriding the entity's .movetype field and associated logic. You'll probably want to use tracebox to move it through the world. Be sure to call .think as appropriate. */
.entity tag_entity;
.float tag_index;
.float skeletonindex;	/* This object serves as a container for the skeletal bone states used to override the animation data. */
.vector colormod;	/* Provides a colour tint for the entity. */
.vector glowmod;
.vector gravitydir;	/* Specifies the direction in which gravity acts. Must be normalised. '0 0 0' also means down. Use '0 0 1' if you want the player to be able to run on ceilings. */
.vector(vector org, vector ang) camera_transform;	/* Provides portal transform information for portal surfaces attached to this entity. Also used to open up pvs in ssqc. */
.float pmove_flags;
.float geomtype;
.float friction;
.float erp;
.float jointtype;
.float mass;
.float bouncefactor;
.float bouncestop;
.float idealpitch;
.float pitch_speed;
.float drawflags;	/* Various flags that affect lighting values and scaling. Typically set to 96 in quake for proper compatibility with DP_QC_SCALE. */
.float abslight;	/* Allows overriding light levels. Use drawflags to state that this field should actually be used. */
.vector color;	/* This affects the colour of realtime lights that were enabled via the pflags field. */
.float light_lev;	/* This is the radius of an entity's light. This is not normally used by the engine, but is used for realtime lights (ones that are enabled with the pflags field). */
.float style;	/* Used by the light util to decide how an entity's light should animate. On an entity with pflags set, this also affects realtime lights. */
.float pflags;	/* Realtime lighting flags */
.float maxspeed;
.entity view2;	/* defines a second viewpoint, typically displayed in a corner of the screen (also punches open pvs). */
.vector movement;	/* These are the directions that the player is currently trying to move in (ie: which +forward/+moveright/+moveup etc buttons they have held), expressed relative to that player's angles. Order is forward, right, up. */
.float vw_index;	/* This acts as a second modelindex, using the same frames etc. */
.entity nodrawtoclient;	/* This entity will not be sent to the player named by this field. They will be invisible and not emit dlights/particles. Does not work in MVD-recorded game. */
.entity drawonlytoclient;	/* This entity will be sent *only* to the player named by this field. To other players they will be invisible and not emit dlights/particles. Does not work in MVD-recorded game. */
.entity viewmodelforclient;	/* This entity will be sent only to the player named by this field, and this entity will be attached to the player's view as an additional weapon model. */
.entity exteriormodeltoclient;	/* This entity will be invisible to the player named by this field, except in mirrors or mirror-like surfaces, where it will be visible as normal. It may still cast shadows as normal, and generate lights+particles, depending on client settings. Does not affect how other players see the entity. */
.float button3;	/* DP_INPUTBUTTONS (note in qw, we set 1 to equal 3, to match zquake/fuhquake/mvdsv) */
.float button4;
.float button5;
.float button6;
.float button7;
.float button8;
.float glow_size;
.float glow_color;
.float glow_trail;
.float traileffectnum;	/* This should be set to the result of particleeffectnum, in order to attach a custom trail effect to an entity as it moves. */
.float emiteffectnum;	/* This should be set to the result of particleeffectnum, in order to continually spawn particles in the direction that this entity faces. */
.float dimension_see;	/* This is the dimension mask (bitfield) that the client is allowed to see. Entities and events not in this dimension mask will be invisible. */
.float dimension_seen;	/* This is the dimension mask (bitfield) that the client is visible within. Clients that cannot see this dimension mask will not see this entity. */
.float dimension_ghost;	/* If this entity is visible only within these dimensions, it will become transparent, as if a ghost. */
.float dimension_ghost_alpha;	/* If this entity is subject to dimension_ghost, this is the scaler for its alpha value. If 0, 0.5 will be used instead. */
.float(entity playerent, float changedflags) SendEntity;	/* Called by the engine whenever an entity needs to be (re)sent to a client's csprogs, either because SendFlags was set or because data was lost. Must write its data to the MSG_ENTITY buffer. Will be called at the engine's leasure. */
.float SendFlags;	/* Indicates that something in the entity has been changed, and that it needs to be updated to all players that can see it. The engine will clear it at some point, with the cleared bits appearing in the 'changedflags' argument of the SendEntity method. */
.float Version;	/* Obsolete, set a SendFlags bit instead. */
.float clientcolors;
.float viewzoom;
.float items2;
.float playerclass;
.float hasted;
.float light_level;	/* Used by hexen2 to indicate the light level where the player is standing. */
.float pvsflags;	/* Reconfigures when the entity is visible to clients */
.float uniquespawnid;	/* Incremented by 1 whenever the entity is respawned. Persists across remove calls, for when the two-second grace period is insufficient. */
.float() customizeentityforclient;	/* Called just before an entity is sent to a client (non-csqc protocol). This gives you a chance to tailor 'self' according to what 'other' should see. */
void(float reqid, float responsecode, string resourcebody) URI_Get_Callback;	/* Called as an eventual result of the uri_get builtin. */
void() SpectatorConnect;	/* Called when a spectator joins the game. */
void() SpectatorDisconnect;	/* Called when a spectator disconnects from the game. */
void() SpectatorThink;	/* Called each frame for each spectator. */
void(string cmd) SV_ParseClientCommand;	/* Provides QC with a way to intercept 'cmd foo' commands from the client. Very handy. Self will be set to the sending client, while the 'cmd' argument can be tokenize()d and each element retrieved via argv(argno). Unrecognised cmds MUST be passed on to the clientcommand builtin. */
void(string dest, string from, string cmd, string info) SV_ParseClusterEvent;	/* Part of cluster mode. Handles cross-node events that were sent via clusterevent, on behalf of the named client. */
float(string sender, string body) SV_ParseConnectionlessPacket;	/* Provides QC with a way to communicate between servers, or with client server browsers. Sender is the sender's ip. Body is the body of the message. You'll need to add your own password/etc support as required. Self is not valid. */
void(float pauseduration) SV_PausedTic;	/* For each frame that the server is paused, this function will be called to give the gamecode a chance to unpause the server again. the pauseduration argument says how long the server has been paused for (the time global is frozen and will not increment while paused). Self is not valid. */
float(float newstatus) SV_ShouldPause;	/* Called to give the qc a change to block pause/unpause requests. Return false for the pause request to be ignored. newstatus is 1 if the user is trying to pause the game. For the duration of the call, self will be set to the player who tried to pause, or to world if it was triggered by a server-side event. */
void() SV_RunClientCommand;	/* Called each time a player movement packet was received from a client. Self is set to the player entity which should be updated, while the input_* globals specify the various properties stored within the input packet. The contents of this function should be somewaht identical to the equivelent function in CSQC, or prediction misses will occur. If you're feeling lazy, you can simply call 'runstandardplayerphysics' after modifying the inputs. */
void() SV_AddDebugPolygons;	/* Called each video frame. This is the only place where ssqc is allowed to call the R_BeginPolygon/R_PolygonVertex/R_EndPolygon builtins. This is exclusively for debugging, and will break in anything but single player as it will not be called if the engine is not running both a client and a server. */
void() SV_PlayerPhysics;	/* Legacy method to tweak player input that does not reliably work with prediction (prediction WILL break). Mods that care about prediction should use SV_RunClientCommand instead. If pr_no_playerphysics is set to 1, this function will never be called, which will either fix prediction or completely break player movement depending on whether the feature was even useful. */
void() EndFrame;	/* Called after non-player entities have been run at the end of the physics frame. Player physics is performed out of order and can/will still occur between EndFrame and BeginFrame. */
string(string addr, string uinfo, string features)  SV_CheckRejectConnection;	/* Called to give the mod a chance to ignore connection requests based upon client protocol support or other properties. Use infoget to read the uinfo and features arguments. */
string(string uri, string method, string postdata, __in string requestheaders, __inout string responseheaders) Cef_GeneratePage;	/* Provides an entrypoint to generate pages for the CEF plugin from within QC. Headers are 
-separated key/value pairs (use tokenizebyseparator). */
void(float prevprogs) init;	/* Part of FTE_MULTIPROGS. Called as soon as a progs is loaded, called at a time when entities are not valid. This is the only time when it is safe to call addprogs without field assignment. As it is also called as part of addprogs, this also gives you a chance to hook functions in modules that are already loaded (via externget+externget). */
void() initents;	/* Part of FTE_MULTIPROGS. Called after fields have been finalized. This is the first point at which it is safe to call spawn(), and is called before any entity fields have been parsed. You can use this entrypoint to send notifications to other modules. */
float parm17, parm18, parm19, parm20, parm21, parm22, parm23, parm24, parm25, parm26, parm27, parm28, parm29, parm30, parm31, parm32;
float parm33, parm34, parm35, parm36, parm37, parm38, parm39, parm40, parm41, parm42, parm43, parm44, parm45, parm46, parm47, parm48;
float parm49, parm50, parm51, parm52, parm53, parm54, parm55, parm56, parm57, parm58, parm59, parm60, parm61, parm62, parm63, parm64;
var float dimension_send;	/* Used by multicast functionality. Multicasts (and related builtins that multicast internally) will only be sent to players where (player.dimension_see & dimension_send) is non-zero. */
//var float dimension_default = 255;
/* Default dimension bitmask */
__used var float physics_mode = 2;	/* 0: original csqc - physics are not run
1: DP-compat. Thinks occur, but not true movetypes.
2: movetypes occur just as they do in ssqc. */
const float TRUE = 1;
const float FALSE = 0;	/* File not found... */
const float M_PI = 3.14159;
const float MOVETYPE_NONE = 0;
const float MOVETYPE_WALK = 3;
const float MOVETYPE_STEP = 4;
const float MOVETYPE_FLY = 5;
const float MOVETYPE_TOSS = 6;
const float MOVETYPE_PUSH = 7;
const float MOVETYPE_NOCLIP = 8;
const float MOVETYPE_FLYMISSILE = 9;
const float MOVETYPE_BOUNCE = 10;
const float MOVETYPE_BOUNCEMISSILE = 11;
const float MOVETYPE_FOLLOW = 12;
const float MOVETYPE_6DOF = 30;	/* A glorified MOVETYPE_FLY. Players using this movetype will get some flightsim-like physics, with fully independant rotations (order-dependant transforms). */
const float MOVETYPE_WALLWALK = 31;	/* Players using this movetype will be able to orient themselves to walls, and then run up them. */
const float MOVETYPE_PHYSICS = 32;	/* Enable the use of ODE physics upon this entity. */
const float SOLID_NOT = 0;
const float SOLID_TRIGGER = 1;
const float SOLID_BBOX = 2;
const float SOLID_SLIDEBOX = 3;
const float SOLID_BSP = 4;	/* Does not collide against other SOLID_BSP entities. Normally paired with MOVETYPE_PUSH. */
const float SOLID_CORPSE = 5;	/* Non-solid to SOLID_SLIDEBOX or other SOLID_CORPSE entities. For hitscan weapons to hit corpses, change the player's .solid value to SOLID_BBOX or so, perform the traceline, then revert the player's .solid value. */
const float SOLID_LADDER = 20;	/* Obsolete and may be removed at some point. Use skin=CONTENT_LADDER and solid_bsp or solid_trigger instead. */
const float SOLID_PORTAL = 21;	/* CSG subtraction volume combined with entity transformations on impact. */
const float SOLID_PHYSICS_BOX = 32;
const float SOLID_PHYSICS_SPHERE = 33;
const float SOLID_PHYSICS_CAPSULE = 34;
const float SOLID_PHYSICS_TRIMESH = 35;
const float SOLID_PHYSICS_CYLINDER = 36;
const float GEOMTYPE_NONE = -1;
const float GEOMTYPE_SOLID = 0;
const float GEOMTYPE_BOX = 1;
const float GEOMTYPE_SPHERE = 2;
const float GEOMTYPE_CAPSULE = 3;
const float GEOMTYPE_TRIMESH = 4;
const float GEOMTYPE_CYLINDER = 5;
const float GEOMTYPE_CAPSULE_X = 6;
const float GEOMTYPE_CAPSULE_Y = 7;
const float GEOMTYPE_CAPSULE_Z = 8;
const float GEOMTYPE_CYLINDER_X = 9;
const float GEOMTYPE_CYLINDER_Y = 10;
const float GEOMTYPE_CYLINDER_Z = 11;
const float JOINTTYPE_FIXED = -1;
const float JOINTTYPE_POINT = 1;
const float JOINTTYPE_HINGE = 2;
const float JOINTTYPE_SLIDER = 3;
const float JOINTTYPE_UNIVERSAL = 4;
const float JOINTTYPE_HINGE2 = 5;
const float DAMAGE_NO = 0;
const float DAMAGE_YES = 1;
const float DAMAGE_AIM = 2;
const float CONTENT_EMPTY = -1;
const float CONTENT_SOLID = -2;
const float CONTENT_WATER = -3;
const float CONTENT_SLIME = -4;
const float CONTENT_LAVA = -5;
const float CONTENT_SKY = -6;
const float CONTENT_LADDER = -16;	/* If this value is assigned to a solid_bsp's .skin field, the entity will become a ladder volume. */
const int CONTENTBIT_NONE = 0x00000000i;
const int CONTENTBIT_SOLID = 0x00000001i;
const int CONTENTBIT_LAVA = 0x00000008i;
const int CONTENTBIT_SLIME = 0x00000010i;
const int CONTENTBIT_WATER = 0x00000020i;
const int CONTENTBIT_FTELADDER = 0x00004000i;
const int CONTENTBIT_PLAYERCLIP = 0x00010000i;
const int CONTENTBIT_MONSTERCLIP = 0x00020000i;
const int CONTENTBIT_BODY = 0x02000000i;
const int CONTENTBIT_CORPSE = 0x04000000i;
const int CONTENTBIT_Q2LADDER = 0x20000000i;	/* Content bit specific to q2bsp */
const int CONTENTBIT_SKY = 0x80000000i;
const int CONTENTBITS_POINTSOLID = CONTENTBIT_SOLID|0x00000002i|CONTENTBIT_BODY;	/* Bits that traceline would normally consider solid */
const int CONTENTBITS_BOXSOLID = CONTENTBIT_SOLID|0x00000002i|CONTENTBIT_BODY|CONTENTBIT_PLAYERCLIP;	/* Bits that tracebox would normally consider solid */
const int CONTENTBITS_FLUID = CONTENTBIT_WATER|CONTENTBIT_SLIME|CONTENTBIT_LAVA|CONTENTBIT_SKY;
const int SPA_POSITION;	/* These SPA_* constants are to specify which attribute is returned by the getsurfacepointattribute builtin */
const int SPA_S_AXIS = 1;
const int SPA_T_AXIS = 2;
const int SPA_R_AXIS = 3;	/* aka: SPA_NORMAL */
const int SPA_TEXCOORDS0 = 4;
const int SPA_LIGHTMAP0_TEXCOORDS = 5;
const int SPA_LIGHTMAP0_COLOR = 6;
const float CHAN_AUTO = 0;	/* The automatic channel, play as many sounds on this channel as you want, and they'll all play, however the other channels will replace each other. */
const float CHAN_WEAPON = 1;
const float CHAN_VOICE = 2;
const float CHAN_ITEM = 3;
const float CHAN_BODY = 4;
const float CHANF_RELIABLE = 8;	/* Only valid if the flags argument is not specified. The sound will be sent reliably, which is important if it is intended to replace looping sounds on doors etc. */
const float SOUNDFLAG_RELIABLE = 1;	/* The sound will be sent reliably, and without regard to phs. */
const float SOUNDFLAG_FORCELOOP = 2;	/* The sound will restart once it reaches the end of the sample. */
const float SOUNDFLAG_NOREVERB = 32;	/* Disables the use of underwater/reverb effects on this sound effect. */
const float SOUNDFLAG_FOLLOW = 64;	/* The sound's origin will updated to follow the emitting entity. */
const float SOUNDFLAG_UNICAST = 256;	/* The sound will be heard only by the player specified by msg_entity. */
const float SOUNDFLAG_SENDVELOCITY = 512;	/* The entity's current velocity will be sent to the client, only useful if doppler is enabled. */
const float ATTN_NONE = 0;	/* Sounds with this attenuation can be heard throughout the map */
const float ATTN_NORM = 1;	/* Standard attenuation */
const float ATTN_IDLE = 2;	/* Extra attenuation so that sounds don't travel too far. */
const float ATTN_STATIC = 3;	/* Even more attenuation to avoid torches drowing out everything else throughout the map. */
const float SVC_CGAMEPACKET = 83;	/* Direct ssqc->csqc message. Must only be multicast. The data triggers a CSQC_Parse_Event call in the csqc for the csqc to read the contents. The server *may* insert length information for clients connected via proxies which are not able to cope with custom csqc payloads. This should only ever be used in conjunction with the MSG_MULTICAST destination. */
const float MSG_BROADCAST = 0;	/* The byte(s) will be unreliably sent to all players. MSG_ constants are valid arguments to the Write* builtin family. */
const float MSG_ONE = 1;	/* The byte(s) will be reliably sent to the player specified in the msg_entity global. WARNING: in quakeworld servers without network preparsing enabled, this can result in illegible server messages (due to individual reliable messages being split between multiple backbuffers/packets). NQ has larger reliable buffers which avoids this issue, but still kicks the client. */
const float MSG_ALL = 2;	/* The byte(s) will be reliably sent to all players. */
const float MSG_INIT = 3;	/* The byte(s) will be written into the signon buffer. Clients will see these messages when they connect later. This buffer is only flushed on map changes, so spamming it _WILL_ result in overflows. */
const float MSG_MULTICAST = 4;	/* The byte(s) will be written into the multicast buffer for more selective sending. Messages sent this way will never be split across packets, and using this for csqc-only messages will not break protocol translation. */
const float MSG_ENTITY = 5;	/* The byte(s) will be written into the entity buffer. This is a special value used only inside 'SendEntity' functions. */
const float MULTICAST_ALL = 0;	/* The multicast message is unreliably sent to all players. MULTICAST_ constants are valid arguments for the multicast builtin, which ignores the specified origin when given this constant. */
const float MULTICAST_PHS = 1;	/* The multicast message is unreliably sent to only players that can potentially hear the specified origin. Its quite loose. */
const float MULTICAST_PVS = 2;	/* The multicast message is unreliably sent to only players that can potentially see the specified origin. */
const float MULTICAST_ONE = 6;	/* The multicast message is unreliably sent to the player specified in the msg_entity global. The specified origin is ignored. */
const float MULTICAST_ALL_R = 3;	/* The multicast message is reliably sent to all players. The specified origin is ignored. */
const float MULTICAST_PHS_R = 4;	/* The multicast message is reliably sent to only players that can potentially hear the specified origin. Players might still not receive it if they are out of range. */
const float MULTICAST_PVS_R = 5;	/* The multicast message is reliably sent to only players that can potentially see the specified origin. Players might still not receive it if they cannot see the event. */
const float MULTICAST_ONE_R = 7;	/* The multicast message is reliably sent to the player specified in the msg_entity global. The specified origin is ignored */
const float PRINT_LOW = 0;
const float PRINT_MEDIUM = 1;
const float PRINT_HIGH = 2;
const float PRINT_CHAT = 3;
const float PVSF_NORMALPVS = 0;	/* Filter first by PVS, then filter this entity using tracelines if sv_cullentities is enabled. */
const float PVSF_NOTRACECHECK = 1;	/* Filter strictly by PVS. */
const float PVSF_USEPHS = 2;	/* Send if we're close enough to be able to hear this entity. */
const float PVSF_IGNOREPVS = 3;	/* Ignores pvs. This entity is visible whereever you are on the map. */
const float PVSF_NOREMOVE = 128;	/* Once visible to a client, this entity will remain visible. This can be useful for csqc and corpses. */
const string INFOKEY_P_IP = "ip";	/* The apparent ip address of the client. This may be a proxy's ip address. */
const string INFOKEY_P_REALIP = "realip";	/* If sv_getrealip is set, this gives the ip as determine using that algorithm. */
const string INFOKEY_P_CSQCACTIVE = "csqcactive";	/* Client has csqc enabled. CSQC ents etc will be sent to this player. */
const string INFOKEY_P_SVPING = "svping";
const string INFOKEY_P_GUID = "guid";	/* Some hash string which should be reasonably unique to this player's quake installation. */
const string INFOKEY_P_CHALLENGE = "challenge";
const string INFOKEY_P_USERID = "*userid";
const string INFOKEY_P_DOWNLOADPCT = "download";	/* The client's download percentage for the current file. Additional files are not known. */
const string INFOKEY_P_TRUSTLEVEL = "trustlevel";
const string INFOKEY_P_PROTOCOL = "protocol";	/* The network protocol the client is using to connect to the server. */
const string INFOKEY_P_VIP = "*VIP";	/* 1 if the player has the VIP 'penalty'. */
const string INFOKEY_P_ISMUTED = "*ismuted";	/* 1 if the player has the 'mute' penalty and is not allowed to use the say/say_team commands. */
const string INFOKEY_P_ISDEAF = "*isdeaf";	/* 1 if the player has the 'deaf' penalty and cannot see other people's say/say_team commands. */
const string INFOKEY_P_ISCRIPPLED = "*ismuted";	/* 1 if the player has the cripple penalty, and their movement values are ignored (.movement is locked to 0). */
const string INFOKEY_P_ISCUFFED = "*ismuted";	/* 1 if the player has the cuff penalty, and is unable to attack or use impulses(.button0 and .impulse fields are locked to 0). */
const string INFOKEY_P_ISLAGGED = "*ismuted";	/* 1 if the player has the fakelag penalty and has an extra 200ms of lag. */
const string INFOKEY_P_PING = "ping";	/* The player's ping time, in milliseconds. */
const string INFOKEY_P_NAME = "name";	/* The player's name. */
const string INFOKEY_P_SPECTATOR = "*spectator";	/* Whether the player is a spectator or not. */
const string INFOKEY_P_TOPCOLOR = "topcolor";	/* The player's upper/shirt colour (palette index). */
const string INFOKEY_P_BOTTOMCOLOR = "bottomcolor";	/* The player's lower/pants/trouser colour (palette index). */
const float STUFFCMD_IGNOREINDEMO = 1;	/* This stuffcmd will NOT be written to mvds/qtv. */
const float STUFFCMD_DEMOONLY = 2;	/* This stuffcmd will ONLY be written into mvds/qtv streams. */
const float STUFFCMD_BROADCAST = 4;	/* The stuffcmd will be broadcast server-wide (according to the mvd filters). */
const float STUFFCMD_UNRELIABLE = 8;	/* The stuffcmd might not arrive. It might also get there faster than ones sent over the reliable channel. */
const float FL_FLY = 1;
const float FL_SWIM = 2;
const float FL_CLIENT = 8;
const float FL_INWATER = 16;
const float FL_MONSTER = 32;
const float FL_GODMODE = 64;
const float FL_NOTARGET = 128;
const float FL_ITEM = 256;
const float FL_ONGROUND = 512;
const float FL_PARTIALGROUND = 1024;
const float FL_WATERJUMP = 2048;
const float FL_FINDABLE_NONSOLID = 16384;	/* Allows this entity to be found with findradius */
const float FL_LAGGEDMOVE = 65536;	/* Enables anti-lag on rockets etc. */
const float MOVE_NORMAL = 0;
const float MOVE_NOMONSTERS = 1;	/* The trace will ignore all non-solid_bsp entities. */
const float MOVE_MISSILE = 2;	/* The trace will use a bbox size of +/- 15 against entities with FL_MONSTER set. */
const float MOVE_HITMODEL = 4;	/* Traces will impact the actual mesh of the model instead of merely their bounding box. Should generally only be used for tracelines. Note that this flag is unreliable as an object can animate through projectiles. The bounding box MUST be set to completely encompass the entity or those extra areas will be non-solid (leaving a hole for things to go through). */
const float MOVE_TRIGGERS = 16;	/* This trace type will impact only triggers. It will ignore non-solid entities. */
const float MOVE_EVERYTHING = 32;	/* This type of trace will hit solids and triggers alike. Even non-solid entities. */
const float MOVE_LAGGED = 64;	/* Will use antilag based upon the player's latency. Traces will be performed against old positions for entities instead of their current origin. */
const float MOVE_ENTCHAIN = 128;	/* Returns a list of entities impacted via the trace_ent.chain field */
const float MOVE_OTHERONLY = 256;	/* Traces that use this trace type will collide against *only* the entity specified via the 'other' global, and will ignore all owner/solid_not/dimension etc rules, they will still adhere to contents and bsp/bbox rules though. */
const float RESTYPE_MODEL = 0;	/* RESTYPE_* constants are used as arguments with the resourcestatus builtin. */
const float RESTYPE_SOUND = 1;	/* precache_sound */
const float RESTYPE_PARTICLE = 2;	/* particleeffectnum */
const float RESSTATE_NOTKNOWN = 0;	/* RESSTATE_* constants are return values from the resourcestatus builtin. The engine doesn't know about the resource if it is in this state. This means you will need to precache it. Attempting to use it anyway may result in warnings, errors, or silently succeed, depending on engine version and resource type. */
const float RESSTATE_NOTLOADED = 1;	/* The resource was precached, but has been flushed and there has not been an attempt to reload it. If you use the resource normally, chances are it'll be loaded but at the cost of a stall. */
const float RESSTATE_LOADING = 2;	/* Resources in this this state are queued for loading, and will be loaded at the engine's convienience. If you attempt to query the resource now, the engine will stall until the result is available. sounds in this state may be delayed, while models/pics/shaders may be invisible. */
const float RESSTATE_FAILED = 3;	/* Resources in this state are unusable/could not be loaded. You will get placeholders or dummy results. Queries will not stall the engine. The engine may display placeholder content. */
const float RESSTATE_LOADED = 4;	/* Resources in this state are finally usable, everything will work okay. Hurrah. Queries will not stall the engine. */
const float EF_BRIGHTFIELD = 1;
const float EF_BRIGHTLIGHT = 4;
const float EF_DIMLIGHT = 8;
const float EF_FLAG1 = 16;
const float EF_FLAG2 = 32;
const float EF_BLUE = 64;	/* A blue glow */
const float EF_RED = 128;	/* A red glow */
const float EF_GREEN = 262144;	/* A green glow */
const float EF_FULLBRIGHT = 512;	/* This entity will ignore lighting */
const float EF_NOSHADOW = 4096;	/* This entity will not cast shadows */
const float EF_NODEPTHTEST = 8192;	/* This entity will be drawn over the top of other things that are closer. */
const float EF_NOMODELFLAGS = 8388608;	/* Surpresses the normal flags specified in the model. */
const float MF_ROCKET = 1;
const float MF_GRENADE = 2;
const float MF_GIB = 4;	/* Regular blood trail */
const float MF_ROTATE = 8;
const float MF_TRACER = 16;	/* AKA: green scrag trail */
const float MF_ZOMGIB = 32;	/* Dark blood trail */
const float MF_TRACER2 = 64;	/* AKA: hellknight projectile trail */
const float MF_TRACER3 = 128;	/* AKA: purple vore trail */
const float SL_ORG_TL = 20;	/* Used with showpic etc, specifies that the x+y values are relative to the top-left of the screen */
const float SL_ORG_TR = 21;
const float SL_ORG_BL = 22;
const float SL_ORG_BR = 23;
const float SL_ORG_MM = 24;
const float SL_ORG_TM = 25;
const float SL_ORG_BM = 26;
const float SL_ORG_ML = 27;
const float SL_ORG_MR = 28;
const float PFLAGS_NOSHADOW = 1;	/* Associated RT lights attached will not cast shadows, making them significantly faster to draw. */
const float PFLAGS_CORONA = 2;	/* Enables support of coronas on the associated rtlights. */
const float PFLAGS_FULLDYNAMIC = 128;	/* When set in self.pflags, enables fully-customised dynamic lights. Custom rtlight information is not otherwise used. */
const float EV_STRING = 1;
const float EV_FLOAT = 2;
const float EV_VECTOR = 3;
const float EV_ENTITY = 4;
const float EV_FIELD = 5;
const float EV_FUNCTION = 6;
const float EV_POINTER = 7;
const float EV_INTEGER = 8;
const float EV_VARIANT = 9;
hashtable gamestate;	/* Special hash table index for hash_add and hash_get. Entries in this table will persist over map changes (and doesn't need to be created/deleted). */
const float HASH_REPLACE = 256;	/* Used with hash_add. Attempts to remove the old value instead of adding two values for a single key. */
const float HASH_ADD = 512;	/* Used with hash_add. The new entry will be inserted in addition to the existing entry. */
const float STAT_USER = 32;	/* Custom user stats start here (lower values are reserved for engine use). */
const float CLIENTTYPE_DISCONNECTED = 0;	/* Return value from clienttype() builtin. This entity is a player slot that is currently empty. */
const float CLIENTTYPE_REAL = 1;	/* This is a real player, and not a bot. */
const float CLIENTTYPE_BOT = 2;	/* This player slot does not correlate to a real player, any messages sent to this client will be ignored. */
const float CLIENTTYPE_NOTACLIENT = 3;	/* This entity is not even a player slot. This is typically an error condition. */
const float FILE_READ = 0;	/* The file may be read via fgets to read a single line at a time. */
const float FILE_APPEND = 1;	/* Like FILE_WRITE, but writing starts at the end of the file. */
const float FILE_WRITE = 2;	/* fputs will be used to write to the file. */
const float FILE_READNL = 4;	/* Like FILE_READ, except newlines are not special. fgets reads the entire file into a tempstring. */
const float FILE_MMAP_READ = 5;	/* The file will be loaded into memory. fgets returns a pointer to the first byte (and will always return the same value for this file). Cast this to your datatype. */
const float FILE_MMAP_RW = 6;	/* Like FILE_MMAP_READ, except any changes to the data will be written back to disk once the file is closed. */
void(vector vang) makevectors = #1; /*
		Takes an angle vector (pitch,yaw,roll) (+x=DOWN). Writes its results into v_forward, v_right, v_up vectors. */

void(entity e, vector o) setorigin = #2; /*
		Changes e's origin to be equal to o. Also relinks collision state (as well as setting absmin+absmax), which is required after changing .solid */

void(entity e, string m) setmodel = #3; /*
		Looks up m in the model precache list, and sets both e.model and e.modelindex to match. BSP models will set e.mins and e.maxs accordingly, other models depend upon the value of sv_gameplayfix_setmodelrealbox - for compatibility you should always call setsize after all pickups or non-bsp models. Also relinks collision state. */

void(entity e, vector min, vector max) setsize = #4; /*
		Sets the e's mins and maxs fields. Also relinks collision state, which sets absmin and absmax too. */

void() breakpoint = #6; /*
		Trigger a debugging event. FTE will break into the qc debugger. Other engines may crash with a debug execption. */

float() random = #7; /*
		Returns a random value between 0 and 1. Be warned, this builtin can return 1 in most engines, which can break arrays. */

void(entity e, float chan, string samp, float vol, float atten, optional float speedpct, optional float flags, optional float timeofs) sound = #8; /*
		Starts a sound centered upon the given entity.
		chan is the entity sound channel to use, channel 0 will allow you to mix many samples at once, others will replace the old sample
		'samp' must have been precached first
		if specified, 'speedpct' should normally be around 100 (or =0), 200 for double speed or 50 for half speed.
		If flags is specified, the reliable flag in the channels argument is used for additional channels. Flags should be made from SOUNDFLAG_* constants
		timeofs should be negative in order to provide a delay before the sound actually starts. */

vector(vector v) normalize = #9; /*
		Shorten or lengthen a direction vector such that it is only one quake unit long. */

void(string e) error = #10; /*
		Ends the game with an easily readable error message. */

void(string e) objerror = #11; /*
		Displays a non-fatal easily readable error message concerning the self entity, including a field dump. self will be removed! */

float(vector v) vlen = #12; /*
		Returns the square root of the dotproduct of a vector with itself. Or in other words the length of a distance vector, in quake units. */

float(vector v, optional entity reference) vectoyaw = #13; /*
		Given a direction vector, returns the yaw angle in which that direction vector points. If an entity is passed, the yaw angle will be relative to that entity's gravity direction. */

entity() spawn = #14; /*
		Adds a brand new entity into the world! Hurrah, you're now a parent! */

void(entity e) remove = #15; /*
		Destroys the given entity and clears some limited fields (including model, modelindex, solid, classname). Any references to the entity following the call are an error. After two seconds, the entity will be reused, in the interim you can unfortunatly still read its fields to see if the reference is no longer valid. */

void(vector v1, vector v2, float flags, entity ent) traceline = #16; /*
		Traces a thin line through the world from v1 towards v2.
		Will not collide with ent, ent.owner, or any entity who's owner field refers to ent.
		The passed entity will also be used to determine whether to use a capsule trace, the contents that the trace should impact, and a couple of other extra fields that define the trace.
		There are no side effects beyond the trace_* globals being written.
		flags&MOVE_NOMONSTERS will not impact on non-bsp entities.
		flags&MOVE_MISSILE will impact with increased size.
		flags&MOVE_HITMODEL will impact upon model meshes, instead of their bounding boxes.
		flags&MOVE_TRIGGERS will also stop on triggers
		flags&MOVE_EVERYTHING will stop if it hits anything, even non-solid entities.
		flags&MOVE_LAGGED will backdate entity positions for the purposes of this builtin according to the indicated player ent's latency, to provide lag compensation. */

entity() checkclient = #17; /*
		Returns one of the player entities. The returned player will change periodically. */

entity(entity start, .string fld, string match) find = #18; /*
		Scan for the next entity with a given field set to the given 'match' value. start should be either world, or the previous entity that was found. Returns world on failure/if there are no more.
		If you have many many entities then you may find that hashtables will give more performance (but requires extra upkeep). */

string(string s) precache_sound = #19; /*
		Precaches a sound, making it known to clients and loading it from disk. This builtin (strongly) should be called during spawn functions. This builtin must be called for the sound before the sound builtin is called, or it might not even be heard. */

string(string s) precache_model = #20; /*
		Precaches a model, making it known to clients and loading it from disk if it has a .bsp extension. This builtin (strongly) should be called during spawn functions. This must be called for each model name before setmodel may use that model name.
		Modelindicies precached in SSQC will always be positive. CSQC precaches will be negative if they are not also on the server. */

void(entity client, string s) stuffcmd = #21; /*
		Sends a console command (or cvar) to the client, where it will be executed. Different clients support different commands. Do NOT forget the final \n.
		This builtin is generally considered evil. */

void(entity client, float flags, string s) stuffcmdflags = #0:stuffcmdflags; /* Part of FTE_QC_STUFFCMDFLAGS
		Sends a console command (or cvar) to the client, where it will be executed. Different clients support different commands. Do NOT forget the final \n.
		This (just as evil) variant allows specifying some flags too. See the STUFFCMD_* constants. */

entity(vector org, float rad, optional .entity chainfield) findradius = #22; /*
		Finds all entities within a distance of the 'org' specified. One entity is returned directly, while other entities are returned via that entity's .chain field. */

void(float msglvl, string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7) bprint = #23; /*
		QW: Concatenates all string arguments, and prints the messsage on the console of only all clients who's 'msg' infokey is set lower or equal to the supplied 'msglvl' argument. */

void(entity client, float msglvl, string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6) sprint = #24; /*
		QW: Concatenates all string arguments, and prints the messsage on the named client's console, but only if that client's 'msg' infokey is set lower or equal to the supplied 'msglvl' argument. */

void(string s, ...) dprint = #25; /*
		QW: Unconditionally prints the given message on the server's console.  Arguments will be concatenated into a single message. */

string(float val) ftos = #26; /*
		Returns a tempstring containing a representation of the given float. Precision depends upon engine. */

string(vector val) vtos = #27; /*
		Returns a tempstring containing a representation of the given vector. Precision depends upon engine. */

void() coredump = #28; /*
		Writes out a coredump. This contains stack, globals, and field info for all ents. This can be handy for debugging. */

void() traceon = #29; /*
		Enables tracing. This may be spammy, slow, and stuff. Set debugger 1 in order to use fte's qc debugger. */

void() traceoff = #30; /*
		Disables tracing again. */

void(entity e) eprint = #31; /*
		Debugging builtin that prints all fields of the given entity to the console. */

float(float yaw, float dist, optional float settraceglobals) walkmove = #32; /*
		Attempt to walk the entity at a given angle for a given distance.
		if settraceglobals is set, the trace_* globals will be set, showing the results of the movement.
		This function will trigger touch events. */

float() droptofloor = #34; /*
		Instantly moves the entity downwards until it hits the ground. If the entity is in solid or would need to drop more than 'pr_droptofloorunits' quake units, its position will be considered invalid and the builtin will abort, returning FALSE, otherwise TRUE. */

void(float lightstyle, string stylestring, optional vector rgb) lightstyle = #35; /*
		Specifies an auto-animating string that specifies the light intensity for entities using that lightstyle.
		a is off, z is fully lit. Should be lower case only.
		rgb will recolour all lights using that lightstyle. */

float(float) rint = #36; /*
		Rounds the given float up or down to the closest integeral value. X.5 rounds away from 0 */

float(float) floor = #37; /*
		Rounds the given float downwards, even when negative. */

float(float) ceil = #38; /*
		Rounds the given float upwards, even when negative. */

float(entity ent) checkbottom = #40; /*
		Expensive checks to ensure that the entity is actually sitting on something solid, returns true if it is. */

float(vector pos) pointcontents = #41; /*
		Checks the given point to see what is there. Returns one of the SOLID_* constants. Just because a spot is empty does not mean that the player can stand there due to the size of the player - use tracebox for such tests. */

float(float) fabs = #43; /*
		Removes the sign of the float, making it positive if it is negative. */

vector(entity player, float missilespeed) aim = #44; /*
		Returns a direction vector (specifically v_forward on error). This builtin attempts to guess what pitch angle to fire projectiles at for people that don't know about mouselook. Does not affect yaw angles. */

float(string) cvar = #45; /*
		Returns the numeric value of the named cvar */

void(string, ...) localcmd = #46; /*
		Adds the string to the console command queue. Commands will not be executed immediately, but rather at the start of the following frame. */

entity(entity) nextent = #47; /*
		Returns the following entity. Skips over removed entities. Returns world when passed the last valid entity. */

void(vector pos, vector dir, float colour, float count) particle = #48; /*
		Spawn 'count' particles around 'pos' moving in the direction 'dir', with a palette colour index between 'colour' and 'colour+8'. */

#define ChangeYaw changeyaw
void() changeyaw = #49; /*
		Changes the self.angles_y field towards self.ideal_yaw by up to self.yaw_speed. */

vector(vector fwd, optional vector up) vectoangles = #51; /*
		Returns the angles (+x=UP) required to orient an entity to look in the given direction. The 'up' argument is required if you wish to set a roll angle, otherwise it will be limited to just monster-style turning. */

void(float to, float val) WriteByte = #52; /*
		Writes a single byte into a network message buffer. Typically you will find a more correct alternative to writing arbitary data. 'to' should be one of the MSG_* constants. MSG_ONE must have msg_entity set first. */

void(float to, float val) WriteChar = #53;
void(float to, float val) WriteShort = #54;
void(float to, float val) WriteLong = #55;
void(float to, float val) WriteCoord = #56;
void(float to, float val) WriteAngle = #57;
void(float to, string val) WriteString = #58;
void(float to, entity val) WriteEntity = #59;
float(float angle) sin = #60; /* Part of DP_QC_SINCOSSQRTPOW
		Forgive me father, for I have trigonometry homework. */

float(float angle) cos = #61; /* Part of DP_QC_SINCOSSQRTPOW*/
float(float value) sqrt = #62; /* Part of DP_QC_SINCOSSQRTPOW*/
float(float a, float n) modulo = #0:modulo;
void(entity ent) changepitch = #63; /* Part of DP_QC_CHANGEPITCH*/
void(entity ent, entity ignore) tracetoss = #64;
string(entity ent) etos = #65; /* Part of DP_QC_ETOS*/
void(float step) movetogoal = #67; /*
		Runs lots and lots of fancy logic in order to try to step the entity the specified distance towards its goalentity. */

string(string s) precache_file = #68; /*
		This builtin does nothing. It was used only as a hint for pak generation. */

void(entity e) makestatic = #69; /*
		Sends a copy of the entity's renderable fields to all clients, and REMOVES the entity, preventing further changes. This means it will be unmutable and non-solid. */

void(string mapname, optional string newmapstartspot) changelevel = #70; /*
		Attempts to change the map to the named map. If 'newmapstartspot' is specified, the state of the current map will be preserved, and the argument will be passed to the next map in the 'startspot' global, and the next map will be loaded from archived state if it was previously visited. If not specified, all archived map states will be purged. */

void(string cvarname, string valuetoset) cvar_set = #72; /*
		Instantly sets a cvar to the given string value. */

void(entity ent, string text, optional string text2, optional string text3, optional string text4, optional string text5, optional string text6, optional string text7) centerprint = #73;
void (vector pos, string samp, float vol, float atten) ambientsound = #74;
string(string str) precache_model2 = #75;
string(string str) precache_sound2 = #76;
string(string str) precache_file2 = #77;
void(entity player) setspawnparms = #78;
void(entity killer, entity killee) logfrag = #79; /* Part of QW_ENGINE*/
string(entity e, string key) infokey = #80; /* Part of FTE_QC_INFOKEY, QW_ENGINE
		If e is world, returns the field 'key' from either the serverinfo or the localinfo. If e is a player, returns the value of 'key' from the player's userinfo string. There are a few special exceptions, like 'ip' which is not technically part of the userinfo. */

float(entity e, string key) infokeyf = #0:infokeyf; /*
		Identical to regular infokey, except returns a float. */

float(string) stof = #81; /* Part of FRIK_FILE, FTE_QC_INFOKEY, FTE_STRINGS, QW_ENGINE, ZQ_QC_STRINGS*/
#define unicast(pl,reli) do{msg_entity = pl; multicast('0 0 0', reli?MULITCAST_ONE_R:MULTICAST_ONE);}while(0)
void(vector where, float set) multicast = #82; /* Part of FTE_QC_MULTICAST
		Once the MSG_MULTICAST network message buffer has been filled with data, this builtin is used to dispatch it to the given target, filtering by pvs for reduced network bandwidth. */

void(entity to, string str) redirectcmd = #101; /* Part of ??MVDSV_BUILTINS
		Executes a single console command, and sends the text generated by it to the specified player. The command will be executed at the end of the frame once QC is no longer running - you may wish to pre/postfix it with 'echo'. */

string(float style, optional __out vector rgb) getlightstyle = #0:getlightstyle; /*
		Obtains the light style string for the given style. */

vector(float style) getlightstylergb = #0:getlightstylergb; /*
		Obtains the current rgb value of the specified light style. In csqc, this is correct with regard to the current frame, while ssqc gives no guarentees about time and ignores client cvars. Note: use getlight if you want the actual light value at a point. */

void(float style, float val, optional vector rgb) lightstylestatic = #5; /*
		Sets the lightstyle to an explicit numerical level. From Hexen2. */

void(vector start, vector mins, vector maxs, vector end, float nomonsters, entity ent) tracebox = #90; /* Part of DP_QC_TRACEBOX
		Exactly like traceline, but a box instead of a uselessly thin point. Acceptable sizes are limited by bsp format, q1bsp has strict acceptable size values. */

vector() randomvec = #91; /* Part of DP_QC_RANDOMVEC
		Returns a vector with random values. Each axis is independantly a value between -1 and 1 inclusive. */

vector(vector org) getlight = #92;
float(string cvarname, string defaultvalue) registercvar = #93; /* Part of DP_REGISTERCVAR
		Creates a new cvar on the fly. If it does not already exist, it will be given the specified value. If it does exist, this is a no-op.
		This builtin has the limitation that it does not apply to configs or commandlines. Such configs will need to use the set or seta command causing this builtin to be a noop.
		In engines that support it, you will generally find the autocvar feature easier and more efficient to use. */

float(float a, float b, ...) min = #94; /* Part of DP_QC_MINMAXBOUND
		Returns the lowest value of its arguments. */

float(float a, float b, ...) max = #95; /* Part of DP_QC_MINMAXBOUND
		Returns the highest value of its arguments. */

float(float minimum, float val, float maximum) bound = #96; /* Part of DP_QC_MINMAXBOUND
		Returns val, unless minimum is higher, or maximum is less. */

float(float value, float exp) pow = #97; /* Part of DP_QC_SINCOSSQRTPOW*/
float(float v, optional float base) logarithm = #0:logarithm; /*
		Determines the logarithm of the input value according to the specified base. This can be used to calculate how much something was shifted by. */

#define findentity findfloat
entity(entity start, .__variant fld, __variant match) findfloat = #98; /* Part of DP_QC_FINDFLOAT
		Equivelent to the find builtin, but instead of comparing strings contents, this builtin compares the raw values. This builtin requires multiple calls in order to scan all entities - set start to the previous call's return value.
		world is returned when there are no more entities. */

float(string extname) checkextension = #99; /*
		Checks for an extension by its name (eg: checkextension("FRIK_FILE") says that its okay to go ahead and use strcat).
		Use cvar("pr_checkextension") to see if this builtin exists. */

float(__variant funcref) checkbuiltin = #0:checkbuiltin; /*
		Checks to see if the specified builtin is supported/mapped. This is intended as a way to check for #0 functions, allowing for simple single-builtin functions. Warning, if two different engines map different builtins to the same number, then this function will not tell you which will be called, only that it won't crash (the exception being #0, which are remapped as available). */

float(string builtinname) builtin_find = #100; /*
		Looks to see if the named builtin is valid, and returns the builtin number it exists at. */

float(float value) anglemod = #102;
void(string slot, string picname, float x, float y, float zone, optional entity player) showpic = #104; /* Part of TEI_SHOWLMP2*/
void(string slot, optional entity player) hidepic = #105; /* Part of TEI_SHOWLMP2*/
void(string slot, float x, float y, float zone, optional entity player) movepic = #106; /* Part of TEI_SHOWLMP2*/
void(string slot, string picname, optional entity player) changepic = #107; /* Part of TEI_SHOWLMP2*/
filestream(string filename, float mode, optional float mmapminsize) fopen = #110; /* Part of FRIK_FILE
		Opens a file, typically prefixed with "data/", for either read or write access. */

void(filestream fhandle) fclose = #111; /* Part of FRIK_FILE*/
string(filestream fhandle) fgets = #112; /* Part of FRIK_FILE
		Reads a single line out of the file. The new line character is not returned as part of the string. Returns the null string on EOF (use if not(string) to easily test for this, which distinguishes it from the empty string which is returned if the line being read is blank */

void(filestream fhandle, string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7) fputs = #113; /* Part of FRIK_FILE
		Writes the given string(s) into the file. For compatibility with fgets, you should ensure that the string is terminated with a \n - this will not otherwise be done for you. It is up to the engine whether dos or unix line endings are actually written. */

int(filestream fhandle, void *ptr, int size) fread = #0:fread; /* Part of FTE_QC_FILE_BINARY
		Reads binary data out of the file. Returns truncated lengths if the read exceeds the length of the file. */

int(filestream fhandle, void *ptr, int size) fwrite = #0:fwrite; /* Part of FTE_QC_FILE_BINARY
		Writes binary data out of the file. */

#define ftell fseek //c compat
int(filestream fhandle, optional int newoffset) fseek = #0:fseek; /* Part of FTE_QC_FILE_BINARY
		Changes the current position of the file, if specified. Returns prior position, in bytes. */

int(filestream fhandle, optional int newsize) fsize = #0:fsize; /* Part of FTE_QC_FILE_BINARY
		Reports the total size of the file, in bytes. Can also be used to truncate/extend the file */

float(string s) strlen = #114; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
string(string s1, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7, optional string s8) strcat = #115; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
string(string s, float start, float length) substring = #116; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
vector(string s) stov = #117; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS*/
string(string s, ...) strzone = #118; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS
		Create a semi-permanent copy of a string that only becomes invalid once strunzone is called on the string (instead of when the engine assumes your string has left scope). This builtin has become redundant in FTEQW due to the FTE_QC_PERSISTENTTEMPSTRINGS extension and is now functionally identical to strcat for compatibility with old engines+mods. */

void(string s) strunzone = #119; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS
		Destroys a string that was allocated by strunzone. Further references to the string MAY crash the game. In FTE, this function became redundant and now does nothing. */

void(string cvar, float val) cvar_setf = #176;
void(string soundname, optional float channel, optional float volume) localsound = #177; /*
		Plays a sound... locally... probably best not to call this from ssqc. Also disables reverb. */

float(string modelname, optional float queryonly) getmodelindex = #200; /*
		Acts as an alternative to precache_model(foo);setmodel(bar, foo); return bar.modelindex;
		If queryonly is set and the model was not previously precached, the builtin will return 0 without needlessly precaching the model. */

__variant(float prnum, string funcname, ...) externcall = #201; /* Part of FTE_MULTIPROGS
		Directly call a function in a different/same progs by its name.
		prnum=0 is the 'default' or 'main' progs.
		prnum=-1 means current progs.
		prnum=-2 will scan through the active progs and will use the first it finds. */

float(string progsname) addprogs = #202; /* Part of FTE_MULTIPROGS
		Loads an additional .dat file into the current qcvm. The returned handle can be used with any of the externcall/externset/externvalue builtins.
		There are cvars that allow progs to be loaded automatically. */

__variant(float prnum, string varname) externvalue = #203; /* Part of FTE_MULTIPROGS
		Reads a global in the named progs by the name of that global.
		prnum=0 is the 'default' or 'main' progs.
		prnum=-1 means current progs.
		prnum=-2 will scan through the active progs and will use the first it finds. */

void(float prnum, __variant newval, string varname) externset = #204; /* Part of FTE_MULTIPROGS
		Sets a global in the named progs by name.
		prnum=0 is the 'default' or 'main' progs.
		prnum=-1 means current progs.
		prnum=-2 will scan through the active progs and will use the first it finds. */

void(entity portal, float state) openportal = #207; /*
		Opens or closes the portals associated with a door or some such on q2 or q3 maps. On Q2BSPs, the entity should be the 'func_areaportal' entity - its style field will say which portal to open. On Q3BSPs, the entity is the door itself, the portal will be determined by the two areas found from a preceding setorigin call. */

float(float attributes, string effectname, ...) RegisterTempEnt = #208; /* Part of FTE_PEXT_CUSTOMTENTS*/
void(float type, vector pos, ...) CustomTempEnt = #209; /* Part of FTE_PEXT_CUSTOMTENTS*/
float(optional float sleeptime) fork = #210; /* Part of FTE_MULTITHREADED
		When called, this builtin simply returns. Twice.
		The current 'thread' will return instantly with a return value of 0. The new 'thread' will return after sleeptime seconds with a return value of 1. See documentation for the 'sleep' builtin for limitations/requirements concerning the new thread. Note that QC should probably call abort in the new thread, as otherwise the function will return to the calling qc function twice also. */

void(optional __variant ret) abort = #211; /* Part of FTE_MULTITHREADED
		QC execution is aborted. Parent QC functions on the stack will be skipped, effectively this forces all QC functions to 'return ret' until execution returns to the engine. If ret is ommited, it is assumed to be 0. */

void(float sleeptime) sleep = #212; /* Part of FTE_MULTITHREADED
		Suspends the current QC execution thread for 'sleeptime' seconds.
		Other QC functions can and will be executed in the interim, including changing globals and field state (but not simultaneously).
		The self and other globals will be restored when the thread wakes up (or set to world if they were removed since the thread started sleeping). Locals will be preserved, but will not be protected from remove calls.
		If the engine is expecting the QC to return a value (even in the parent/root function), the value 0 shall be used instead of waiting for the qc to resume. */

void(entity player, string key, string value) forceinfokey = #213; /* Part of FTE_FORCEINFOKEY
		Directly changes a user's info without pinging off the client. Also allows explicitly setting * keys, including *spectator. Does not affect the user's config or other servers. */

void(string filename, float starttag, entity edict) chat = #214; /* Part of FTE_QC_NPCCHAT*/
void(vector org, vector dmin, vector dmax, float colour, float effect, float count) particle2 = #215; /* Part of FTE_HEXEN2*/
void(vector org, vector box, float colour, float effect, float count) particle3 = #216; /* Part of FTE_HEXEN2*/
void(vector org, float radius, float colour, float effect, float count) particle4 = #217; /* Part of FTE_HEXEN2*/
float(float number, float quantity) bitshift = #218; /* Part of EXT_BITSHIFT*/
void(vector pos) te_lightningblood = #219; /* Part of FTE_TE_STANDARDEFFECTBUILTINS*/
float(string s1, string sub, optional float startidx) strstrofs = #221; /* Part of FTE_STRINGS
		Returns the 0-based offset of sub within the s1 string, or -1 if sub is not in s1.
		If startidx is set, this builtin will ignore matches before that 0-based offset. */

float(string str, float index) str2chr = #222; /* Part of FTE_STRINGS
		Retrieves the character value at offset 'index'. */

string(float chr, ...) chr2str = #223; /* Part of FTE_STRINGS
		The input floats are considered character values, and are concatenated. */

string(float ccase, float redalpha, float redchars, string str, ...) strconv = #224; /* Part of FTE_STRINGS
		Converts quake chars in the input string amongst different representations.
		ccase specifies the new case for letters.
		 0: not changed.
		 1: forced to lower case.
		 2: forced to upper case.
		redalpha and redchars switch between colour ranges.
		 0: no change.
		 1: Forced white.
		 2: Forced red.
		 3: Forced gold(low) (numbers only).
		 4: Forced gold (high) (numbers only).
		 5+6: Forced to white and red alternately.
		You should not use this builtin in combination with UTF-8. */

string(float pad, string str1, ...) strpad = #225; /* Part of FTE_STRINGS
		Pads the string with spaces, to ensure its a specific length (so long as a fixed-width font is used, anyway). If pad is negative, the spaces are added on the left. If positive the padding is on the right. */

string(infostring old, string key, string value) infoadd = #226; /* Part of FTE_STRINGS
		Returns a new tempstring infostring with the named value changed (or added if it was previously unspecified). Key and value may not contain the \ character. */

string(infostring info, string key) infoget = #227; /* Part of FTE_STRINGS
		Reads a named value from an infostring. The returned value is a tempstring */

#define strcmp strncmp
float(string s1, string s2, optional float len, optional float s1ofs, optional float s2ofs) strncmp = #228; /* Part of FTE_STRINGS
		Compares up to 'len' chars in the two strings. s1ofs allows you to treat s2 as a substring to compare against, or should be 0.
		Returns 0 if the two strings are equal, a negative value if s1 appears numerically lower, and positive if s1 appears numerically higher. */

float(string s1, string s2) strcasecmp = #229; /* Part of FTE_STRINGS
		Compares the two strings without case sensitivity.
		Returns 0 if they are equal. The sign of the return value may be significant, but should not be depended upon. */

float(string s1, string s2, float len, optional float s1ofs, optional float s2ofs) strncasecmp = #230; /* Part of FTE_STRINGS
		Compares up to 'len' chars in the two strings without case sensitivity. s1ofs allows you to treat s2 as a substring to compare against, or should be 0.
		Returns 0 if they are equal. The sign of the return value may be significant, but should not be depended upon. */

string(string s) strtrim = #0:strtrim; /*
		Trims the whitespace from the start+end of the string. */

void() calltimeofday = #231; /* Part of FTE_CALLTIMEOFDAY
		Asks the engine to instantly call the qc's 'timeofday' function, before returning. For compatibility with mvdsv.
		timeofday should have the prototype: void(float secs, float mins, float hour, float day, float mon, float year, string strvalue)
		The strftime builtin is more versatile and less weird. */

void(float num, float type, .__variant fld) clientstat = #232; /*
		Specifies what data to use in order to send various stats, in a client-specific way.
		'num' should be a value between 32 and 127, other values are reserved.
		'type' must be set to one of the EV_* constants, one of EV_FLOAT, EV_STRING, EV_INTEGER, EV_ENTITY.
		fld must be a reference to the field used, each player will be sent only their own copy of these fields. */

void(float num, float type, string name) globalstat = #233; /*
		Specifies what data to use in order to send various stats, in a non-client-specific way. num and type are as in clientstat, name however, is the name of the global to read in the form of a string (pass "foo"). */

void(float num, float type, __variant *address) pointerstat = #0:pointerstat; /*
		Specifies what data to use in order to send various stats, in a non-client-specific way. num and type are as in clientstat, address however, is the address of the variable you would like to use (pass &foo). */

float(entity player) isbackbuffered = #234; /* Part of FTE_ISBACKBUFFERED
		Returns if the given player's network buffer will take multiple network frames in order to clear. If this builtin returns non-zero, you should delay or reduce the amount of reliable (and also unreliable) data that you are sending to that client. */

void(vector angle) rotatevectorsbyangle = #235; /*
		rotates the v_forward,v_right,v_up matrix by the specified angles. */

void(vector fwd, vector right, vector up) rotatevectorsbyvectors = #236;
float(float mdlindex, string skinname) skinforname = #237;
void(vector org, optional float count) te_bloodqw = #239; /* Part of FTE_TE_STANDARDEFFECTBUILTINS*/
void(entity ent) te_muzzleflash = #0:te_muzzleflash;
float(vector viewpos, entity entity) checkpvs = #240; /* Part of FTE_QC_CHECKPVS*/
entity(string match, optional float matchnum) matchclientname = #241; /* Part of FTE_QC_MATCHCLIENTNAME*/
void(string destaddress, string content) sendpacket = #242; /* Part of FTE_QC_SENDPACKET*/
float(float dividend, float divisor) mod = #245;
float(optional string host, optional string user, optional string pass, optional string defaultdb, optional string driver) sqlconnect = #250; /* Part of FTE_SQL*/
void(float serveridx) sqldisconnect = #251; /* Part of FTE_SQL*/
float(float serveridx, void(float serveridx, float queryidx, float rows, float columns, float eof, float firstrow) callback, float querytype, string query) sqlopenquery = #252; /* Part of FTE_SQL*/
void(float serveridx, float queryidx) sqlclosequery = #253; /* Part of FTE_SQL*/
string(float serveridx, float queryidx, float row, float column) sqlreadfield = #254; /* Part of FTE_SQL*/
string(float serveridx, optional float queryidx) sqlerror = #255; /* Part of FTE_SQL*/
string(float serveridx, string data) sqlescape = #256; /* Part of FTE_SQL*/
string(float serveridx) sqlversion = #257; /* Part of FTE_SQL*/
float(float serveridx, float queryidx, float row, float column) sqlreadfloat = #258; /* Part of FTE_SQL*/
int(float serveridx, float queryidx, float row, float column, __variant *ptr, int maxsize) sqlreadblob = #0:sqlreadblob;
string(float serveridx, __variant *ptr, int maxsize) sqlescapeblob = #0:sqlescapeblob;
int(string) stoi = #259; /* Part of FTE_QC_INTCONV
		Converts the given string into a true integer. Base 8, 10, or 16 is determined based upon the format of the string. */

string(int) itos = #260; /* Part of FTE_QC_INTCONV
		Converts the passed true integer into a base10 string. */

int(string) stoh = #261; /* Part of FTE_QC_INTCONV
		Reads a base-16 string (with or without 0x prefix) as an integer. Bugs out if given a base 8 or base 10 string. :P */

string(int) htos = #262; /* Part of FTE_QC_INTCONV
		Formats an integer as a base16 string, with leading 0s and no prefix. Always returns 8 characters. */

int(float) ftoi = #0:ftoi; /* Part of FTE_QC_INTCONV
		Converts the given float into a true integer without depending on extended qcvm instructions. */

float(int) itof = #0:itof; /* Part of FTE_QC_INTCONV
		Converts the given true integer into a float without depending on extended qcvm instructions. */

float(float modlindex, optional float useabstransforms) skel_create = #263; /* Part of FTE_CSQC_SKELETONOBJECTS
		Allocates a new uninitiaised skeletal object, with enough bone info to animate the given model.
		eg: self.skeletonobject = skel_create(self.modelindex); */

typedef struct
{
	int sourcemodelindex; /*frame data will be imported from this model, bones must be compatible*/
	int reserved;
	int firstbone;
	int lastbone;
	float prescale;	/*0 destroys existing data, 1 retains it*/
	float scale[4];	/*you'll need to do lerpfrac manually*/
	int animation[4];
	float animationtime[4];
	/*halflife models*/
	float subblend[2];
	float controllers[5];
} skelblend_t;
float(float skel, entity ent, float modelindex, float retainfrac, float firstbone, float lastbone, optional float addfrac) skel_build = #264; /* Part of FTE_CSQC_SKELETONOBJECTS
		Animation data (according to the entity's frame info) is pulled from the specified model and blended into the specified skeletal object.
		If retainfrac is set to 0 on the first call and 1 on the others, you can blend multiple animations together according to the addfrac value. The final weight should be 1. Other values will result in scaling and/or other weirdness. You can use firstbone and lastbone to update only part of the skeletal object, to allow legs to animate separately from torso, use 0 for both arguments to specify all, as bones are 1-based. */

float(float skel, int numblends, skelblend_t *weights, int structsize) skel_build_ptr = #0:skel_build_ptr; /*
		Like skel_build, but slightly simpler. */

float(float skel) skel_get_numbones = #265; /* Part of FTE_CSQC_SKELETONOBJECTS
		Retrives the number of bones in the model. The valid range is 1<=bone<=numbones. */

string(float skel, float bonenum) skel_get_bonename = #266; /* Part of FTE_CSQC_SKELETONOBJECTS
		Retrieves the name of the specified bone. Mostly only for debugging. */

float(float skel, float bonenum) skel_get_boneparent = #267; /* Part of FTE_CSQC_SKELETONOBJECTS
		Retrieves which bone this bone's position is relative to. Bone 0 refers to the entity's position rather than an actual bone */

float(float skel, string tagname) skel_find_bone = #268; /* Part of FTE_CSQC_SKELETONOBJECTS
		Finds a bone by its name, from the model that was used to create the skeletal object. */

vector(float skel, float bonenum) skel_get_bonerel = #269; /* Part of FTE_CSQC_SKELETONOBJECTS
		Gets the bone position and orientation relative to the bone's parent. Return value is the offset, and v_forward, v_right, v_up contain the orientation. */

vector(float skel, float bonenum) skel_get_boneabs = #270; /* Part of FTE_CSQC_SKELETONOBJECTS
		Gets the bone position and orientation relative to the entity. Return value is the offset, and v_forward, v_right, v_up contain the orientation.
		Use gettaginfo for world coord+orientation. */

void(float skel, float bonenum, vector org, optional vector fwd, optional vector right, optional vector up) skel_set_bone = #271; /* Part of FTE_CSQC_SKELETONOBJECTS
		Sets a bone position relative to its parent. If the orientation arguments are not specified, v_forward+v_right+v_up are used instead. */

void(float skel, float bonenum, vector org, optional vector fwd, optional vector right, optional vector up) skel_premul_bone = #272; /* Part of FTE_CSQC_SKELETONOBJECTS
		Transforms a single bone by a matrix. You can use makevectors to generate a rotation matrix from an angle. */

void(float skel, float startbone, float endbone, vector org, optional vector fwd, optional vector right, optional vector up) skel_premul_bones = #273; /* Part of FTE_CSQC_SKELETONOBJECTS
		Transforms an entire consecutive range of bones by a matrix. You can use makevectors to generate a rotation matrix from an angle, but you'll probably want to divide the angle by the number of bones. */

void(float skel, float bonenum, vector org, optional vector fwd, optional vector right, optional vector up) skel_postmul_bone = #0:skel_postmul_bone; /*
		Transforms a single bone by a matrix. You can use makevectors to generate a rotation matrix from an angle. */

void(float skeldst, float skelsrc, float startbone, float entbone) skel_copybones = #274; /* Part of FTE_CSQC_SKELETONOBJECTS
		Copy bone data from one skeleton directly into another. */

void(float skel) skel_delete = #275; /* Part of FTE_CSQC_SKELETONOBJECTS
		Deletes a skeletal object. The actual delete is delayed, allowing the skeletal object to be deleted in an entity's predraw function yet still be valid by the time the addentity+renderscene builtins need it. Also uninstanciates any ragdoll currently in effect on the skeletal object. */

float(float modidx, string framename) frameforname = #276; /* Part of FTE_CSQC_SKELETONOBJECTS
		Looks up a framegroup from a model by name, avoiding the need for hardcoding. Returns -1 on error. */

float(float modidx, float framenum) frameduration = #277; /* Part of FTE_CSQC_SKELETONOBJECTS
		Retrieves the duration (in seconds) of the specified framegroup. */

void(float modidx, float framenum, __inout float basetime, float targettime, void(float timestamp, int code, string data) callback) processmodelevents = #0:processmodelevents; /* Part of FTE_GFX_MODELEVENTS
		Calls a callback for each event that has been reached. Basetime is set to targettime. */

float(float modidx, float framenum, __inout float basetime, float targettime, __out int code, __out string data) getnextmodelevent = #0:getnextmodelevent; /*
		Reports the next event within a model's animation. Returns a boolean if an event was found between basetime and targettime. Writes to basetime,code,data arguments (if an event was found, basetime is set to the event's time, otherwise to targettime).
		WARNING: this builtin cannot deal with multiple events with the same timestamp (only the first will be reported). */

float(float modidx, float framenum, int eventidx, __out float timestamp, __out int code, __out string data) getmodeleventidx = #0:getmodeleventidx; /*
		Reports an indexed event within a model's animation. Writes to timestamp,code,data arguments on success. Returns false if the animation/event/model was out of range/invalid. Does not consider looping animations (retry from index 0 if it fails and you know that its a looping animation). This builtin is more annoying to use than getnextmodelevent, but can be made to deal with multiple events with the exact same timestamp. */

#define dotproduct(v1,v2) ((vector)(v1)*(vector)(v2))
vector(vector v1, vector v2) crossproduct = #0:crossproduct; /* Part of FTE_QC_CROSSPRODUCT
		Small helper function to calculate the crossproduct of two vectors. */

float(entity pusher, vector move, vector amove) pushmove = #0:pushmove;
void(float action, optional vector pos, optional float radius, optional float quant, ...) terrain_edit = #278; /* Part of FTE_TERRAIN_MAP
		Realtime terrain editing. Actions are the TEREDIT_ constants. */

typedef struct
{
	string	shadername;
	vector	planenormal;
	float	planedist;
	vector	sdir;
	float	sbias;
	vector	tdir;
	float	tbias;
} brushface_t;
int(float modelidx, int brushid, brushface_t *out_faces, int maxfaces, int *out_contents) brush_get = #0:brush_get; /* Part of FTE_RAW_MAP
		Queries a brush's information. You must pre-allocate the face array for the builtin to write to. Return value is the number of faces retrieved, 0 on error. */

int(float modelidx, brushface_t *in_faces, int numfaces, int contents, optional int brushid) brush_create = #0:brush_create; /* Part of FTE_RAW_MAP
		Inserts a new brush into the model. Return value is the new brush's id. */

void(float modelidx, int brushid) brush_delete = #0:brush_delete; /* Part of FTE_RAW_MAP
		Destroys the specified brush. */

float(float modelid, int brushid, int faceid, float selectedstate) brush_selected = #0:brush_selected; /* Part of FTE_RAW_MAP
		Allows you to easily set transient visual properties of a brush. returns old value. selectedstate=-1 changes nothing (called for its return value). */

int(float modelid, int brushid, int faceid, vector *points, int maxpoints) brush_getfacepoints = #0:brush_getfacepoints; /* Part of FTE_RAW_MAP
		Returns the list of verticies surrounding the given face. If face is 0, returns the center of the brush (if space for 1 point) or the mins+maxs (if space for 2 points). */

int(int faceid, brushface_t *in_faces, int numfaces, vector *points, int maxpoints) brush_calcfacepoints = #0:brush_calcfacepoints; /* Part of FTE_RAW_MAP
		Determines the points of the specified face, if the specified brush were to actually be created. */

int(float modelid, vector *planes, float *dists, int numplanes, int *out_brushes, int *out_faces, int maxresults) brush_findinvolume = #0:brush_findinvolume; /* Part of FTE_RAW_MAP
		Allows you to easily obtain a list of brushes+faces within the given bounding region. If out_faces is not null, the same brush might be listed twice. */

void(optional entity ent, optional vector neworigin) touchtriggers = #279; /*
		Triggers a touch events between self and every SOLID_TRIGGER entity that it is in contact with. This should typically just be the triggers touch functions. Also optionally updates the origin of the moved entity. */

void(float buf, float fl) WriteFloat = #280;
float(entity skelent, string dollcmd, float animskel) skel_ragupdate = #281; /*
		Updates the skeletal object attached to the entity according to its origin and other properties.
		if animskel is non-zero, the ragdoll will animate towards the bone state in the animskel skeletal object, otherwise they will pick up the model's base pose which may not give nice results.
		If dollcmd is not set, the ragdoll will update (this should be done each frame).
		If the doll is updated without having a valid doll, the model's default .doll will be instanciated.
		commands:
		 doll foo.doll : sets up the entity to use the named doll file
		 dollstring TEXT : uses the doll file directly embedded within qc, with that extra prefix.
		 cleardoll : uninstanciates the doll without destroying the skeletal object.
		 animate 0.5 : specifies the strength of the ragdoll as a whole 
		 animatebody somebody 0.5 : specifies the strength of the ragdoll on a specific body (0 will disable ragdoll animations on that body).
		 enablejoint somejoint 1 : enables (or disables) a joint. Disabling joints will allow the doll to shatter. */

float*(float skel) skel_mmap = #282; /*
		Map the bones in VM memory. They can then be accessed via pointers. Each bone is 12 floats, the four vectors interleaved (sadly). */

void(entity ent, float bonenum, vector org, optional vector angorfwd, optional vector right, optional vector up) skel_set_bone_world = #283; /*
		Sets the world position of a bone within the given entity's attached skeletal object. The world position is dependant upon the owning entity's position. If no orientation argument is specified, v_forward+v_right+v_up are used for the orientation instead. If 1 is specified, it is understood as angles. If 3 are specified, they are the forawrd/right/up vectors to use. */

string(float modidx, float framenum) frametoname = #284;
string(float modidx, float skin) skintoname = #285;
float(float resourcetype, float tryload, string resourcename) resourcestatus = #286; /*
		resourcetype must be one of the RESTYPE_ constants. Returns one of the RESSTATE_ constants. Tryload 0 is a query only. Tryload 1 will attempt to reload the content if it was flushed. */

hashtable(float tabsize, optional float defaulttype) hash_createtab = #287; /* Part of FTE_QC_HASHTABLES
		Creates a hash table object with at least 'tabsize' slots. hash table with index 0 is a game-persistant table and will NEVER be returned by this builtin (except as an error return). */

void(hashtable table) hash_destroytab = #288; /* Part of FTE_QC_HASHTABLES
		Destroys a hash table object. */

void(hashtable table, string name, __variant value, optional float typeandflags) hash_add = #289; /* Part of FTE_QC_HASHTABLES
		Adds the given key with the given value to the table.
		If flags&HASH_REPLACE, the old value will be removed, if not set then multiple values may be added for a single key, they won't overwrite.
		The type argument describes how the value should be stored and saved to files. While you can claim that all variables are just vectors, being more precise can result in less issues with tempstrings or saved games. */

__variant(hashtable table, string name, optional __variant deflt, optional float requiretype, optional float index) hash_get = #290; /* Part of FTE_QC_HASHTABLES
		looks up the specified key name in the hash table. returns deflt if key was not found. If stringsonly=1, the return value will be in the form of a tempstring, otherwise it'll be the original value argument exactly as it was. If requiretype is specified, then values not of the specified type will be ignored. Hurrah for multiple types with the same name. */

__variant(hashtable table, string name) hash_delete = #291; /* Part of FTE_QC_HASHTABLES
		removes the named key. returns the value of the object that was destroyed, or 0 on error. */

string(hashtable table, float idx) hash_getkey = #292; /* Part of FTE_QC_HASHTABLES
		gets some random key name. add+delete can change return values of this, so don't blindly increment the key index if you're removing all. */

float(string name) checkcommand = #294; /* Part of FTE_QC_CHECKCOMMAND
		Checks to see if the supplied name is a valid command, cvar, or alias. Returns 0 if it does not exist. */

string(string s) argescape = #295; /*
		Marks up a string so that it can be reliably tokenized as a single argument later. */

void(string dest, string from, string cmd, string info) clusterevent = #0:clusterevent; /*
		Only functions in mapcluster mode. Sends an event to whichever server the named player is on. The destination server can then dispatch the event to the client or handle it itself via the SV_ParseClusterEvent entrypoint. If dest is empty, the event is broadcast to ALL servers. If the named player can't be found, the event will be returned to this server with the cmd prefixed with 'error:'. */

string(entity player, optional string newnode) clustertransfer = #0:clustertransfer; /*
		Only functions in mapcluster mode. Initiate transfer of the player to a different node. Can take some time. If dest is specified, returns null on error. Otherwise returns the current/new target node (or null if not transferring). */

float(float mdlidx) modelframecount = #0:modelframecount; /*
		Retrieves the number of frames in the specified model. */

void(string texturename, optional float flags, optional float is2d) R_BeginPolygon = #306; /*
		Specifies the shader to use for the following polygons, along with optional flags.
		If is2d, the polygon will be drawn as soon as the EndPolygon call is made, rather than waiting for renderscene. This allows complex 2d effects. */

void(vector org, vector texcoords, vector rgb, float alpha) R_PolygonVertex = #307; /*
		Specifies a polygon vertex with its various properties. */

void() R_EndPolygon = #308; /*
		Ends the current polygon. At least 3 verticies must have been specified. You do not need to call beginpolygon if you wish to draw another polygon with the same shader. */

float(string effectname) particleeffectnum = #335; /* Part of DP_ENT_TRAILEFFECTNUM, FTE_SV_POINTPARTICLES
		Precaches the named particle effect. If your effect name is of the form 'foo.bar' then particles/foo.cfg will be loaded by the client if foo.bar was not already defined.
		Different engines will have different particle systems, this specifies the QC API only. */

void(float effectnum, entity ent, vector start, vector end) trailparticles = #336; /* Part of FTE_SV_POINTPARTICLES
		Draws the given effect between the two named points. If ent is not world, distances will be cached in the entity in order to avoid framerate dependancies. The entity is not otherwise used. */

void(float effectnum, vector origin, optional vector dir, optional float count) pointparticles = #337; /* Part of FTE_SV_POINTPARTICLES
		Spawn a load of particles from the given effect at the given point traveling or aiming along the direction specified. The number of particles are scaled by the count argument.
		For regular particles, the dir vector is multiplied by the 'veladd' property (while orgadd will push the particles along it). Decals will use it as a hint to align to the correct surface. In both cases, it should normally be a unit vector, but other lengths will still work. If it has length 0 then FTE will assume downwards. */

void(string s, ...) print = #339; /* Part of DP_SV_PRINT
		Unconditionally print on the local system's console, even in ssqc (doesn't care about the value of the developer cvar). */

void(entity ent) runstandardplayerphysics = #347; /*
		Perform the engine's standard player movement prediction upon the given entity using the input_* globals to describe movement. */

float(entity ent) wasfreed = #353; /*
		Quickly check to see if the entity is currently free. This function is only valid during the two-second non-reuse window, after that it may give bad results. Try one second to make it more robust. */

string(string key) serverkey = #354; /*
		Look up a key in the server's public serverinfo string */

float(string key, optional float assumevalue) serverkeyfloat = #0:serverkeyfloat; /*
		Version of serverkey that returns the value as a float (which avoids tempstrings). */

__variant*(int size) memalloc = #384; /* Part of FTE_MEMALLOC
		Allocate an arbitary block of memory */

void(__variant *ptr) memfree = #385; /* Part of FTE_MEMALLOC
		Frees a block of memory that was allocated with memfree */

void(__variant *dst, __variant *src, int size) memcpy = #386; /* Part of FTE_MEMALLOC
		Copys memory from one location to another */

void(__variant *dst, int val, int size) memfill8 = #387; /* Part of FTE_MEMALLOC
		Sets an entire block of memory to a specified value. Pretty much always 0. */

__variant(__variant *dst, float ofs) memgetval = #388; /*
		Looks up the 32bit value stored at a pointer-with-offset. */

void(__variant *dst, float ofs, __variant val) memsetval = #389; /*
		Changes the 32bit value stored at the specified pointer-with-offset. */

__variant*(__variant *base, float ofs) memptradd = #390; /*
		Perform some pointer maths. Woo. */

float(string s) memstrsize = #0:memstrsize; /*
		strlen, except ignores utf-8 */

float(entity e, float nowreadonly) entityprotection = #0:entityprotection; /*
		Changes the protection on the specified entity to protect it from further edits from QC. The return value is the previous setting. Note that this can be used to unprotect the world, but doing so long term is not advised as you will no longer be able to detect invalid entity references. Also, world is not networked, so results might not be seen by clients (or in other words, world.avelocity_y=64 is a bad idea). */

entity(entity from, optional entity to) copyentity = #400; /* Part of DP_QC_COPYENTITY
		Copies all fields from one entity to another. */

void(entity ent, float colours) setcolors = #401; /*
		Changes a player's colours. The bits 0-3 are the lower/trouser colour, bits 4-7 are the upper/shirt colours. */

entity(.string field, string match, optional .entity chainfield) findchain = #402; /* Part of DP_QC_FINDCHAIN*/
entity(.float fld, float match, optional .entity chainfield) findchainfloat = #403; /* Part of DP_QC_FINDCHAINFLOAT*/
void(vector org, string modelname, float startframe, float endframe, float framerate) effect = #404; /* Part of DP_SV_EFFECT
		Spawns a self-animating sprite */

void(vector org, vector dir, float count) te_blood = #405; /* Part of DP_TE_BLOOD*/
void(vector mincorner, vector maxcorner, float explosionspeed, float howmany) te_bloodshower = #406; /* Part of _DP_TE_BLOODSHOWER*/
void(vector org, vector color) te_explosionrgb = #407; /* Part of DP_TE_EXPLOSIONRGB*/
void(vector mincorner, vector maxcorner, vector vel, float howmany, float color, float gravityflag, float randomveljitter) te_particlecube = #408; /* Part of DP_TE_PARTICLECUBE*/
void(vector mincorner, vector maxcorner, vector vel, float howmany, float color) te_particlerain = #409; /* Part of DP_TE_PARTICLERAIN*/
void(vector mincorner, vector maxcorner, vector vel, float howmany, float color) te_particlesnow = #410; /* Part of DP_TE_PARTICLESNOW*/
void(vector org, vector vel, float howmany) te_spark = #411; /* Part of DP_TE_SPARK*/
void(vector org) te_gunshotquad = #412; /* Part of _DP_TE_QUADEFFECTS1*/
void(vector org) te_spikequad = #413; /* Part of _DP_TE_QUADEFFECTS1*/
void(vector org) te_superspikequad = #414; /* Part of _DP_TE_QUADEFFECTS1*/
void(vector org) te_explosionquad = #415; /* Part of _DP_TE_QUADEFFECTS1*/
void(vector org) te_smallflash = #416; /* Part of DP_TE_SMALLFLASH*/
void(vector org, float radius, float lifetime, vector color) te_customflash = #417; /* Part of DP_TE_CUSTOMFLASH*/
void(vector org, optional float count) te_gunshot = #418; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_spike = #419; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_superspike = #420; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_explosion = #421; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_tarexplosion = #422; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_wizspike = #423; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_knightspike = #424; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_lavasplash = #425; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org) te_teleport = #426; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(vector org, float color, float colorlength) te_explosion2 = #427; /* Part of DP_TE_STANDARDEFFECTBUILTINS*/
void(entity own, vector start, vector end) te_lightning1 = #428; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(entity own, vector start, vector end) te_lightning2 = #429; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(entity own, vector start, vector end) te_lightning3 = #430; /* Part of DP_TE_STANDARDEFFECTBUILTINS, FTE_TE_STANDARDEFFECTBUILTINS*/
void(entity own, vector start, vector end) te_beam = #431; /* Part of DP_TE_STANDARDEFFECTBUILTINS*/
void(vector dir) vectorvectors = #432; /* Part of DP_QC_VECTORVECTORS*/
void(vector org) te_plasmaburn = #433; /* Part of _DP_TE_PLASMABURN*/
float(entity e, float s) getsurfacenumpoints = #434; /* Part of DP_QC_GETSURFACE*/
vector(entity e, float s, float n) getsurfacepoint = #435; /* Part of DP_QC_GETSURFACE*/
vector(entity e, float s) getsurfacenormal = #436; /* Part of DP_QC_GETSURFACE*/
string(entity e, float s) getsurfacetexture = #437; /* Part of DP_QC_GETSURFACE*/
float(entity e, vector p) getsurfacenearpoint = #438; /* Part of DP_QC_GETSURFACE*/
vector(entity e, float s, vector p) getsurfaceclippedpoint = #439; /* Part of DP_QC_GETSURFACE*/
void(entity e, string s) clientcommand = #440; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND*/
float(string s) tokenize = #441; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND*/
string(float n) argv = #442; /* Part of KRIMZON_SV_PARSECLIENTCOMMAND*/
void(entity e, entity tagentity, string tagname) setattachment = #443; /* Part of DP_GFX_QUAKE3MODELTAGS*/
searchhandle(string pattern, float caseinsensitive, float quiet) search_begin = #444; /* Part of DP_QC_FS_SEARCH
		initiate a filesystem scan based upon filenames. Be sure to call search_end on the returned handle. */

void(searchhandle handle) search_end = #445; /* Part of DP_QC_FS_SEARCH*/
float(searchhandle handle) search_getsize = #446; /* Part of DP_QC_FS_SEARCH
		Retrieves the number of files that were found. */

string(searchhandle handle, float num) search_getfilename = #447; /* Part of DP_QC_FS_SEARCH
		Retrieves name of one of the files that was found by the initial search. */

float(searchhandle handle, float num) search_getfilesize = #0:search_getfilesize; /* Part of FTE_QC_FS_SEARCH_SIZEMTIME
		Retrieves the size of one of the files that was found by the initial search. */

string(searchhandle handle, float num) search_getfilemtime = #0:search_getfilemtime; /* Part of FTE_QC_FS_SEARCH_SIZEMTIME
		Retrieves modification time of one of the files. */

string(string cvarname) cvar_string = #448; /* Part of DP_QC_CVAR_STRING*/
entity(entity start, .float fld, float match) findflags = #449; /* Part of DP_QC_FINDFLAGS*/
entity(.float fld, float match, optional .entity chainfield) findchainflags = #450; /* Part of DP_QC_FINDCHAINFLAGS*/
float(entity ent, string tagname) gettagindex = #451; /* Part of DP_MD3_TAGSINFO*/
vector(entity ent, float tagindex) gettaginfo = #452; /* Part of DP_MD3_TAGSINFO
		Obtains the current worldspace position+orientation of the bone or tag from the given entity. The return value is the world coord, v_forward, v_right, v_up are also set according to the bone/tag's orientation. */

void(entity player) dropclient = #453; /* Part of DP_SV_DROPCLIENT*/
entity() spawnclient = #454; /* Part of DP_SV_BOTCLIENT*/
float(entity client) clienttype = #455; /* Part of DP_SV_BOTCLIENT*/
void(float target, string str) WriteUnterminatedString = #456; /* Part of DP_SV_WRITEUNTERMINATEDSTRING*/
void(vector org, vector vel, float howmany) te_flamejet = #457; /* Part of _DP_TE_FLAMEJET*/
entity(float entnum) edict_num = #459; /* Part of DP_QC_EDICT_NUM*/
strbuf() buf_create = #460; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle) buf_del = #461; /* Part of DP_QC_STRINGBUFFERS*/
float(strbuf bufhandle) buf_getsize = #462; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle_from, strbuf bufhandle_to) buf_copy = #463; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle, float sortprefixlen, float backward) buf_sort = #464; /* Part of DP_QC_STRINGBUFFERS*/
string(strbuf bufhandle, string glue) buf_implode = #465; /* Part of DP_QC_STRINGBUFFERS*/
string(strbuf bufhandle, float string_index) bufstr_get = #466; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle, float string_index, string str) bufstr_set = #467; /* Part of DP_QC_STRINGBUFFERS*/
float(strbuf bufhandle, string str, float ordered) bufstr_add = #468; /* Part of DP_QC_STRINGBUFFERS*/
void(strbuf bufhandle, float string_index) bufstr_free = #469; /* Part of DP_QC_STRINGBUFFERS*/
float(float s) asin = #471; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float c) acos = #472; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float t) atan = #473; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float c, float s) atan2 = #474; /* Part of DP_QC_ASINACOSATANATAN2TAN*/
float(float a) tan = #475; /* Part of DP_QC_ASINACOSATANATAN2TAN
		Forgive me father, for I have a sunbed and I'm not afraid to use it. */

float(string s) strlennocol = #476; /* Part of DP_QC_STRINGCOLORFUNCTIONS
		Returns the number of characters in the string after any colour codes or other markup has been parsed. */

string(string s) strdecolorize = #477; /* Part of DP_QC_STRINGCOLORFUNCTIONS
		Flattens any markup/colours, removing them from the string. */

string(float uselocaltime, string format, ...) strftime = #478; /* Part of DP_QC_STRFTIME*/
float(string s, string separator1, ...) tokenizebyseparator = #479; /* Part of DP_QC_TOKENIZEBYSEPARATOR*/
string(string s) strtolower = #480; /* Part of DP_QC_STRING_CASE_FUNCTIONS*/
string(string s) strtoupper = #481; /* Part of DP_QC_STRING_CASE_FUNCTIONS*/
string(string s) cvar_defstring = #482; /* Part of DP_QC_CVAR_DEFSTRING*/
void(vector origin, string sample, float volume, float attenuation) pointsound = #483; /* Part of DP_SV_POINTSOUND*/
string(string search, string replace, string subject) strreplace = #484; /* Part of DP_QC_STRREPLACE*/
string(string search, string replace, string subject) strireplace = #485; /* Part of DP_QC_STRREPLACE*/
vector(entity e, float s, float n, float a) getsurfacepointattribute = #486; /* Part of DP_QC_GETSURFACEPOINTATTRIBUTE*/
float(float caseinsensitive, string s, ...) crc16 = #494; /* Part of DP_QC_CRC16*/
float(string name) cvar_type = #495; /* Part of DP_QC_CVAR_TYPE*/
float() numentityfields = #496; /* Part of DP_QC_ENTITYDATA
		Gives the number of named entity fields. Note that this is not the size of an entity, but rather just the number of unique names (ie: vectors use 4 names rather than 3). */

float(string fieldname) findentityfield = #0:findentityfield; /*
		Find a field index by name. */

typedef .__variant field_t;
field_t(float fieldnum) entityfieldref = #0:entityfieldref; /*
		Returns a field value that can be directly used to read entity fields. Be sure to validate the type with entityfieldtype before using. */

string(float fieldnum) entityfieldname = #497; /* Part of DP_QC_ENTITYDATA
		Retrieves the name of the given entity field. */

float(float fieldnum) entityfieldtype = #498; /* Part of DP_QC_ENTITYDATA
		Provides information about the type of the field specified by the field num. Returns one of the EV_ values. */

string(float fieldnum, entity ent) getentityfieldstring = #499; /* Part of DP_QC_ENTITYDATA*/
float(float fieldnum, entity ent, string s) putentityfieldstring = #500; /* Part of DP_QC_ENTITYDATA*/
void(float to, string s, float sz) WritePicture = #501; /* Part of DP_SV_WRITEPICTURE
		Encodes the named image across the network as-is adhering to some size limit. In FTE, this simply writes the string and is equivelent to writestring and sz is ignored. WritePicture should be paired with ReadPicture in csqc. */

string(string filename, optional float makereferenced) whichpack = #503; /* Part of DP_QC_WHICHPACK
		Returns the pak file name that contains the file specified. progs/player.mdl will generally return something like 'pak0.pak'. If makereferenced is true, clients will automatically be told that the returned package should be pre-downloaded and used, even if allow_download_refpackages is not set. */

string(string in) uri_escape = #510; /* Part of DP_QC_URI_ESCAPE*/
string(string in) uri_unescape = #511; /* Part of DP_QC_URI_ESCAPE*/
float(entity ent) num_for_edict = #512;
#define uri_post uri_get
float(string uril, float id, optional string postmimetype, optional string postdata) uri_get = #513; /* Part of DP_QC_URI_GET, DP_QC_URI_POST
		uri_get() gets content from an URL and calls a callback "uri_get_callback" with it set as string; an unique ID of the transfer is returned
		returns 1 on success, and then calls the callback with the ID, 0 or the HTTP status code, and the received data in a string
		For a POST request, you will typically want the postmimetype set to application/x-www-form-urlencoded.
		For a GET request, omit the mime+data entirely.
		Consult your webserver/php/etc documentation for best-practise. */

float(string str) tokenize_console = #514; /*
		Tokenize a string exactly as the console's tokenizer would do so. The regular tokenize builtin became bastardized for convienient string parsing, which resulted in a large disparity that can be exploited to bypass checks implemented in a naive SV_ParseClientCommand function, therefore you can use this builtin to make sure it exactly matches. */

float(float idx) argv_start_index = #515; /*
		Returns the character index that the tokenized arg started at. */

float(float idx) argv_end_index = #516; /*
		Returns the character index that the tokenized arg stopped at. */

void(strbuf strbuf, string pattern, string antipattern) buf_cvarlist = #517;
string(string cvarname) cvar_description = #518; /*
		Retrieves the description of a cvar, which might be useful for tooltips or help files. This may still not be useful. */

float(optional float timetype) gettime = #519;
void(string s) loadfromdata = #529; /*
		Reads a set of entities from the given string. This string should have the same format as a .ent file or a saved game. Entities will be spawned as required. If you need to see the entities that were created, you should use parseentitydata instead. */

void(string s) loadfromfile = #530; /*
		Reads a set of entities from the named file. This file should have the same format as a .ent file or a saved game. Entities will be spawned as required. If you need to see the entities that were created, you should use parseentitydata instead. */

void(float pause) setpause = #531; /*
		Sets whether the server should or should not be paused. This does not affect auto-paused things like when the console is down. */

float(string mname) precache_vwep_model = #532; /* Part of ZQ_VWEP*/
float(float v, optional float base) log = #532; /* Part of ??MVDSV_BUILTINS
		Determines the logarithm of the input value according to the specified base. This can be used to calculate how much something was shifted by. */

float(string filename, strbuf bufhandle) buf_loadfile = #535; /*
		Appends the named file into a string buffer (which must have been created in advance). The return value merely says whether the file was readable. */

float(filestream filehandle, strbuf bufhandle, optional float startpos, optional float numstrings) buf_writefile = #536; /*
		Writes the contents of a string buffer onto the end of the supplied filehandle (you must have already used fopen). Additional optional arguments permit you to constrain the writes to a subsection of the stringbuffer. */

float(optional float force) physics_supported = #0:physics_supported; /*
		Queries whether rigid body physics is enabled or not. CSQC and SSQC may report different values. If the force argument is used then the engine will try to activate or release physics (returning the new state, which may fail if plugins or dlls are missing). Note that restarting the physics engine is likely to result in hitches when collision trees get generated. The state may change if a plugin is disabled mid-map. */

void(entity e, float physics_enabled) physics_enable = #540; /*
		Enable or disable the physics attached to a MOVETYPE_PHYSICS entity. Entities which have been disabled in this way will stop taking so much cpu time. */

void(entity e, vector force, vector relative_ofs) physics_addforce = #541; /*
		Apply some impulse directional force upon a MOVETYPE_PHYSICS entity. */

void(entity e, vector torque) physics_addtorque = #542; /*
		Apply some impulse rotational force upon a MOVETYPE_PHYSICS entity. */

void(.../*, string funcname*/) callfunction = #605; /*
		Invokes the named function. The function name is always passed as the last parameter and must always be present. The others are passed to the named function as-is */

void(filestream fh, entity e) writetofile = #606; /*
		Writes an entity's fields to the named frik_file file handle. */

float(string s) isfunction = #607; /*
		Returns true if the named function exists and can be called with the callfunction builtin. */

float(entity e, string s, optional float offset) parseentitydata = #613; /*
		Reads a single entity's fields into an already-spawned entity. s should contain field pairs like in a saved game: {"foo1" "bar" "foo2" "5"}. Returns <=0 on failure, otherwise returns the offset in the string that was read to. */

string(entity e) generateentitydata = #0:generateentitydata; /*
		Dumps the entities fields into a string which can later be parsed with parseentitydata. */

string(string dnsname, optional float defport) netaddress_resolve = #625;
string(string fmt, ...) sprintf = #627; /* Part of DP_QC_SPRINTF*/
float(entity e, float s) getsurfacenumtriangles = #628;
vector(entity e, float s, float n) getsurfacetriangle = #629;
string(string digest, string data, ...) digest_hex = #639;
#ifdef _ACCESSORS
accessor strbuf : float
{
	inline get float asfloat[float idx] = {return stof(bufstr_get(this, idx));};
	inline set float asfloat[float idx] = {bufstr_set(this, idx, ftos(value));};
	get string[float] = bufstr_get;
	set string[float] = bufstr_set;
	get float length = buf_getsize;
};
accessor searchhandle : float
{
	get string[float] = search_getfilename;
	get float length = search_getsize;
};
accessor hashtable : float
{
	inline get vector v[string key] = {return hash_get(this, key, '0 0 0', EV_VECTOR);};
	inline set vector v[string key] = {hash_add(this, key, value, HASH_REPLACE|EV_VECTOR);};
	inline get string s[string key] = {return hash_get(this, key, "", EV_STRING);};
	inline set string s[string key] = {hash_add(this, key, value, HASH_REPLACE|EV_STRING);};
	inline get float f[string key] = {return hash_get(this, key, 0.0, EV_FLOAT);};
	inline set float f[string key] = {hash_add(this, key, value, HASH_REPLACE|EV_FLOAT);};
	inline get __variant[string key] = {return hash_get(this, key, __NULL__);};
	inline set __variant[string key] = {hash_add(this, key, value, HASH_REPLACE);};
};
accessor infostring : string
{
	get string[string] = infoget;
	inline seti& string[string fld] = {this = infoadd(this, fld, value);};
};
accessor filestream : float
{
	get string = fgets;
	inline set string = {fputs(this,value);};
};
#endif
#pragma noref 0
// Empty
//
//	Main.qc - mostly functions that will be called from the engine and are expected to exist
//

void() main =
{
};

//called for each frame that QC runs
void() StartFrame =
{
};

void() worldspawn =
{	
	precache_everything();
};

void() SpectatorConnect =
{	
};


//
//	Player.qc - Various stuff done for the player, including per-frame functions like PlayerPreThink and PlayerPostThink, also client specific stuff like PutClientInServer etc.
//

void() PlayerJump =
{
	if (!(self.flags & FL_ONGROUND))
		return;

	if ( !(self.flags & FL_JUMPRELEASED) )
		return;
	
	self.weaponframe = 0;
	self.flags = self.flags - (self.flags & FL_JUMPRELEASED);
	self.button2 = 0;
};

void() CheckImpulses =
{
	switch (self.impulse)
	{
	default: break;
	}
	self.impulse = 0;
};

vector() get_spawn_point =
{
	entity spawnpoint = world;
	spawnpoint = find(spawnpoint, classname, "info_player_start");

	return spawnpoint.origin + '0 0 1';
};

void() PlayerPreThink =
{	
	CheckImpulses();
	makevectors(self.v_angle);
	if(self.button0)
	{
		
	}
	if(self.button2)
	{
		PlayerJump();
	}
	else
	{
		self.flags = self.flags | FL_JUMPRELEASED;
	}
};

void() PlayerPostThink =
{
};

void() ClientKill =
{
};

//called when a client connects to the server
void() ClientConnect =
{
	// print("Client connect\n");
};

void() PlayerSpawn =
{
	self.classname = "player";
	self.solid = SOLID_SLIDEBOX;
	setmodel(self, "models/testplayer.iqm");
	self.movetype = MOVETYPE_WALK;
	self.health = 100;
	setorigin(self, get_spawn_point());
	self.fixangle = TRUE;
	setsize(self, [-16, -16, 0], [16, 16, 56]);
	self.view_ofs = [0, 0, 48];
};

void() PutClientInServer =
{
	player_chain_add(self);
	PlayerSpawn();
};

void() ClientDisconnect =
{
	bprint(PRINT_HIGH, self.netname);
	bprint(PRINT_HIGH, " has left the game.\n");
};


void() SetNewParms =
{
};

void() SetChangeParms =
{
};

void() info_player_start =
{
};

void(float elapsedtime) SV_PausedTic =
{
	// if (elapsedtime > 2) setpause(0);
};

void(string command_string) SV_ParseClientCommand =
{
	tokenize(command_string);
	string cmd = argv(0);
	switch (cmd)
	{
	default: break;
	}
	clientcommand(self, command_string);
};


void() SV_RunClientCommand =
{
	runstandardplayerphysics(self);
};

// Constants
float ACCELERATION = 10;
float AIR_ACCELERATION = 1;
float FRICTION = 6;
float GRAVITY = 20;
float JUMP_VELOCITY = 270;
float MAX_SPEED = 320;
float MAX_AIR_SPEED = 30;
float STOP_SPEED = 1;
float STRAFE_ACCELERATION = 50;

// Bunnyhopping constants
float BHOP_CAP = 1.2;
float BHOP_MIN_SPEED = 50;

// Initialize player variables
// Initialize player variables
vector move;
float forwardmove;
float sidemove;
float jump_time;

// Calculate the length of a vector
float length(vector v) {
    return sqrt(v_x*v_x + v_y*v_y + v_z*v_z);
}

// Main player physics function
void player_physics(float frametime) {

    // Apply friction
    float friction = FRICTION * frametime;
    float speed_old = length(self.velocity);
    float speed = max(0, speed_old - speed_old * friction);

    // Get movement input
    forwardmove = (self.impulse.use > 0) ? self.impulse.forwardmove : 0;
    sidemove = (self.impulse.use > 0) ? self.impulse.sidemove : 0;

    // Calculate movement direction
    vector direction = normalize(self.velocity);
    direction_z = 0;
    vector right = crossproduct(direction, '0 0 1');
    vector up = crossproduct(direction, right);
    vector move_direction = normalize(right * sidemove + up * forwardmove);

    // Apply movement
    float move_speed = (self.waterlevel > 1) ? MAX_AIR_SPEED : MAX_SPEED;
    move = move_speed * move_direction;
    self.velocity = self.velocity + move * frametime;

    // Apply gravity
    if (self.waterlevel <= 1) {
        self.velocity_z = self.velocity_z - GRAVITY * frametime;
    }

    // Apply jump
    if (self.waterlevel <= 1 && self.onground) {
        if (jump_time > 0 && jump_time <= 0.15) {
            self.velocity_z = JUMP_VELOCITY;
        }
        jump_time = 0;
        if (self.impulse.jump > 0) {
            self.velocity_z = JUMP_VELOCITY;
            jump_time = 0.01;
        }
    }

    // Apply air control
    if (self.waterlevel > 1) {
        self.velocity = self.velocity + move * frametime * AIR_ACCELERATION;
    } else if (self.onground) {
        self.velocity = self.velocity + move * frametime * ACCELERATION;
    } else {
        self.velocity = self.velocity + move * frametime * AIR_ACCELERATION;
    }

    // Cap velocity
    float velocity_length = length(self.velocity);
    if (velocity_length > move_speed) {
        self.velocity = (self.velocity / velocity_length) * move_speed;
    }
}
        // Adjust player's velocity based on movement input
        move[0] = self.view_angles[1] * DEGTORAD;
        if (self.groundentity != null) {
            move[0] = 0;
        }
        if (forwardmove != 0) {
            if (forwardmove < 0) {
                speed *= BACKPEDAL;
            }
            else {
                speed *= RUNSPEED;
            }
            move[0] += self.view_angles[0] * DEGTORAD;
            self.velocity += speed * normalize(vector[move[0], self.view_angles[1] * DEGTORAD, 0]);
        }
        if (sidemove != 0) {
            move[0] += (self.view_angles[1] + 90) * DEGTORAD;
            self.velocity += speed * normalize(vector[move[0], self.view_angles[1] * DEGTORAD, 0]);
        }

        // Apply gravity
        self.velocity[2] -= GRAVITY * frametime;

        // Update player's position
        self.origin += self.velocity * frametime;

        // Check if the player is on the ground
        if (self.groundentity != null) {
            jump_time = 0;
        }

        // Bunny hopping and strafe jumping
        if (self.impulse.use > 0) {
            if (self.impulse.jump > 0) {
                if (self.groundentity != null || jump_time < 0.1) {
                    self.velocity[2] = JUMP_VELOCITY;
                    jump_time = 0.1;
                }
            }
            else if (self.impulse.sidemove != 0) {
                if (self.groundentity == null) {
                    float side_speed = speed * SIDEJUMPSPEED;
                    if (self.impulse.sidemove < 0) {
                        side_speed = -side_speed;
                    }
                    move[0] = (self.view_angles[1] + 90) * DEGTORAD;
                    self.velocity += side_speed * normalize(vector[move[0], self.view_angles[1] * DEGTORAD, 0]);
                }
            }
            else if (self.impulse.forwardmove != 0) {
                if (self.groundentity == null) {
                    float forward_speed = speed * FORWARDJUMPSPEED;
                    if (self.impulse.forwardmove < 0) {
                        forward_speed = -forward_speed;
                    }
                    move[0] = self.view_angles[1] * DEGTORAD;
                    self.velocity += forward_speed * normalize(vector[move[0], self.view_angles[1] * DEGTORAD, 0]);
                }
            }
        }
    }
}


/*
void() trigger_example =
{
	setmodel(self, self.model);
	self.modelindex = 0;
	self.solid = SOLID_TRIGGER;
	self.touch = something;
};
*/

void() info_null =
{
};

void() func_illusionary =
{
	setmodel(self, self.model);
	self.solid = SOLID_NOT;
};
